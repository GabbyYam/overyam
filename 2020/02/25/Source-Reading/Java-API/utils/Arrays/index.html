<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no">

    
      <link rel="icon" href="/overyam/favicon.png" />
    

    <title>
        
          Source-Reading/Java-API/utils/Arrays - Overyam
        
    </title>

    <!-- Spectre.css framework -->
    <link rel="stylesheet" href="https://unpkg.com/spectre.css/dist/spectre.min.css">
    <link rel="stylesheet" href="https://unpkg.com/spectre.css/dist/spectre-exp.min.css">
    <link rel="stylesheet" href="https://unpkg.com/spectre.css/dist/spectre-icons.min.css">

    <!-- theme css & js -->
    
<link rel="stylesheet" href="/overyam/css/book.css">

    
<script src="/overyam/js/book.js"></script>


    <!-- tocbot -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.css">
    
    <!-- katex -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">

    
    
<script src="https://cdnjs.cloudflare.com/ajax/libs/zooming/2.1.1/zooming.min.js"></script>
<script>
document.addEventListener('DOMContentLoaded', function () {
    const zooming = new Zooming()
    zooming.listen('.book-content img')
})
</script>

<meta name="generator" content="Hexo 4.2.0"></head>

<body>

<div class="book-container">
  <div class="book-sidebar">
    <div class="book-brand">
  <a href="/overyam/">
    <img src="/overyam/favicon.png">
    <span>OVERYAM</span>
  </a>
</div>
    <div class="book-menu">
  
</div>


<script src="/overyam/js/book-menu.js"></script>

  </div>

  <div class="off-canvas-content">
    <div class="columns">
      <div class="column col-10 col-lg-12">
        <div class="book-navbar">
          <!-- For Responsive Layout -->

<header class="navbar">
  <section class="navbar-section">
    <a onclick="open_sidebar()">
      <i class="icon icon-menu"></i>
    </a>
  </section>
</header>

        </div>
        <div class="book-content">
          <div class="book-post">
  <p>[TOC]</p>
<h1 id="定义">定义</h1>
<ul>
<li>Arrays是java.util下的一个类，类中的方法（几乎都是static方法）用于各种数组相关的操作</li>
<li><strong>所有方法都抛出空指针异常</strong></li>
<li>最早出现于<strong>jdk1.2</strong></li>
<li>用到的排序算法有</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Arrays</span></span></span><br></pre></td></tr></table></figure>
<h1 id="字段属性">字段属性</h1>
<p>定义了一些使用特定排序算法的阈值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用并行排序的最小数组长度，低于此长度使用并行任务将会导致内存占用，从而令并行排序失效</span></span><br><span class="line"><span class="comment">//长度为2^13=8192，也即大于此值才会使用并行排序</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_ARRAY_SORT_GRAN = <span class="number">1</span> &lt;&lt; <span class="number">13</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数组大小小于等于此值时，将优先使用插入排序而不是归并排序</span></span><br><span class="line"><span class="comment">//To be removed in a future release.后续版本中可能会删除</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INSERTIONSORT_THRESHOLD = <span class="number">7</span>;</span><br></pre></td></tr></table></figure>
<h1 id="排序算法的选择策略">排序算法的选择策略</h1>
<h2 id="Sort-经典排序">Sort(经典排序)</h2>
<p><strong>根据传入数组的不同可能会使用以下三种算法：</strong></p>
<table>
<thead>
<tr>
<th></th>
<th>（时间复杂度）平均</th>
<th>（时间复杂度）最优</th>
<th>（时间复杂度）最差</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>快速排序</strong></td>
<td>$O(nlog(n))$</td>
<td>$O(nlog(n))$</td>
<td>$O(n^2)$</td>
</tr>
<tr>
<td><strong>插入排序</strong></td>
<td>$O(n^2)$</td>
<td>$O(n)$</td>
<td>$O(n^2)$</td>
</tr>
<tr>
<td><strong>归并排序</strong></td>
<td>$O(nlog(n))$</td>
<td>$O(nlog(n))$</td>
<td>$O(nlog(n))$</td>
</tr>
</tbody>
</table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//传入基本类型数组，默认调用外部类DualPivotQuicksort的sort方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">    DualPivotQuicksort.sort(a, <span class="number">0</span>, a.length - <span class="number">1</span>, <span class="keyword">null</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//此方法还有其他基本类型的重载版本，可以指定排序范围fromIndex，toIndex</span></span><br><span class="line"><span class="comment">//包括long、short、char、byte、float、double</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DualPivotQuicksort中的sort</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> left, <span class="keyword">int</span> right,</span></span></span><br><span class="line"><span class="function"><span class="params">                 <span class="keyword">int</span>[] work, <span class="keyword">int</span> workBase, <span class="keyword">int</span> workLen)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Use Quicksort on small arrays</span></span><br><span class="line">    <span class="comment">// QUICKSORT_THRESHOLD = 286</span></span><br><span class="line">    <span class="comment">// 大于47，小于286的小数组将使用快排 ** 小于47将使用插入排序 **</span></span><br><span class="line">    <span class="keyword">if</span> (right - left &lt; QUICKSORT_THRESHOLD) &#123;</span><br><span class="line">        sort(a, left, right, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Index run[i] is the start of i-th run</span></span><br><span class="line"><span class="comment">         * (ascending or descending sequence).</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    <span class="keyword">int</span>[] run = <span class="keyword">new</span> <span class="keyword">int</span>[MAX_RUN_COUNT + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>; run[<span class="number">0</span>] = left;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查该数组是否基本有序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = left; k &lt; right; run[count] = k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[k] &lt; a[k + <span class="number">1</span>]) &#123; <span class="comment">// ascending 升序</span></span><br><span class="line">            <span class="keyword">while</span> (++k &lt;= right &amp;&amp; a[k - <span class="number">1</span>] &lt;= a[k]);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[k] &gt; a[k + <span class="number">1</span>]) &#123; <span class="comment">// descending 降序</span></span><br><span class="line">            <span class="keyword">while</span> (++k &lt;= right &amp;&amp; a[k - <span class="number">1</span>] &gt;= a[k]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> lo = run[count] - <span class="number">1</span>, hi = k; ++lo &lt; --hi; ) &#123;</span><br><span class="line">                <span class="keyword">int</span> t = a[lo]; a[lo] = a[hi]; a[hi] = t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// equal</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> m = MAX_RUN_LENGTH; ++k &lt;= right &amp;&amp; a[k - <span class="number">1</span>] == a[k]; ) &#123;</span><br><span class="line">                <span class="keyword">if</span> (--m == <span class="number">0</span>) &#123;</span><br><span class="line">                    sort(a, left, right, <span class="keyword">true</span>);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//数组如果不是高度结构化的，即不是基本有序的，将视情况使用快排或插入排序</span></span><br><span class="line">        <span class="comment">//跳转到private static void sort(int[] a, int left, int right, boolean leftmost)</span></span><br><span class="line">        <span class="keyword">if</span> (++count == MAX_RUN_COUNT) &#123;</span><br><span class="line">            sort(a, left, right, <span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检查特殊情况</span></span><br><span class="line">    <span class="comment">// Implementation note: variable "right" is increased by 1.</span></span><br><span class="line">    <span class="keyword">if</span> (run[count] == right++) &#123; <span class="comment">// The last run contains one element</span></span><br><span class="line">        run[++count] = right;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (count == <span class="number">1</span>) &#123; <span class="comment">// 已经是有序数组</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Determine alternation base for merge</span></span><br><span class="line">    <span class="keyword">byte</span> odd = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">1</span>; (n &lt;&lt;= <span class="number">1</span>) &lt; count; odd ^= <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用一个临时数组b用于归并</span></span><br><span class="line">    <span class="keyword">int</span>[] b;                 <span class="comment">// 临时数组，和a进行归并</span></span><br><span class="line">    <span class="keyword">int</span> ao, bo;              <span class="comment">// 范围偏置</span></span><br><span class="line">    <span class="keyword">int</span> blen = right - left; <span class="comment">// b需要的最小长度</span></span><br><span class="line">    <span class="keyword">if</span> (work == <span class="keyword">null</span> || workLen &lt; blen || workBase + blen &gt; work.length) &#123;</span><br><span class="line">        work = <span class="keyword">new</span> <span class="keyword">int</span>[blen];</span><br><span class="line">        workBase = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (odd == <span class="number">0</span>) &#123;</span><br><span class="line">        System.arraycopy(a, left, work, workBase, blen);</span><br><span class="line">        b = a;</span><br><span class="line">        bo = <span class="number">0</span>;</span><br><span class="line">        a = work;</span><br><span class="line">        ao = workBase - left;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        b = work;</span><br><span class="line">        ao = <span class="number">0</span>;</span><br><span class="line">        bo = workBase - left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始归并</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> last; count &gt; <span class="number">1</span>; count = last) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = (last = <span class="number">0</span>) + <span class="number">2</span>; k &lt;= count; k += <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> hi = run[k], mi = run[k - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = run[k - <span class="number">2</span>], p = i, q = mi; i &lt; hi; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (q &gt;= hi || p &lt; mi &amp;&amp; a[p + ao] &lt;= a[q + ao]) &#123;</span><br><span class="line">                    b[i + bo] = a[p++ + ao];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    b[i + bo] = a[q++ + ao];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            run[++last] = hi;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((count &amp; <span class="number">1</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = right, lo = run[count - <span class="number">1</span>]; --i &gt;= lo;</span><br><span class="line">                 b[i + bo] = a[i + ao]</span><br><span class="line">                );</span><br><span class="line">            run[++last] = right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] t = a; a = b; b = t;</span><br><span class="line">        <span class="keyword">int</span> o = ao; ao = bo; bo = o;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果数组结构化程度不高，跳转至此</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">boolean</span> leftmost)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = right - left + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此时长度小于47的数组将会变成插入排序，反之快排</span></span><br><span class="line">    <span class="keyword">if</span> (length &lt; INSERTION_SORT_THRESHOLD) &#123;</span><br><span class="line">        <span class="keyword">if</span> (leftmost) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * Traditional (without sentinel) insertion sort,</span></span><br><span class="line"><span class="comment">                 * optimized for server VM, is used in case of</span></span><br><span class="line"><span class="comment">                 * the leftmost part.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = left, j = i; i &lt; right; j = ++i) &#123;</span><br><span class="line">                <span class="keyword">int</span> ai = a[i + <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">while</span> (ai &lt; a[j]) &#123;</span><br><span class="line">                    a[j + <span class="number">1</span>] = a[j];</span><br><span class="line">                    <span class="keyword">if</span> (j-- == left) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                a[j + <span class="number">1</span>] = ai;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * Skip the longest ascending sequence.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">while</span> (a[++left] &gt;= a[left - <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * Every element from adjoining part plays the role</span></span><br><span class="line"><span class="comment">                 * of sentinel, therefore this allows us to avoid the</span></span><br><span class="line"><span class="comment">                 * left range check on each iteration. Moreover, we use</span></span><br><span class="line"><span class="comment">                 * the more optimized algorithm, so called pair insertion</span></span><br><span class="line"><span class="comment">                 * sort, which is faster (in the context of Quicksort)</span></span><br><span class="line"><span class="comment">                 * than traditional implementation of insertion sort.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = left; ++left &lt;= right; k = ++left) &#123;</span><br><span class="line">                <span class="keyword">int</span> a1 = a[k], a2 = a[left];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (a1 &lt; a2) &#123;</span><br><span class="line">                    a2 = a1; a1 = a[left];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span> (a1 &lt; a[--k]) &#123;</span><br><span class="line">                    a[k + <span class="number">2</span>] = a[k];</span><br><span class="line">                &#125;</span><br><span class="line">                a[++k + <span class="number">1</span>] = a1;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (a2 &lt; a[--k]) &#123;</span><br><span class="line">                    a[k + <span class="number">1</span>] = a[k];</span><br><span class="line">                &#125;</span><br><span class="line">                a[k + <span class="number">1</span>] = a2;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> last = a[right];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (last &lt; a[--right]) &#123;</span><br><span class="line">                a[right + <span class="number">1</span>] = a[right];</span><br><span class="line">            &#125;</span><br><span class="line">            a[right + <span class="number">1</span>] = last;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>由以上分析可见，<strong>sort的算法选择策略</strong>可以用以下流程图表示:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A[array]</span><br><span class="line">    A --&gt; B&#123;len&gt;286?&#125;</span><br><span class="line">    B --&gt;|yes| C&#123;is nearly sorted?&#125;</span><br><span class="line">    C --&gt;|yes| M[mergeSort&#x2F;归并排序]</span><br><span class="line">    C --&gt;|no| Q[quickSort&#x2F;快排]</span><br><span class="line">    B --&gt;|no| D&#123;len&lt;47&#125;</span><br><span class="line">    D --&gt;|yes| I[insertionSort&#x2F;插入排序]</span><br><span class="line">    D --&gt;|no| Q</span><br></pre></td></tr></table></figure>
<h2 id="parallelSort-并发排序">parallelSort(并发排序)</h2>
<p><mark>该类方法是jdk1.8新增的，使用一些并发排序算法</mark></p>
<p><mark>看不太懂，待补全，请自行忽略本节</mark></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果小于MIN_ARRAY_SORT_GRAN=2^13=8192,将使用经典排序</span></span><br><span class="line"><span class="comment">//唤醒一个外部类ArraysParallelSortHelpers的内部类的内部类Sorter</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">parallelSort</span><span class="params">(<span class="keyword">byte</span>[] a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = a.length, p, g;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= MIN_ARRAY_SORT_GRAN ||</span><br><span class="line">        (p = ForkJoinPool.getCommonPoolParallelism()) == <span class="number">1</span>)</span><br><span class="line">        DualPivotQuicksort.sort(a, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// n/p</span></span><br><span class="line">        <span class="keyword">new</span> ArraysParallelSortHelpers.FJByte.Sorter</span><br><span class="line">        (<span class="keyword">null</span>, a, <span class="keyword">new</span> <span class="keyword">byte</span>[n], <span class="number">0</span>, n, <span class="number">0</span>,</span><br><span class="line">         ((g = n / (p &lt;&lt; <span class="number">2</span>)) &lt;= MIN_ARRAY_SORT_GRAN) ?</span><br><span class="line">         MIN_ARRAY_SORT_GRAN : g).invoke();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同样有多个重载版本，可以指定排序范围</span></span><br><span class="line"><span class="comment">//支持多种基本数据类型：byte、char、short、int、long、float、double</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">parallelSort</span><span class="params">(<span class="keyword">byte</span>[] a, <span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Sorter</span> <span class="keyword">extends</span> <span class="title">CountedCompleter</span>&lt;<span class="title">Void</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">2446542900576103244L</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span>[] a, w;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> base, size, wbase, gran;</span><br><span class="line">    <span class="comment">//构造方法</span></span><br><span class="line">    Sorter(CountedCompleter&lt;?&gt; par, <span class="keyword">float</span>[] a, <span class="keyword">float</span>[] w, <span class="keyword">int</span> base,</span><br><span class="line">           <span class="keyword">int</span> size, <span class="keyword">int</span> wbase, <span class="keyword">int</span> gran) &#123;</span><br><span class="line">        <span class="keyword">super</span>(par);</span><br><span class="line">        <span class="keyword">this</span>.a = a; <span class="keyword">this</span>.w = w; <span class="keyword">this</span>.base = base; <span class="keyword">this</span>.size = size;</span><br><span class="line">        <span class="keyword">this</span>.wbase = wbase; <span class="keyword">this</span>.gran = gran;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CountedCompleter&lt;?&gt; s = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">float</span>[] a = <span class="keyword">this</span>.a, w = <span class="keyword">this</span>.w; <span class="comment">// localize all params</span></span><br><span class="line">        <span class="keyword">int</span> b = <span class="keyword">this</span>.base, n = <span class="keyword">this</span>.size, wb = <span class="keyword">this</span>.wbase, g = <span class="keyword">this</span>.gran;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; g) &#123;</span><br><span class="line">            <span class="keyword">int</span> h = n &gt;&gt;&gt; <span class="number">1</span>, q = h &gt;&gt;&gt; <span class="number">1</span>, u = h + q; <span class="comment">// quartiles</span></span><br><span class="line">            Relay fc = <span class="keyword">new</span> Relay(<span class="keyword">new</span> Merger(s, w, a, wb, h,</span><br><span class="line">                                            wb+h, n-h, b, g));</span><br><span class="line">            Relay rc = <span class="keyword">new</span> Relay(<span class="keyword">new</span> Merger(fc, a, w, b+h, q,</span><br><span class="line">                                            b+u, n-u, wb+h, g));</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//开启</span></span><br><span class="line">            <span class="keyword">new</span> Sorter(rc, a, w, b+u, n-u, wb+u, g).fork();</span><br><span class="line">            <span class="keyword">new</span> Sorter(rc, a, w, b+h, q, wb+h, g).fork();;</span><br><span class="line">            Relay bc = <span class="keyword">new</span> Relay(<span class="keyword">new</span> Merger(fc, a, w, b, q,</span><br><span class="line">                                            b+q, h-q, wb, g));</span><br><span class="line">            <span class="keyword">new</span> Sorter(bc, a, w, b+q, h-q, wb+q, g).fork();</span><br><span class="line">            s = <span class="keyword">new</span> EmptyCompleter(bc);</span><br><span class="line">            n = q;</span><br><span class="line">        &#125;</span><br><span class="line">        DualPivotQuicksort.sort(a, b, b + n - <span class="number">1</span>, w, wb, n);</span><br><span class="line">        s.tryComplete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="部分方法解析">部分方法解析</h1>
<h2 id="equals-deepEquals">equals &amp; deepEquals</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//支持所有基本数据类型和对象，其中对象的比较使用equals，具体要看传入的类是否重写了equals方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(<span class="keyword">long</span>[] a, <span class="keyword">long</span>[] a2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//地址相同，判定为相同</span></span><br><span class="line">    <span class="keyword">if</span> (a==a2)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">//都为null，判定为不同</span></span><br><span class="line">    <span class="keyword">if</span> (a==<span class="keyword">null</span> || a2==<span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">int</span> length = a.length;</span><br><span class="line">    <span class="keyword">if</span> (a2.length != length)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	<span class="comment">//逐一对比元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;length; i++)</span><br><span class="line">        <span class="keyword">if</span> (a[i] != a2[i])</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//深度判同，支持多维数组和多层嵌套</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">deepEquals0</span><span class="params">(Object e1, Object e2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> e1 != <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> eq;</span><br><span class="line">    <span class="keyword">if</span> (e1 <span class="keyword">instanceof</span> Object[] &amp;&amp; e2 <span class="keyword">instanceof</span> Object[])</span><br><span class="line">        eq = deepEquals ((Object[]) e1, (Object[]) e2);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (e1 <span class="keyword">instanceof</span> <span class="keyword">byte</span>[] &amp;&amp; e2 <span class="keyword">instanceof</span> <span class="keyword">byte</span>[])</span><br><span class="line">        eq = equals((<span class="keyword">byte</span>[]) e1, (<span class="keyword">byte</span>[]) e2);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (e1 <span class="keyword">instanceof</span> <span class="keyword">short</span>[] &amp;&amp; e2 <span class="keyword">instanceof</span> <span class="keyword">short</span>[])</span><br><span class="line">        eq = equals((<span class="keyword">short</span>[]) e1, (<span class="keyword">short</span>[]) e2);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (e1 <span class="keyword">instanceof</span> <span class="keyword">int</span>[] &amp;&amp; e2 <span class="keyword">instanceof</span> <span class="keyword">int</span>[])</span><br><span class="line">        eq = equals((<span class="keyword">int</span>[]) e1, (<span class="keyword">int</span>[]) e2);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (e1 <span class="keyword">instanceof</span> <span class="keyword">long</span>[] &amp;&amp; e2 <span class="keyword">instanceof</span> <span class="keyword">long</span>[])</span><br><span class="line">        eq = equals((<span class="keyword">long</span>[]) e1, (<span class="keyword">long</span>[]) e2);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (e1 <span class="keyword">instanceof</span> <span class="keyword">char</span>[] &amp;&amp; e2 <span class="keyword">instanceof</span> <span class="keyword">char</span>[])</span><br><span class="line">        eq = equals((<span class="keyword">char</span>[]) e1, (<span class="keyword">char</span>[]) e2);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (e1 <span class="keyword">instanceof</span> <span class="keyword">float</span>[] &amp;&amp; e2 <span class="keyword">instanceof</span> <span class="keyword">float</span>[])</span><br><span class="line">        eq = equals((<span class="keyword">float</span>[]) e1, (<span class="keyword">float</span>[]) e2);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (e1 <span class="keyword">instanceof</span> <span class="keyword">double</span>[] &amp;&amp; e2 <span class="keyword">instanceof</span> <span class="keyword">double</span>[])</span><br><span class="line">        eq = equals((<span class="keyword">double</span>[]) e1, (<span class="keyword">double</span>[]) e2);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (e1 <span class="keyword">instanceof</span> <span class="keyword">boolean</span>[] &amp;&amp; e2 <span class="keyword">instanceof</span> <span class="keyword">boolean</span>[])</span><br><span class="line">        eq = equals((<span class="keyword">boolean</span>[]) e1, (<span class="keyword">boolean</span>[]) e2);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        eq = e1.equals(e2);</span><br><span class="line">    <span class="keyword">return</span> eq;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="toString-deepToString">toString &amp; deepToString</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//支持基本类型数据和对象</span></span><br><span class="line"><span class="comment">//使用StringBuilder构建字符串</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">toString</span><span class="params">(<span class="keyword">long</span>[] a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"null"</span>;</span><br><span class="line">    <span class="keyword">int</span> iMax = a.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (iMax == -<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"[]"</span>;</span><br><span class="line"></span><br><span class="line">    StringBuilder b = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    b.append(<span class="string">'['</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; ; i++) &#123;</span><br><span class="line">        b.append(a[i]);</span><br><span class="line">        <span class="keyword">if</span> (i == iMax)</span><br><span class="line">            <span class="keyword">return</span> b.append(<span class="string">']'</span>).toString();</span><br><span class="line">        b.append(<span class="string">", "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//支持多维数组和多重嵌套的toString</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">deepToString</span><span class="params">(Object[] a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"null"</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//预留20倍长度</span></span><br><span class="line">    <span class="keyword">int</span> bufLen = <span class="number">20</span> * a.length;</span><br><span class="line">    <span class="keyword">if</span> (a.length != <span class="number">0</span> &amp;&amp; bufLen &lt;= <span class="number">0</span>)</span><br><span class="line">        bufLen = Integer.MAX_VALUE;</span><br><span class="line">    StringBuilder buf = <span class="keyword">new</span> StringBuilder(bufLen);</span><br><span class="line">    deepToString(a, buf, <span class="keyword">new</span> HashSet&lt;Object[]&gt;());</span><br><span class="line">    <span class="keyword">return</span> buf.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="fill">fill</h2>
<p>快速填充数组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fill</span><span class="params">(<span class="keyword">long</span>[] a, <span class="keyword">long</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, len = a.length; i &lt; len; i++)</span><br><span class="line">        a[i] = val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//支持所有基本类型数据和对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fill</span><span class="params">(<span class="keyword">long</span>[] a, <span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex, <span class="keyword">long</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//越界判定</span></span><br><span class="line">    rangeCheck(a.length, fromIndex, toIndex);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = fromIndex; i &lt; toIndex; i++)</span><br><span class="line">        a[i] = val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="binarySearch">binarySearch</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">long</span>[] a, <span class="keyword">long</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> binarySearch0(a, <span class="number">0</span>, a.length, key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//经典二分查找,前提是数组必须有序</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch0</span><span class="params">(<span class="keyword">long</span>[] a, <span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">long</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//头尾指针</span></span><br><span class="line">    <span class="keyword">int</span> low = fromIndex;</span><br><span class="line">    <span class="keyword">int</span> high = toIndex - <span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//注意循环的终止条件是小于等于，如果写成小于的话会出现找不到的情况</span></span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (low + high) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> midVal = a[mid];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (midVal &lt; key)</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (midVal &gt; key)</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> mid; <span class="comment">// 返回所查值的key</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -(low + <span class="number">1</span>);  <span class="comment">// 找不到，返回一个负数-(low+1)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="asList">asList</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用ArrayList的构造方法返回list</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">asList</span><span class="params">(T... a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="从Arrays类看排序算法的适用场景">从Arrays类看排序算法的适用场景</h1>
<p>待补全</p>

</div>


  <div class="book-comments">
    




  </div>



<script src="/overyam/js/book-post.js"></script>

        </div>
      </div>
      <div class="column col-2 hide-lg">
        <div class="book-post-info">
  
    <div class="book-post-meta">

  <div class="author">

    <!-- Author image -->
    <div class="author-img">
      
        <figure
          class="avatar avatar-lg"
          data-initial="G"
          style="background-color: #3b4351;">
        </figure>
      
    </div>

    <!-- Author title -->
    <div class="author-title">
      <div>GabbyYam</div>
      <div>2020-02-25</div>
    </div>
  </div>

  

  <div class="divider"></div>
</div>
  

  <div class="book-tocbot">
</div>
<div class="book-tocbot-menu">
  <a class="book-toc-expand" onclick="expand_toc()">Expand all</a>
  <a onclick="go_top()">Back to top</a>
  <a onclick="go_bottom()">Go to bottom</a>
</div>


<script src="/overyam/js/book-toc.js"></script>

</div>
      </div>
    </div>
  </div>
  
  <a class="off-canvas-overlay" onclick="hide_canvas()"></a>
</div>

</body>
</html>


<script src="/overyam/js/book.js"></script>
