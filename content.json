{"meta":{"title":"Overyam","subtitle":"欢迎来到世界的尽头..才怪啦","description":"写点自己喜欢的东西","author":"GabbyYam","url":"https://gabbyyam.github.io/overyam","root":"/overyam/"},"pages":[],"posts":[{"title":"String-Easy","slug":"String-Easy","date":"un33fin33","updated":"un33fin33","comments":true,"path":"2020/02/26/String-Easy/","link":"","permalink":"https://gabbyyam.github.io/overyam/2020/02/26/String-Easy/","excerpt":"Abstract： 更新部分Easy难度 string相关题解","text":"Abstract： 更新部分Easy难度 string相关题解 13. Roman to Integer 解法一：Hash表 优先判定两个字符的值，其他没什么可说的 class Solution { public int romanToInt(String s) { Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); map.put(&quot;I&quot;, 1); map.put(&quot;IV&quot;, 4); map.put(&quot;V&quot;, 5); map.put(&quot;IX&quot;, 9); map.put(&quot;X&quot;, 10); map.put(&quot;XL&quot;, 40); map.put(&quot;L&quot;, 50); map.put(&quot;XC&quot;, 90); map.put(&quot;C&quot;, 100); map.put(&quot;CD&quot;, 400); map.put(&quot;D&quot;, 500); map.put(&quot;CM&quot;, 900); map.put(&quot;M&quot;, 1000); int ans=0; for(int i=0;i&lt;s.length();i++){ if(i+1&lt;s.length() &amp;&amp; map.containsKey(s.substring(i,i+2))){ ans+=map.get(s.substring(i,i+2)); i++; } else ans+=map.get(s.substring(i,i+1)); } return ans; } } 14. Longest Common Prefix 解法一：线性扫描（从前往后） class Solution { public String longestCommonPrefix(String[] strs) { if(strs.length==0 || strs==null){return &quot;&quot;;} String common=&quot;&quot;; int min_len=Integer.MAX_VALUE; for(String s:strs){min_len=Math.min(min_len,s.length());} //先找最小长度min_len for(int curr=0;curr&lt;min_len;curr++){ char c=strs[0].charAt(curr); //以第一个为准 for(String s:strs){if(s.charAt(curr)!=c)return common;} common+=c; } return common; } } [改进版] String：改进了String的操作相关，String重载的==+操作==相当耗时，因此不使用字符串拼接，而是substring的方法 **遍历：**根本不需要找到最短的字符串，只要遍历时多判断一次是否超出就行了 **效果：**12ms -&gt;2ms class Solution { public String longestCommonPrefix(String[] strs) { if(strs.length==0 || strs==null){return &quot;&quot;;} for(int curr=0;curr&lt;strs[0].length();curr++){ char c=strs[0].charAt(curr); for(String s:strs){ if(s.length()==curr || s.charAt(curr)!=c) //新增s.length()==curr判断一下就行 return strs[0].substring(0,curr); //改为substring,String+操作是相当费时的 } } return strs[0]; } } 解法二：线性扫描（从后往前） public String longestCommonPrefix(String[] strs) { if (strs.length == 0) return &quot;&quot;; String prefix = strs[0]; for (int i = 1; i &lt; strs.length; i++) while (strs[i].indexOf(prefix) != 0) { //以第一个为准 prefix = prefix.substring(0, prefix.length() - 1); //如果不满足，每次缩小一个字符 if (prefix.isEmpty()) return &quot;&quot;; //直到为空 } return prefix; } 20. Valid Parentheses 解法一：栈（标准解法） class Solution { public boolean isValid(String s) { Stack&lt;Character&gt; stack = new Stack&lt;Character&gt;(); for(int curr=0;curr&lt;s.length();curr++){ char c=s.charAt(curr); if(c=='(' || c=='[' || c=='{') //如果是左括号，压入栈中 stack.push(c); else if(c==')'){ //如果是右括号，检查栈是否为空，不为空的话检查是否匹配 if(stack.isEmpty() || stack.pop()!='(')return false; //注意isEmpty在前 } else if(c==']'){ if(stack.isEmpty() || stack.pop()!='[')return false; } else if(c=='}'){ if(stack.isEmpty() || stack.pop()!='{')return false; } } return stack.isEmpty();//最后如果栈空则为ture,否则为false } } 28. Implement strStr() 解法一：猥琐API法（太脏了，自裁） class Solution { public int strStr(String haystack, String needle) { return haystack.indexOf(needle); //这题要实现的就是indexOf的功能 } } 解法二：暴力匹配 class Solution { public int strStr(String haystack, String needle) { //以下三者均会卡掉for循环，需要特别处理，且equals要第一个判定，否则第二条需要进一步限定 if(haystack.equals(needle))return 0; //字典等于词 if(haystack.length()==0)return -1; //字典为空 if(needle.length()==0) return 0; //词为空 //注意curr_hay&lt;haystack.length()-needle.length()+1，必须+1，否则匹配不到最后一位 for(int curr_hay=0;curr_hay&lt;haystack.length()-needle.length()+1;curr_hay++){ for(int curr_nee=0;curr_nee&lt;needle.length();curr_nee++){ if(haystack.charAt(curr_hay+curr_nee)!=needle.charAt(curr_nee)) break; if(curr_nee==needle.length()-1)//匹配到最后一个依然正确，返回此时的curr_hay return curr_hay; } } return -1; //没找到则返回-1 } } 解法三：KMP（以后再说吧） //问就是不会 58. Length of Last Word 要点分析 **特殊情况：**末尾有空格 如何找到最后一个空格？ 连续空格怎么处理？ 解法一：分段切割 **缺点：**substring耗时，trim耗时 class Solution { public int lengthOfLastWord(String s) { s=s.trim(); //开局剪切，保证末尾没有空格 String res=s; for(int i=0;i&lt;s.length();i++){ if(s.charAt(i)==' ')res=s.substring(i+1,s.length()); //每遇到一个空格，把前面的砍掉 } return res.length(); //最后的长度即为所求 } } 改进版，从后往前切割，大大节省时间 class Solution { public int lengthOfLastWord(String s) { s=s.trim(); //开局剪切，保证末尾没有空格 String res=s; for(int i=s.length()-1;i&gt;-1;i--){ //从后往前砍 if(s.charAt(i)==' '){return s.substring(i+1,s.length());} } return res.length(); //最后的长度即为所求 } }","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://gabbyyam.github.io/overyam/categories/Algorithm/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://gabbyyam.github.io/overyam/tags/leetcode/"}]},{"title":"Tree-Medium","slug":"Tree-Medium","date":"un33fin33","updated":"un44fin44","comments":true,"path":"2020/02/26/Tree-Medium/","link":"","permalink":"https://gabbyyam.github.io/overyam/2020/02/26/Tree-Medium/","excerpt":"Abstract： 更新部分Medium难度 Tree相关题解","text":"Abstract： 更新部分Medium难度 Tree相关题解 94. Binary Tree Inorder Traversal 解法一：递归法 没什么好说的，不会砍手 class Solution { List&lt;Integer&gt; inorder=new ArrayList&lt;Integer&gt;(); public List&lt;Integer&gt; inorderTraversal(TreeNode root) { if(root!=null){ inorder=inorderTraversal(root.left); inorder.add(root.val); inorder=inorderTraversal(root.right);} return inorder; } } 解法二：迭代法 比递归法难理解一些，重点是理解好如何回溯 class Solution { List&lt;Integer&gt; inorder=new ArrayList&lt;Integer&gt;(); Stack&lt;TreeNode&gt; stack=new Stack&lt;TreeNode&gt;(); public List&lt;Integer&gt; inorderTraversal(TreeNode root) { TreeNode curr=root; //辅助接点curr，指向当前访问的TreeNode while(curr!=null || !stack.isEmpty()){ //当前访问的节点不为空或栈不为空，说明还没遍历完 while(curr!=null){ //不断压入左节点 stack.push(curr); curr=curr.left; } curr=stack.pop(); //**回溯** inorder.add(curr.val); //将当前访问的节点加入 curr=curr.right; //如果有右节点则访问右节点，如果没有将在下一轮回溯或者结束 } return inorder; } } 解法三： 莫比斯遍历 //待补全 96. Unique Binary Search Trees 解法一：递归法 **思路：**分别以1-n的任意整数为根，那么左右子树有哪些值是可以确定的，因此可以递归地来做 要点：{4,5,6,7,8}在此处可以等价于{1,2,3,4,5}，因此可以很方便的进行递归，但是在这里只是个取巧的做法 **缺点：**没有保存递归结果，增加了许多重复的操作，下一个解法考虑对结果进行缓存 class Solution { public int numTrees(int n) { if(n&lt;=1)return 1; //特殊情况，以及递归的基准 int uniqueNum=0; for(int i=1;i&lt;=n;i++){uniqueNum+=numTrees(i-1)*numTrees(n-i);} //递归左右区间的乘积 return uniqueNum; } } 解法二：记忆化递归 直接递归的缺点是重复递归很多地方，所以需要剪枝 class Solution { public int numTrees(int n) { int[] dp=new int[n+1]; return dynamicNumTrees(n,dp); } public int dynamicNumTrees(int n,int[] dp){ if(n&lt;=1){return 1;} if(dp[n]!=0){return dp[n];} //加入缓存 for(int i=1;i&lt;=n;i++){dp[n]+=dynamicNumTrees(i-1,dp)*dynamicNumTrees(n-i,dp);} return dp[n]; } } 95. Unique Binary Search Trees II 解法一：递归法 和上题类似的递归思路，不过注意root的创建时机 class Solution { public List&lt;TreeNode&gt; generateTrees(int n) { if(n==0)return new LinkedList&lt;TreeNode&gt;(); //特殊情况 return generate(1,n); } public List&lt;TreeNode&gt; generate(int lo,int hi){ List&lt;TreeNode&gt; BSTs=new LinkedList&lt;TreeNode&gt;(); //注意ArrayList不能加入null if(lo&gt;hi){BSTs.add(null);return BSTs;} //加入null if(lo==hi){BSTs.add(new TreeNode(lo));return BSTs;} //递归边界 for(int i=lo;i&lt;=hi;i++){ List&lt;TreeNode&gt; leftList=generate(lo,i-1); List&lt;TreeNode&gt; rightList=generate(i+1,hi); //分别取得左右子树的递归结果 for(TreeNode leftRoot:leftList){ for(TreeNode rightRoot:rightList){ TreeNode root=new TreeNode(i);//root应该在循环体内new，否则会和上一轮的混淆 root.left=leftRoot; root.right=rightRoot; BSTs.add(root); } } } return BSTs; } } 解法二：记忆化递归 //这是啥? 105. Construct Binary Tree from Preorder and Inorder Traversal 解法一：递归法 这题的重点是如何分别在inorder和preorder中划分左右子树 preorder的头部是root **inorder如何划分：**在inorder中找到root，那么在此之前的为left，之后的为right **preorder如何划分：**inorder中，left-root即为left的长度leftSize，由此推出以下关系 //左子树 next_p_lo=p_lo+1; next_p_hi=p_lo+leftSize; next_i_lo=i_lo; next_i_hi=i_lo+leftSize+1; //右子树 next_p_lo=p_lo+leftSize+1; next_p_hi=p_hi; next_i_lo=i_lo+leftSize+1; next_i_hi=p_hi; class Solution { public TreeNode buildTree(int[] preorder, int[] inorder) { int len=preorder.length-1; return build(preorder,inorder,0,len,0,len); } public TreeNode build(int[] preorder,int[] inorder,int p_lo,int p_hi,int i_lo,int i_hi){ if(p_lo&gt;p_hi || i_lo&gt;i_hi){return null;} //越界判定 &amp; 递归结束 int leftSize=0; for(int i=i_lo;i&lt;=i_hi;i++){ //在inorder中找到root并算出leftSize if(inorder[i]==preorder[p_lo]){leftSize=i-i_lo;} } TreeNode root=new TreeNode(preorder[p_lo]); //依据已有关系，构造根节点和左右子树 root.left=build(preorder,inorder,p_lo+1,p_lo+leftSize,i_lo,i_lo+leftSize-1); root.right=build(preorder,inorder,p_lo+leftSize+1,p_hi,i_lo+leftSize+1,i_hi); return root; } } &lt;p class=&quot;code-caption&quot; data-lang=&quot;&quot; data-line_number=&quot;frontend&quot; data-trim_indent=&quot;backend&quot; data-label_position=&quot;outer&quot; data-labels_left=&quot;Code&quot; data-labels_right=&quot;:&quot; data-labels_copy=&quot;Copy Code&quot;&gt;&lt;span class=&quot;code-caption-label&quot;&gt;&lt;/span&gt;&lt;/p&gt; 98. Validate Binary Search Tree 解法一：中序遍历 判断BST，容易简单认为是只要左子树比根节点小，右子树比根节点大，以此递归就行 但是，上述策略忽略了一点：左子树&lt;右子树 因此必须保证这一点，考虑到BST的特性：中序遍历，得出以下解法 class Solution { List&lt;Integer&gt; inorder=new ArrayList&lt;Integer&gt;(); public boolean isValidBST(TreeNode root) { inorder(root); for(int i=1;i&lt;inorder.size();i++){ //检查中序遍历结果是否顺序即可 if(inorder.get(i)&lt;=inorder.get(i-1))return false; } return true; } public void inorder(TreeNode root){ if(root!=null){ inorder(root.left); inorder.add(root.val); inorder(root.right); } } } 解法二：迭代法 边迭代边检查，还可以写成递归法，不过同理就不写了 class Solution { Stack&lt;TreeNode&gt; stack=new Stack&lt;TreeNode&gt;(); public boolean isValidBST(TreeNode root) { if(root==null)return true; TreeNode curr=root; Integer val=null; //注意这里要用Integer而不是int，因为可以用null,不然无论设成什么都能被卡掉 while(curr!=null || !stack.isEmpty()){ while(curr!=null){ stack.push(curr); curr=curr.left; } curr=stack.pop(); if(val!=null &amp;&amp; curr.val&lt;=val){return false;} //错误判定 val=curr.val; curr=curr.right; } return true; } }","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://gabbyyam.github.io/overyam/categories/Algorithm/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://gabbyyam.github.io/overyam/tags/leetcode/"}]},{"title":"Tree-Easy","slug":"Tree-Easy","date":"un33fin33","updated":"un33fin33","comments":true,"path":"2020/02/26/Tree-Easy/","link":"","permalink":"https://gabbyyam.github.io/overyam/2020/02/26/Tree-Easy/","excerpt":"Abstract： 更新部分Easy难度 Tree相关题解","text":"Abstract： 更新部分Easy难度 Tree相关题解 965. Univalued Binary Tree /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ 解法一：递归遍历 记录根节点的值，逐一向下遍历即可 class Solution { public boolean isUnivalTree(TreeNode root) { if(root==null){return true;}//注意这里要判空一次，否则root.val会报空指针 return isUnival(root,root.val); } public boolean isUnival(TreeNode root,int val){ if(root==null){return true;} if(root.val!=val){return false;} return isUnival(root.left,val) &amp;&amp; isUnival(root.right,val); //左右都true才是true } } 112. Path Sum 解法一： DFS DFS的核心三步： 终止条件：root==null的时候返回什么？ 处理过程：对root和root.val 如何处理？ 递归条件：对左右子树如何处理？ class Solution { public boolean hasPathSum(TreeNode root, int sum) { if(root==null){return false;} //为空时返回false,考虑空树和空子树的情况可以得到这个结论 sum-=root.val; //减去当前val if(root.left==null &amp;&amp; root.right==null){ //为叶子节点时，要判断是不是满足条件 if(sum==0){return true;} else return false; } return hasPathSum(root.left,sum) || hasPathSum(root.right,sum); //左右子树一方满足即可 } } 100. Same Tree 解法一：递归法 判空，分两种情况，两者都为空和只有一者为空 比值，对比值是否相等 递归，递归左右子树的结果，取**&amp;&amp;** class Solution { public boolean isSameTree(TreeNode p, TreeNode q) { if(p==null &amp;&amp; q==null){return true;} //如果都为空，视为相等 if(p==null || q==null){return false;} //如果一方为空，显然是不等 if(p.val!=q.val){return false;} //比较val return isSameTree(p.left,q.left) &amp;&amp; isSameTree(p.right,q.right); //递归左右子树 } } 解法二：迭代法(没搞懂，以后再看) class Solution { public boolean check(TreeNode p,TreeNode q){ if(p==null &amp;&amp; q==null){return true;} //如果都为空，视为相等 if(p==null || q==null){return false;} //如果一方为空，显然是不等 if(p.val!=q.val){return false;} //比较val return true; } public boolean isSameTree(TreeNode p,TreeNode q){ if(!check(p,q)){return false;} //下面没写完 } } 111. Minimum Depth of Binary Tree 解法一：递归遍历 判空：空时为0 判断是否为叶子节点：如果是返回1 判断是否有一边为null：如果只有一边为null的话，应该对其忽略不计，否则会把此处错误地当做最小深度 递归：最小深度为左右子树的最小深度中更小的那者再+1 class Solution { public int minDepth(TreeNode root) { if(root==null){return 0;} //判空 if(root.left==null &amp;&amp; root.right==null){return 1;} //对叶子节点的处理 if(root.left==null || root.right==null){ //如果只有一方为空要忽略处理，这里用的是max的方法 return Math.max(1+minDepth(root.left),1+minDepth(root.right));} return 1+Math.min(minDepth(root.left),minDepth(root.right)); //递归的最小值+1即为结果 } } 257. Binary Tree Paths 解法一： 标准DFS 没啥可说的，标准DFS不会剁手 class Solution { public List&lt;String&gt; binaryTreePaths(TreeNode root) { return TreePaths(root,&quot;&quot;,new ArrayList&lt;String&gt;()); } public List&lt;String&gt; TreePaths(TreeNode root,String path,List&lt;String&gt; paths){ if(root!=null){ //判空，为空不加入 path+=root.val; //先拼val if(root.left==null&amp;root.right==null){ //如果是叶子节点，那么add path paths.add(path); } else{ //否则继续递归，拼上 '-&gt;' path+=&quot;-&gt;&quot;; TreePaths(root.left,path,paths); TreePaths(root.right,path,paths); } } return paths; //返回结果 } }","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://gabbyyam.github.io/overyam/categories/Algorithm/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://gabbyyam.github.io/overyam/tags/leetcode/"}]},{"title":"Greedy-Easy","slug":"Greedy-Easy","date":"un33fin33","updated":"un33fin33","comments":true,"path":"2020/02/26/Greedy-Easy/","link":"","permalink":"https://gabbyyam.github.io/overyam/2020/02/26/Greedy-Easy/","excerpt":"Abstract： 更新部分Easy难度 Greedy相关题解","text":"Abstract： 更新部分Easy难度 Greedy相关题解 122. Best Time to Buy and Sell Stock II 解法一：贪心 显然，如果允许无限次交易的话，那么只要有差价就能赚，因此总利润就是升价之和 class Solution { public int maxProfit(int[] prices) { if(prices.length&lt;=1){return 0;} //特殊情况 int profit=0; for(int i=1;i&lt;prices.length;i++){ int check=prices[i]-prices[i-1]; profit+=check&gt;0?check:0; //只要本次交易有利可得就去赚，必定能使利益最大化 } return profit; } } 455. Assign Cookies 解法一：贪心 策略：先排序，用最小的饼干先喂胃口最小的小鬼 特殊情况：两者可能为空要注意，但是本题不会有不良影响就是了 class Solution { public int findContentChildren(int[] g, int[] s) { Arrays.sort(g); Arrays.sort(s);//先排序 int cookie=0,maxAssign=0;//记录饼干的位置和最大人数 for(int i=0;i&lt;g.length;i++){ while(cookie&lt;s.length){ if(s[cookie]&gt;=g[i]){//如果满足的话，人数++，饼干用掉了所以移动到下一块，cookie++ maxAssign++; cookie++; break;//代码中注意不要出现break，影响美观，这里是反面教材了 } cookie++;//不满足的话就换下一个饼干 } } return maxAssign; } } 简洁版：根本不需要专门记录最大人数，另外改掉break这样的不良习惯，出现break只会让代码丑且丢人 class Solution { public int findContentChildren(int[] g, int[] s) { Arrays.sort(g); Arrays.sort(s);//先排序 int cookie=0,greedy=0;//记录饼干的位置、小鬼位置 while(cookie&lt;s.length &amp;&amp; greedy&lt;g.length){ if(g[greedy]&lt;=s[cookie])greedy++; cookie++; } return greedy;//根本不需要记录最大人数，greedy的最终值就是最大人数 } } 1046. Last Stone Weight（TopK问题） 解法一：排序 依题意，每次都用最重的两块石头，那么就每轮排一次序就行了 虽然简洁易懂，但是缺点是快排空间消耗比较大，另外数据规模大时额外消耗的时间也比较大 class Solution { public int lastStoneWeight(int[] stones) { if(stones==null || stones.length==0){return 0;} //特殊情况 null或为空 int stoneNum=stones.length,len=stones.length; while(stoneNum&gt;1){//每轮都排一次序，直到石头小于一颗 Arrays.sort(stones); stones[len-1]=stones[len-1]-stones[len-2]; stones[len-2]=0; stoneNum--; } return stones[len-1];//返回最后一颗石子的重量即为答案 } } 解法二：优先队列 由于问题本质是TopK问题，因此用优先队列是相当王道的做法 小数据下比简单排序略逊，但是数据量增大时优于排序 class Solution { public int lastStoneWeight(int[] stones) { if(stones==null || stones.length==0){return 0;} Queue&lt;Integer&gt; stoneQ= new PriorityQueue&lt;Integer&gt;(Collections.reverseOrder());//优先队列 for(int stone:stones){stoneQ.add(stone);}//初始化 while(stoneQ.size()&gt;2){//边界处理，如果&gt;1的话可能会让空队列poll int stoneSmashed=stoneQ.poll()-stoneQ.poll(); if(stoneSmashed&gt;0)stoneQ.add(stoneSmashed);//如果没彻底smashed，就放回队列中 } return stoneQ.size()&gt;1?stoneQ.poll()-stoneQ.poll():stoneQ.peek(); //依据情况返回对应结果 } } 860. Lemonade Change 解法一：贪心 如果是5块和10块没什么可说的，重点是20块 如果是20块，要优先找10块和5块组合，实在不行才用三张5块 class Solution { public boolean lemonadeChange(int[] bills) { int five=0,ten=0;//分别记录5块和10块 for(int i=0;i&lt;bills.length;i++){ if(bills[i]==5)five++; //5块时直接++ else if(bills[i]==10){ //10块时直接找5块，没有就gg if(five&gt;0){ten++;five--;} else return false; } else if(bills[i]==20){ //优先找10块 if(ten&gt;0 &amp;&amp; five&gt;0){ten--;five--;} else if(five&gt;=3){five-=3;} else return false; } } return true; } } 874. Walking Robot Simulation 解法一：HashSet+模拟 麻烦在写逻辑 class Solution { public int robotSim(int[] commands, int[][] obstacles) { int x=0,y=0,turn=0,maxDistance=0; int[] moves = new int[2]; //借用官方的编码模式 Set&lt;Long&gt; obstacleSet = new HashSet(); for (int[] obstacle: obstacles) { long ox = (long) obstacle[0] + 30000; long oy = (long) obstacle[1] + 30000; obstacleSet.add((ox &lt;&lt; 16) + oy); } for(int i=0;i&lt;commands.length;i++){ if(commands[i] == -1){turn=(turn+1)%4;} //右转90度 else if(commands[i] == -2){turn=(turn+3)%4;} //左转90度，注意不要--，因为负数不能% else{ //否则应该是移动 for(int k=0;k&lt;commands[i];k++){ //一格一格地走 moves = move(turn,moves); //根据方向和command计算移动的(x,y) int nx=x+moves[0]; int ny=y+moves[1]; long code = (((long) nx + 30000) &lt;&lt; 16) + ((long) ny + 30000); if (!obstacleSet.contains(code)) { x = nx; y = ny; maxDistance = Math.max(maxDistance, x*x + y*y); } } } } return maxDistance; } public int[] move(int turn,int[] moves){ //判断移动的x,y if(turn%4 == 0){moves[0]=0;moves[1]=1;return moves;} else if(turn%4 == 1){moves[0]=1;moves[1]=0;return moves;} else if(turn%4 == 2){moves[0]=0;moves[1]=-1;return moves;} else if(turn%4 == 3){moves[0]=-1;moves[1]=0;return moves;} return moves; //throw new IllegalArgumentException; } }","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://gabbyyam.github.io/overyam/categories/Algorithm/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://gabbyyam.github.io/overyam/tags/leetcode/"}]},{"title":"Linkedlist-Easy","slug":"Linkedlist-Easy","date":"un33fin33","updated":"un33fin33","comments":true,"path":"2020/02/26/Linkedlist-Easy/","link":"","permalink":"https://gabbyyam.github.io/overyam/2020/02/26/Linkedlist-Easy/","excerpt":"Abstract： 更新部分Easy难度 Linkedlist相关题解","text":"Abstract： 更新部分Easy难度 Linkedlist相关题解 21. Merge Two Sorted Lists 解法一：递归法 class Solution { public ListNode mergeTwoLists(ListNode l1, ListNode l2) { if(l1==null)return l2; else if(l2==null)return l1; else if(l1.val&lt;l2.val){ l1.next=mergeTwoLists(l1.next,l2); return l1; } else { l2.next=mergeTwoLists(l2.next,l1); return l2; } } } 解法二：迭代法 class Solution { public ListNode mergeTwoLists(ListNode l1, ListNode l2) { ListNode pre_head=new ListNode(-1); //合并结果的头结点，pre_head.next开始为答案 ListNode curr=pre_head; //指向当前访问节点 while(l1!=null &amp;&amp; l2!=null){ if(l1.val&lt;l2.val){ //根据大小判断先放谁 curr.next=l1; l1=l1.next; } else { curr.next=l2; l2=l2.next; } curr=curr.next; } curr.next=l1==null?l2:l1; //当一方为null时，另一方的剩余部分放入解的尾部 return pre_head.next; } } 83. Remove Duplicates from Sorted List 解法一：迭代法 class Solution { public ListNode deleteDuplicates(ListNode head) { if(head==null)return null; ListNode curr=head; while(curr!=null &amp;&amp; curr.next!=null){ if(curr.val==curr.next.val) curr.next=curr.next.next; else curr=curr.next; } return head; } } 206. Reverse Linked List 解法一：递归法 class Solution { public ListNode reverseList(ListNode head) { if(head==null || head.next==null)return head; //递归结束条件 ListNode n_head=reverseList(head.next); //next为翻转后部分的头部,即原先的尾部 head.next.next=head; //翻转后部分的尾部，本来为null，先将它指向head head.next=null; //将原先的head.next设为null，防止出现循环链表 return n_head; //返回新的头部 } } 解法二：迭代法 class Solution { public ListNode reverseList(ListNode head) { ListNode prev=null; //prev初始为null,所以不必担心出现循环链表 ListNode curr=head; while(curr!=null){ ListNode next=curr.next; //保存curr.next curr.next=prev; //翻转 prev=curr; curr=next; //prev,curr向前移动一格 } return prev; } } 160. Intersection of Two Linked Lists 解法一：HashSet public class Solution { public ListNode getIntersectionNode(ListNode headA, ListNode headB) { Set&lt;ListNode&gt; set=new HashSet&lt;ListNode&gt;(); ListNode curr_a=headA; ListNode curr_b=headB; while(curr_a!=null){ //遍历链表A，将所有节点加入HashSet set.add(curr_a); curr_a=curr_a.next; } while(curr_b!=null){ //遍历链表B，看是否有节点在HashSet存在 if(set.contains(curr_b))return curr_b; curr_b=curr_b.next; } return null; } } 解法二：双指针 参考官方题解3：十分巧妙 public class Solution { public ListNode getIntersectionNode(ListNode headA, ListNode headB) { ListNode curr_a=headA; ListNode curr_b=headB; while(curr_a!=null &amp;&amp; curr_b!=null){ if(curr_a==curr_b)return curr_a; //交点 curr_a=curr_a.next; curr_b=curr_b.next; if(curr_a==null &amp;&amp; curr_b==null)return null;//到达终点，证明不存在 if(curr_a==null)curr_a=headB; //a接入b链 if(curr_b==null)curr_b=headA; //b接入a链 } return null; } } 234. Palindrome Linked List 解法一：栈 简明，和数组的做法没有区别，但是空间复杂度O(n) class Solution { public boolean isPalindrome(ListNode head) { Stack&lt;Integer&gt; stack=new Stack&lt;Integer&gt;(); //空间复杂度O(n) ListNode curr=head; while(curr!=null){ //第一次遍历，将所有值压入栈内 stack.push(curr.val); curr=curr.next; } while(head!=null){ //第二次遍历，逐一比对 if(stack.pop()!=head.val)return false; head=head.next; } return true; } }","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://gabbyyam.github.io/overyam/categories/Algorithm/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://gabbyyam.github.io/overyam/tags/leetcode/"}]},{"title":"DP-Easy","slug":"DP-Easy","date":"un33fin33","updated":"un44fin44","comments":true,"path":"2020/02/26/DP-Easy/","link":"","permalink":"https://gabbyyam.github.io/overyam/2020/02/26/DP-Easy/","excerpt":"Abstract： 更新部分Easy难度 DP相关题解","text":"Abstract： 更新部分Easy难度 DP相关题解 70. Climbing Stairs 解法一：DP 基本情况：一层楼梯有一种方法，两层楼梯两种方法，因此dp[0]=1,dp[1]=2 转移方程：对于大于等于2的层数，dp[n-1]=dp[n-2]+dp[n-3]，即为一般解 class Solution { public int climbStairs(int n) { if(n&lt;=1){return 1;} if(n==2){return 2;} int[] dp=new int[n]; dp[0]=1; dp[1]=2; for(int i=2;i&lt;n;i++){dp[i]=dp[i-1]+dp[i-2];} return dp[n-1]; } } 121. Best Time to Buy and Sell Stock 解法一：线性扫描 线性扫描，考虑到不能只求最大值和最小值，但是记录Index也是无用功 不妨只更新最小值，那么计算利润的值就必定是在最小值之后，那就只需无脑更新最大利润就行了 时间复杂度：$ O(N) $ class Solution { public int maxProfit(int[] prices) { int maxProfit=0,minPrice=Integer.MAX_VALUE; //只需要最大利润和最小值 for(int i=0;i&lt;prices.length;i++){ minPrice=Math.min(prices[i],minPrice); maxProfit=Math.max(maxProfit,prices[i]-minPrice); } return maxProfit; } } 解法二：DP //下次写(?) 198. House Robber 解法一：DP 特殊情况：可抢劫的房子不到三家，即0,1,2 基本情况：第一家的价值是其自身，第二家的价值是第一家和第二家价值的最大值，即 dp[0]=nums[0]; dp[1]=Math.max(nums[0],nums[1]); 转移方程：由基本情况可以推出，第n家的价值 dp[n]=Math.max( dp[n-2]+nums[n], dp[n-1] ); 结果：不是最后一家就是倒数第二家，取最大值即可 class Solution { public int rob(int[] nums) { //三种特殊情况,不考虑会越界 if(nums.length==0 || nums==null){return 0;} if(nums.length==1){return nums[0];} if(nums.length==2){return Math.max(nums[0],nums[1]);} int[] dp=new int[nums.length]; //两种基本情况 dp[0]=nums[0]; dp[1]=Math.max(dp[0],nums[1]); //状态转移 for(int i=2;i&lt;nums.length;i++){dp[i]=Math.max((dp[i-2]+nums[i]),dp[i-1]);} //最后两家的价值取最大值即可 return Math.max(dp[nums.length-1],dp[nums.length-2]); } } 303. Range Sum Query - Immutable 解法一：缓存 由于会大量调用，所以如果每次都遍历一次来计算会很慢，所以这里需要加入缓存 nums传入初始化时，就把到n为止的sum计算出来，结果返回两个边界的差值就行了 class NumArray { private int[] sum; public NumArray(int[] nums) { sum=new int[nums.length+1]; for(int i=0;i&lt;nums.length;i++){ sum[i+1]=nums[i]+sum[i]; } } public int sumRange(int i, int j) { return sum[j+1]-sum[i]; //注意这里是j+1 和 i ，因为如果是i+1的话，会把nums[i]也算进去，那得到的和就没有nums[i]了 } } 62. Unique Paths（Medium？Easy？） 解法一：DP 基本情况：每个格子对应的解数应为 转移方程：每个格子对应的解数应为 左方格子的解数+上方格子的解数，因此 dp[i][j]=dp[i-1][j]+dp[i][j-1]; 边界问题：由于边界上的格子上方或左方没有格子，直接计算会导致越界，因此长宽各扩展一格val=0的格子来作辅助 class Solution { public int uniquePaths(int m, int n) { int[][] dp = new int[m+1][n+1]; //长宽都+1，自动初始化为0作为辅助 for(int i=1;i&lt;=m;i++){ for(int j=1;j&lt;=n;j++){ dp[i][j]=(i==1&amp;&amp;j==1)?1:dp[i-1][j]+dp[i][j-1]; //dp[1][1]为1，其他则由其按转移方程推得 } } return dp[m][n];//右下角即为结果 } }","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://gabbyyam.github.io/overyam/categories/Algorithm/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://gabbyyam.github.io/overyam/tags/leetcode/"}]},{"title":"Array-Easy","slug":"Array-Easy","date":"un33fin33","updated":"un33fin33","comments":true,"path":"2020/02/26/Array-Easy/","link":"","permalink":"https://gabbyyam.github.io/overyam/2020/02/26/Array-Easy/","excerpt":"Abstract： 更新部分Easy难度 Array相关题解","text":"Abstract： 更新部分Easy难度 Array相关题解 1. Two Sum 解法一：暴力法 冒泡排序，送死写法，就不多说了 解法二：哈希表 为了最快得到target的index，HashMap是个好方法，$Time:O(n^2) Space:O(n^2)$ //原始版本为两遍Hash表，但是发现可以合写在一起 class Solution { public int[] twoSum(int[] nums, int target) { Map&lt;Integer,Integer&gt; map=new HashMap&lt;Integer,Integer&gt;(); for (int i=0;i&lt;nums.length;i++){ if (map.containsKey(nums[i])&amp;&amp;map.get(nums[i])!=i) return new int[] {i,map.get(nums[i])//此值的index及其对应满足条件的index }; map.put(target-nums[i],i);//不满足的话存入Map准备下一次搜索 } throw new IllegalArgumentException(&quot;no such answer!&quot;); } } 83. Remove Duplicates from Sorted List 解法一：双指针 class Solution { public int removeDuplicates(int[] nums) { if(nums.length&lt;=1)return 1;//1的情况 int len=1;//因为第一个必定是nums[0],所以从1开始 for(int i=0;i&lt;nums.length-1;i++){ if (nums[i]!=nums[i+1]){ nums[len]=nums[i+1];//每找到一个新的值，放到前面对应的位置 len++;//更新最新前面的指针 } } return len; } } 27. Remove Element 解法一：我的双指针 第一想到的虽然是覆盖，但还是鬼使神差得选择了交换 从后往前找一个非val的值 从前往后找一个等于val的值 二者交换（交换的方法很蠢，浪费时间和空间，不如直接覆盖） 缺点：需要考虑很多边界情况，而且还麻烦 class Solution { public int removeElement(int[] nums, int val) { //考虑特殊情况，0，1,2,空 if(nums.length==1){ if(nums[0]==val)return 0; else return 1; } int lo=0,hi=nums.length-1,count=0; while(lo&lt;hi){ //从后往前找 while(nums[hi] == val){ hi--; count++; //目标值++ if(hi&lt;0){return nums.length-count;} //注意如果已经找到最前面了就不要再找了，直接返回目前的结果 } //从后往前找 while(lo&lt;hi &amp;&amp; nums[lo]!=val){ //注意必须满足lo&lt;hi lo++; } //交换 int temp=nums[lo]; nums[lo]=nums[hi]; nums[hi]=temp; } return nums.length-count; } } 解法二：官方双指针[改] 直接覆盖的方法，简单优雅 从前往后找一个等于val的值 用后排的一个值直接覆盖 class Solution { public int removeElement(int[] nums, int val) { int lo=0,hi=nums.length; while(lo&lt;hi){ if(nums[lo]==val){nums[lo]=nums[--hi];}//如果是val就用后面的值覆盖 //就算后面的值也是val也没关系，因为下一轮覆盖还是会把它覆盖掉 else lo++; } return hi;//最后返回最后一次覆盖的位置，即为删除后的长度 } } 35. Search Insert Position 解法一：二分查找（虽然思想简单，但是边界问题搞人） class Solution { public int searchInsert(int[] nums, int target) { int lo=0,hi=nums.length-1,mi=0; if(target&lt;=nums[lo]){return 0;} //小于最小值按0处理 if(target&gt;nums[hi]){return hi+1;} //大于最大值按length处理 while(lo&lt;=hi){ //注意必须是 &lt;= 否则会错过一次循环判定 mi=(lo+hi)/2; if(target==nums[mi]){return mi;} //如果刚好相等，那返回该处索引 else if(target&lt;nums[mi]){hi=mi-1;} //二分查找模板 else if(target&gt;nums[mi]){lo=mi+1;} } //如果没有刚好相等的，要进行最后一轮判定 if(nums[mi]&lt;target)return mi+1; //小于target，要+1 else return mi; } } 53. Maximum Subarray 解法一：经典分治法 最大和序列可能的情况：左边界序列，右边界序列，中间序列 因此先计算左右边界序列的最大值，再递归地比较中间序列，就能找到最大的子序列和 时间复杂度： class Solution { public int maxSubArray(int[] nums) { return maxSub(nums,0,nums.length-1); } public int maxSub(int[] nums,int lo,int hi){ if(hi&lt;lo){return Integer.MIN_VALUE;//注意越界后要返回一个最小的值，否则无法通过负数的情况 }// lo必须小于等于hi int maxLeft=nums[lo],maxRight=nums[hi],sumLeft=0,sumRight=0;//一些待用变量 for(int i=lo;i&lt;=hi;i++){//找到左边界的最大和序列 sumLeft+=nums[i]; maxLeft=Math.max(sumLeft,maxLeft); //if(sumLeft&gt;maxLeft){ // maxLeft=sumLeft; // indexLeft=i; //} } for(int i=hi;i&gt;=lo;i--){//找到右边界的最大和序列 sumRight+=nums[i]; maxRight=Math.max(sumRight,maxRight); //if(sumRight&gt;maxRight){ // maxRight=sumRight; // indexRight=i; //} } int maxSide=Math.max(maxLeft,maxRight); return Math.max(maxSide,maxSub(nums,lo+1,hi-1)); //左右边界最大和序列 与 中间和序列 比较 } } 解法二：线性扫描 计算当前的和 比较最大值 如果当前和 小于等于0，那么和直接归零，因为前面的结果不能让后面更大了，因此也没有继续加和的必要了 时间复杂度：$O(N)$ class Solution { public int maxSubArray(int[] nums) { int sum=0,max=nums[0]; for(int i=0;i&lt;nums.length;i++){ sum+=nums[i]; //计算当前和 max=Math.max(sum,max); //注意要先比较max，不然会导致sum=0和全负数的情况比较，结果错误 if(sum&lt;=0){sum=0;} //小于0就可以滚蛋了，因为肯定没有后面的和大 } return max; } }","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://gabbyyam.github.io/overyam/categories/Algorithm/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://gabbyyam.github.io/overyam/tags/leetcode/"}]}]}