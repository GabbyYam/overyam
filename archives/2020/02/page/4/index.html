<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



<title>
  
    Archive: 2020/2
  
</title>

<meta name="description" content="On Your Mark">
<meta property="og:type" content="website">
<meta property="og:title" content="OverYam">
<meta property="og:url" content="http://yoursite.com/archives/2020/02/page/4/index.html">
<meta property="og:site_name" content="OverYam">
<meta property="og:description" content="On Your Mark">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="GabbyYam">
<meta name="twitter:card" content="summary">


  <link rel="alternative" href="/atom.xml" title="OverYam" type="application/atom+xml">



  <link rel="icon" href="/favicon.png">



<link rel="stylesheet" href="https://github.com/GabbyYam/overyam/perfect-scrollbar/css/perfect-scrollbar.min.css">


<link rel="stylesheet" href="https://github.com/GabbyYam/overyam/styles/main.css">







<meta name="generator" content="Hexo 4.2.0"></head>
<body
  
    class="monochrome"
  
  >
  <div class="mobile-header">
  <button class="sidebar-toggle" type="button">
    <span class="icon-bar"></span>
    <span class="icon-bar"></span>
    <span class="icon-bar"></span>
  </button>
  <a class="title" href="https://github.com/GabbyYam/overyam/" target="_blank" rel="noopener">OverYam</a>
</div>

  <div class="main-container">
    <div class="sidebar">
  <div class="header">
    <h1 class="title"><a href="https://github.com/GabbyYam/overyam/" target="_blank" rel="noopener">OverYam</a></h1>
    
    <div class="info">
      <div class="content">
        
          <div class="description">On Your Mark</div>
        
        
          <div class="author">GabbyYam</div>
        
      </div>
      
        <div class="avatar">
          
            <a href="/about"><img src="https://cn.gravatar.com/avatar/35fef74d731255cd569c2c2b0b9e87e4?s=200"></a>
          
        </div>
      
    </div>
  </div>
  <div class="body">
    
      
        <ul class="nav">
          
            
              <li class="category-list-container">
                <a href="javascript:;">Category</a>
                
              </li>
            
          
            
              <li class="tag-list-container">
                <a href="javascript:;">Tag</a>
                
              </li>
            
          
            
              <li class="archive-list-container">
                <a href="javascript:;">Archive</a>
                <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="https://github.com/GabbyYam/overyam/archives/2020/" target="_blank" rel="noopener">2020</a><span class="archive-list-count">44</span></li></ul>
              </li>
            
          
        </ul>
      
        <ul class="nav">
          
            
              <li>
                <a href="https://github.com/GabbyYam/overyam/" target="_blank" rel="noopener" title="Homepage" external="false">Homepage</a>
              </li>
            
          
            
              <li>
                <a href="https://github.com/GabbyYam/overyam/archives" target="_blank" rel="noopener" title="By Year" external="false">By Year</a>
              </li>
            
          
        </ul>
      
        <ul class="nav">
          
            
              <li>
                <a href="https://github.com/denjones/hexo-theme-chan" title="Chan" target="_blank" rel="noopener">Chan</a>
              </li>
            
          
            
              <li>
                <a href="https://github.com/denjones" title="Github" target="_blank" rel="noopener">Github</a>
              </li>
            
          
            
              <li>
                <a href="https://github.com/GabbyYam/overyam/atom.xml" target="_blank" rel="noopener" title="RSS" external="false">RSS</a>
              </li>
            
          
        </ul>
      
    
  </div>
</div>

    <div class="main-content">
      
        <div style="max-width: 1000px">
      
          

  
  
    
      
      
      <section class="archives-wrap">
        <div class="archive-year-wrap">
          <h1><a href="https://github.com/GabbyYam/overyam/archives/2020" target="_blank" rel="noopener" class="archive-year">2020</a></h1>
        </div>
        <div class="post-list">
    
  

    <div class="post-list-item article">
      <h3 class="article-header">
        <a href="https://github.com/GabbyYam/overyam/2020/02/25/Concurrent%20programming/java.util.concuurent/" target="_blank" rel="noopener" >
  Concurrent programming/java.util.concuurent
</a>

      </h3>
      

      <div class="article-info">
        <a href="https://github.com/GabbyYam/overyam/2020/02/25/Concurrent%20programming/java.util.concuurent/" target="_blank" rel="noopener"><span class="article-date">
  2020-02-25
</span>
</a>
        

        

      </div>
      <div class="article-entry">
        
          <h1 id="JUC"><a href="#JUC" class="headerlink" title="JUC"></a>JUC</h1><p><strong>重要概念：</strong></p>
<ul>
<li>进程/线程</li>
<li>并发/并行</li>
</ul>
<p><strong>三个核心包：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java.util.concurrent</span><br><span class="line">java.util.concurrent.atomic</span><br><span class="line">java.util.concurrent.locks</span><br></pre></td></tr></table></figure>

<p>基本套路：在高内聚低耦合的前提下：线程，操作，资源类</p>
<ul>
<li><p>new资源类</p>
</li>
<li><p>newThread01/02  匿名内部类和lambda表达式，调用资源类实例方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(&#123;实现方法&#125;,name:<span class="string">"..."</span>).start();</span><br></pre></td></tr></table></figure>
</li>
<li><p>arrayList-&gt;线程不安全，初值为10，扩容一次多一半</p>
</li>
<li><p>CopyOnWriteArrayList:线程安全</p>
</li>
<li><p>判断/干活/通知</p>
</li>
<li><p>防止虚假唤醒-&gt;使用while来进行循环判断</p>
</li>
</ul>

        
      </div>
    </div>

  

  
  
    
  

    <div class="post-list-item article">
      <h3 class="article-header">
        <a href="https://github.com/GabbyYam/overyam/2020/02/25/Concurrent%20programming/AQS/" target="_blank" rel="noopener" >
  Concurrent programming/AQS
</a>

      </h3>
      

      <div class="article-info">
        <a href="https://github.com/GabbyYam/overyam/2020/02/25/Concurrent%20programming/AQS/" target="_blank" rel="noopener"><span class="article-date">
  2020-02-25
</span>
</a>
        

        

      </div>
      <div class="article-entry">
        
          <p>[TOC]</p>
<h1 id="原理概览"><a href="#原理概览" class="headerlink" title="原理概览"></a>原理概览</h1><ul>
<li><p><code>AQS</code>，全称<code>AbstractQueueSynchronizer</code>，是用于维护线程等待队列的数据结构</p>
</li>
<li><p><code>AQS</code>中的队列是<code>FIFO</code>的<strong>双向队列</strong></p>
</li>
<li><p><code>AQS</code>中的节点均为<code>volatile</code>修饰</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;	<span class="comment">//等待状态</span></span><br><span class="line"><span class="keyword">volatile</span> Node prev;         <span class="comment">//前驱节点</span></span><br><span class="line"><span class="keyword">volatile</span> Node next;			<span class="comment">//后继节点</span></span><br><span class="line"><span class="keyword">volatile</span> Thread thread;		<span class="comment">//代表的线程</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state; <span class="comment">//同步状态，即锁的个数</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>实现==自定义同步器==需要实现的以下方法：</p>
<ul>
<li>纯独占模式：<code>ReentrantLock</code></li>
<li>双模式：<code>ReentrantWriteReadLock</code></li>
<li>其中<code>acquire</code>和<code>release</code>继承于AQS，不需要重写，用于管理位于双向队列中的各节点</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断线程是否取得锁</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span>    </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//独占模式</span></span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span>	<span class="comment">//用于AQS中的acquire方法，尝试获取资源，并设置状态</span></span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> arg)</span>	<span class="comment">//用于AQS中的release方法，尝试释放资源,并设置状态</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">//共享模式</span></span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span>	</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br></pre></td></tr></table></figure>

</li>
</ul>

        
      </div>
    </div>

  

  
  
    
  

    <div class="post-list-item article">
      <h3 class="article-header">
        <a href="https://github.com/GabbyYam/overyam/2020/02/25/Compiler/Stanford-Note/lexical%20analysis/" target="_blank" rel="noopener" >
  Compiler/Stanford-Note/lexical analysis
</a>

      </h3>
      

      <div class="article-info">
        <a href="https://github.com/GabbyYam/overyam/2020/02/25/Compiler/Stanford-Note/lexical%20analysis/" target="_blank" rel="noopener"><span class="article-date">
  2020-02-25
</span>
</a>
        

        

      </div>
      <div class="article-entry">
        
          <h1 id="Lexical-Analysis（词法分析）"><a href="#Lexical-Analysis（词法分析）" class="headerlink" title="Lexical Analysis（词法分析）"></a>Lexical Analysis（词法分析）</h1><p><strong>主要任务：</strong></p>
<ul>
<li><p><strong>将一段program分割成不同的成分</strong></p>
</li>
<li><p><strong>并标记对应的token（即词性：逻辑运算符、运算符、变量名、关键字、etc）</strong></p>
</li>
</ul>
<p>token的形式：&lt;class,string&gt;,for example:</p>
<ul>
<li>&lt;Id,”foo”&gt;</li>
<li>&lt;op,”=”&gt;</li>
<li>&lt;Int,”42”&gt;</li>
<li>…</li>
</ul>
<p>标点符号没有token，而是用自己本身表示，比如 </p>
<ul>
<li>“:” </li>
<li>“(“</li>
<li>“;”</li>
</ul>
<p>正则语言-regular language：</p>
<p>交集（x）、并集（+）、反复（*）</p>

        
      </div>
    </div>

  

  
  
    
  

    <div class="post-list-item article">
      <h3 class="article-header">
        <a href="https://github.com/GabbyYam/overyam/2020/02/25/Compiler/Mooc-Note/Note-01-%E6%A6%82%E8%BF%B0/" target="_blank" rel="noopener" >
  Compiler/Mooc-Note/Note-01-概述
</a>

      </h3>
      

      <div class="article-info">
        <a href="https://github.com/GabbyYam/overyam/2020/02/25/Compiler/Mooc-Note/Note-01-%E6%A6%82%E8%BF%B0/" target="_blank" rel="noopener"><span class="article-date">
  2020-02-25
</span>
</a>
        

        

      </div>
      <div class="article-entry">
        
          <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>高级语言语言 （编译）=&gt; 汇编语言 （汇编）=&gt; 机器语言</p>
<p><strong>结构：类似于语言翻译</strong></p>
<ul>
<li>分析部分：分析源语言</li>
<li>优化器</li>
<li>综合部分：组织目标语言</li>
</ul>
<p><strong>词法分析：</strong>识别各个单词，判断该词的category</p>
<ul>
<li>词法单元以token的形式呈现 &lt;Kind,Type&gt;</li>
<li>关键词(key word)</li>
<li>常量 </li>
<li>运算符 =-+*</li>
<li>界限符 :({[])</li>
<li>标识符：变量名、方法名、类名、etc</li>
</ul>
<p><strong>语句通过分析树来进行分析</strong></p>
<p><strong>语义分析：</strong></p>
<ul>
<li>收集标识符的属性信息<ul>
<li>Kind</li>
<li>Type</li>
<li>储存位置、位置</li>
<li>值</li>
<li>作用域</li>
<li>参数和返回信息</li>
</ul>
</li>
<li>语义检查</li>
</ul>
<p><strong>中间代码生成：即代码翻译的中间形式</strong></p>
<ul>
<li>三地址指令（操作符，操作数，被操作数，赋值数）</li>
</ul>

        
      </div>
    </div>

  

  
  
    
  

    <div class="post-list-item article">
      <h3 class="article-header">
        <a href="https://github.com/GabbyYam/overyam/2020/02/25/Algorithm/Leetcode/Tree-Medium/" target="_blank" rel="noopener" >
  Algorithm/Leetcode/Tree-Medium
</a>

      </h3>
      

      <div class="article-info">
        <a href="https://github.com/GabbyYam/overyam/2020/02/25/Algorithm/Leetcode/Tree-Medium/" target="_blank" rel="noopener"><span class="article-date">
  2020-02-25
</span>
</a>
        

        

      </div>
      <div class="article-entry">
        
          <p>[TOC]</p>
<h1 id="94-Binary-Tree-Inorder-Traversal"><a href="#94-Binary-Tree-Inorder-Traversal" class="headerlink" title="94. Binary Tree Inorder Traversal"></a><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/" target="_blank" rel="noopener">94. Binary Tree Inorder Traversal</a></h1><p><img src="diagram/image-20200211153052914.png" alt="image-20200211153052914"></p>
<h2 id="解法一：递归法"><a href="#解法一：递归法" class="headerlink" title="解法一：递归法"></a>解法一：递归法</h2><p>没什么好说的，不会砍手</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; inorder=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        inorder=inorderTraversal(root.left);</span><br><span class="line">        inorder.add(root.val);</span><br><span class="line">        inorder=inorderTraversal(root.right);&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> inorder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解法二：迭代法"><a href="#解法二：迭代法" class="headerlink" title="解法二：迭代法"></a>解法二：迭代法</h2><p>比递归法难理解一些，重点是理解好如何回溯</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; inorder=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    Stack&lt;TreeNode&gt; stack=<span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        TreeNode curr=root; <span class="comment">//辅助接点curr，指向当前访问的TreeNode</span></span><br><span class="line">        <span class="keyword">while</span>(curr!=<span class="keyword">null</span> || !stack.isEmpty())&#123; <span class="comment">//当前访问的节点不为空或栈不为空，说明还没遍历完</span></span><br><span class="line">            <span class="keyword">while</span>(curr!=<span class="keyword">null</span>)&#123; <span class="comment">//不断压入左节点</span></span><br><span class="line">                stack.push(curr);</span><br><span class="line">                curr=curr.left;</span><br><span class="line">            &#125;</span><br><span class="line">            curr=stack.pop(); <span class="comment">//**回溯**</span></span><br><span class="line">            inorder.add(curr.val); <span class="comment">//将当前访问的节点加入</span></span><br><span class="line">            curr=curr.right; <span class="comment">//如果有右节点则访问右节点，如果没有将在下一轮回溯或者结束</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> inorder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解法三：-莫比斯遍历"><a href="#解法三：-莫比斯遍历" class="headerlink" title="解法三： 莫比斯遍历"></a>解法三： 莫比斯遍历</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="96-Unique-Binary-Search-Trees"><a href="#96-Unique-Binary-Search-Trees" class="headerlink" title="96. Unique Binary Search Trees"></a><a href="https://leetcode-cn.com/problems/unique-binary-search-trees/" target="_blank" rel="noopener">96. Unique Binary Search Trees</a></h1><p><img src="diagram/image-20200211165519568.png" alt="image-20200211165519568"></p>
<h2 id="解法一：递归法-1"><a href="#解法一：递归法-1" class="headerlink" title="解法一：递归法"></a>解法一：递归法</h2><ul>
<li><p><strong>思路：</strong>分别以1-n的任意整数为根，那么左右子树有哪些值是可以确定的，因此可以递归地来做</p>
</li>
<li><p><strong>要点：</strong>{4,5,6,7,8}在此处可以等价于{1,2,3,4,5}，因此可以很方便的进行递归</p>
</li>
<li><p><strong>缺点：</strong>没有保存递归结果，增加了许多重复的操作，下一个解法考虑对结果进行缓存</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">1</span>)<span class="keyword">return</span> <span class="number">1</span>; <span class="comment">//特殊情况，以及递归的基准</span></span><br><span class="line">        <span class="keyword">int</span> uniqueNum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;uniqueNum+=numTrees(i-<span class="number">1</span>)*numTrees(n-i);&#125; <span class="comment">//递归左右区间的乘积</span></span><br><span class="line">        <span class="keyword">return</span> uniqueNum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解法二：记忆化递归"><a href="#解法二：记忆化递归" class="headerlink" title="解法二：记忆化递归"></a>解法二：记忆化递归</h2><p>直接递归的缺点是重复递归很多地方，所以需要剪枝</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp=<span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> dynamicNumTrees(n,dp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dynamicNumTrees</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span>[] dp)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">1</span>)&#123;<span class="keyword">return</span> <span class="number">1</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span>(dp[n]!=<span class="number">0</span>)&#123;<span class="keyword">return</span> dp[n];&#125; <span class="comment">//加入DP缓存</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;dp[n]+=dynamicNumTrees(i-<span class="number">1</span>,dp)*dynamicNumTrees(n-i,dp);&#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="95-Unique-Binary-Search-Trees-II"><a href="#95-Unique-Binary-Search-Trees-II" class="headerlink" title="95. Unique Binary Search Trees II"></a><a href="https://leetcode-cn.com/problems/unique-binary-search-trees-ii/" target="_blank" rel="noopener">95. Unique Binary Search Trees II</a></h1><p><img src="diagram/image-20200211195518011.png" alt="image-20200211195518011"></p>
<h2 id="解法一：递归法-2"><a href="#解法一：递归法-2" class="headerlink" title="解法一：递归法"></a>解法一：递归法</h2><p>和上题类似的递归思路，不过注意==root的创建时机==</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)<span class="keyword">return</span> <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;(); <span class="comment">//特殊情况</span></span><br><span class="line">        <span class="keyword">return</span> generate(<span class="number">1</span>,n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title">generate</span><span class="params">(<span class="keyword">int</span> lo,<span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">        List&lt;TreeNode&gt; BSTs=<span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();     <span class="comment">//注意ArrayList不能加入null</span></span><br><span class="line">        <span class="keyword">if</span>(lo&gt;hi)&#123;BSTs.add(<span class="keyword">null</span>);<span class="keyword">return</span> BSTs;&#125;              <span class="comment">//加入null</span></span><br><span class="line">        <span class="keyword">if</span>(lo==hi)&#123;BSTs.add(<span class="keyword">new</span> TreeNode(lo));<span class="keyword">return</span> BSTs;&#125; <span class="comment">//递归基准</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=lo;i&lt;=hi;i++)&#123;</span><br><span class="line">            List&lt;TreeNode&gt; leftList=generate(lo,i-<span class="number">1</span>);</span><br><span class="line">            List&lt;TreeNode&gt; rightList=generate(i+<span class="number">1</span>,hi); <span class="comment">//分别取得左右子树的递归结果</span></span><br><span class="line">            <span class="keyword">for</span>(TreeNode leftRoot:leftList)&#123;</span><br><span class="line">                <span class="keyword">for</span>(TreeNode rightRoot:rightList)&#123;    </span><br><span class="line">                    TreeNode root=<span class="keyword">new</span> TreeNode(i);<span class="comment">//root应该在循环体内new，否则会和上一轮的混淆</span></span><br><span class="line">                    root.left=leftRoot;</span><br><span class="line">                    root.right=rightRoot;</span><br><span class="line">                    BSTs.add(root);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> BSTs;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解法二：记忆化递归-1"><a href="#解法二：记忆化递归-1" class="headerlink" title="解法二：记忆化递归"></a>解法二：记忆化递归</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal"><a href="#105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal" class="headerlink" title="105. Construct Binary Tree from Preorder and Inorder Traversal"></a><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/" target="_blank" rel="noopener">105. Construct Binary Tree from Preorder and Inorder Traversal</a></h1><p><img src="diagram/image-20200211234824881.png" alt=""></p>
<h2 id="解法一：递归法-3"><a href="#解法一：递归法-3" class="headerlink" title="解法一：递归法"></a>解法一：递归法</h2><p>这题的重点是如何分别在inorder和preorder中划分左右子树</p>
<ul>
<li><strong>preorder的头部是root</strong></li>
<li><strong>inorder如何划分：</strong>在inorder中找到root，那么在此之前的为left，之后的为right</li>
<li><strong>preorder如何划分：</strong>inorder中，left-root即为left的长度leftSize，由此推出以下关系</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//左子树</span></span><br><span class="line">next_p_lo=p_lo+<span class="number">1</span>;</span><br><span class="line">next_p_hi=p_lo+leftSize;</span><br><span class="line">next_i_lo=i_lo;</span><br><span class="line">next_i_hi=i_lo+leftSize+<span class="number">1</span>;</span><br><span class="line"><span class="comment">//右子树</span></span><br><span class="line">next_p_lo=p_lo+leftSize+<span class="number">1</span>;</span><br><span class="line">next_p_hi=p_hi;</span><br><span class="line">next_i_lo=i_lo+leftSize+<span class="number">1</span>;</span><br><span class="line">next_i_hi=p_hi;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len=preorder.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> build(preorder,inorder,<span class="number">0</span>,len,<span class="number">0</span>,len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">build</span><span class="params">(<span class="keyword">int</span>[] preorder,<span class="keyword">int</span>[] inorder,<span class="keyword">int</span> p_lo,<span class="keyword">int</span> p_hi,<span class="keyword">int</span> i_lo,<span class="keyword">int</span> i_hi)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p_lo&gt;p_hi || i_lo&gt;i_hi)&#123;<span class="keyword">return</span> <span class="keyword">null</span>;&#125; <span class="comment">//越界判定 &amp; 递归结束</span></span><br><span class="line">        <span class="keyword">int</span> leftSize=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=i_lo;i&lt;=i_hi;i++)&#123; <span class="comment">//在inorder中找到root并算出leftSize</span></span><br><span class="line">            <span class="keyword">if</span>(inorder[i]==preorder[p_lo])&#123;leftSize=i-i_lo;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode root=<span class="keyword">new</span> TreeNode(preorder[p_lo]); <span class="comment">//依据已有关系，构造根节点和左右子树</span></span><br><span class="line">        root.left=build(preorder,inorder,p_lo+<span class="number">1</span>,p_lo+leftSize,i_lo,i_lo+leftSize-<span class="number">1</span>);</span><br><span class="line">        root.right=build(preorder,inorder,p_lo+leftSize+<span class="number">1</span>,p_hi,i_lo+leftSize+<span class="number">1</span>,i_hi);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="98-Validate-Binary-Search-Tree"><a href="#98-Validate-Binary-Search-Tree" class="headerlink" title="98. Validate Binary Search Tree"></a><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/" target="_blank" rel="noopener">98. Validate Binary Search Tree</a></h1><p><img src="diagram/image-20200212032652708.png" alt="image-20200212032652708"></p>
<h2 id="解法一：中序遍历"><a href="#解法一：中序遍历" class="headerlink" title="解法一：中序遍历"></a>解法一：中序遍历</h2><p>判断BST，<strong>容易简单认为是</strong>只要左子树比根节点小，右子树比根节点大，以此递归就行</p>
<p>但是，上述策略忽略了一点：==左子树&lt;右子树==</p>
<p>因此必须保证这一点，考虑到==BST的特性：中序遍历==，得出以下解法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; inorder=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        inorder(root);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;inorder.size();i++)&#123; <span class="comment">//检查中序遍历结果是否顺序即可</span></span><br><span class="line">            <span class="keyword">if</span>(inorder.get(i)&lt;=inorder.get(i-<span class="number">1</span>))<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            inorder(root.left);</span><br><span class="line">            inorder.add(root.val);</span><br><span class="line">            inorder(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解法二：迭代法-1"><a href="#解法二：迭代法-1" class="headerlink" title="解法二：迭代法"></a>解法二：迭代法</h2><p>边迭代边检查，还可以写成递归法，不过同理就不写了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack=<span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        TreeNode curr=root;</span><br><span class="line">        Integer val=<span class="keyword">null</span>; <span class="comment">//注意这里要用Integer而不是int，因为可以用null,不然无论设成什么都能被卡掉</span></span><br><span class="line">        <span class="keyword">while</span>(curr!=<span class="keyword">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(curr!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(curr);</span><br><span class="line">                curr=curr.left;</span><br><span class="line">            &#125;</span><br><span class="line">            curr=stack.pop();</span><br><span class="line">            <span class="keyword">if</span>(val!=<span class="keyword">null</span> &amp;&amp; curr.val&lt;=val)&#123;<span class="keyword">return</span> <span class="keyword">false</span>;&#125; <span class="comment">//错误判定</span></span><br><span class="line">            val=curr.val;</span><br><span class="line">            curr=curr.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


        
      </div>
    </div>

  

  
  
    
  

    <div class="post-list-item article">
      <h3 class="article-header">
        <a href="https://github.com/GabbyYam/overyam/2020/02/25/Algorithm/Leetcode/Tree-Easy/" target="_blank" rel="noopener" >
  Algorithm/Leetcode/Tree-Easy
</a>

      </h3>
      

      <div class="article-info">
        <a href="https://github.com/GabbyYam/overyam/2020/02/25/Algorithm/Leetcode/Tree-Easy/" target="_blank" rel="noopener"><span class="article-date">
  2020-02-25
</span>
</a>
        

        

      </div>
      <div class="article-entry">
        
          <p>[TOC]</p>
<h1 id="965-Univalued-Binary-Tree"><a href="#965-Univalued-Binary-Tree" class="headerlink" title="965. Univalued Binary Tree"></a><a href="https://leetcode-cn.com/problems/univalued-binary-tree/" target="_blank" rel="noopener">965. Univalued Binary Tree</a></h1><p><img src="diagram/image-20200209113924669.png" alt="image-20200209113924669"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h2 id="解法一：递归遍历"><a href="#解法一：递归遍历" class="headerlink" title="解法一：递归遍历"></a>解法一：递归遍历</h2><p>记录根节点的值，逐一向下遍历即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isUnivalTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;<span class="keyword">return</span> <span class="keyword">true</span>;&#125;<span class="comment">//注意这里要判空一次，否则root.val会报空指针</span></span><br><span class="line">        <span class="keyword">return</span> isUnival(root,root.val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isUnival</span><span class="params">(TreeNode root,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;<span class="keyword">return</span> <span class="keyword">true</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span>(root.val!=val)&#123;<span class="keyword">return</span> <span class="keyword">false</span>;&#125;</span><br><span class="line">        <span class="keyword">return</span> isUnival(root.left,val) &amp;&amp; isUnival(root.right,val); <span class="comment">//左右都true才是true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="112-Path-Sum"><a href="#112-Path-Sum" class="headerlink" title="112. Path Sum"></a><a href="https://leetcode-cn.com/problems/path-sum/" target="_blank" rel="noopener">112. Path Sum</a></h1><p><img src="diagram/image-20200209120253876.png" alt="image-20200209120253876"></p>
<h2 id="解法一：-DFS的简单变形"><a href="#解法一：-DFS的简单变形" class="headerlink" title="解法一： DFS的简单变形"></a>解法一： DFS的简单变形</h2><p>==DFS的核心三步==：</p>
<ol>
<li><strong>终止条件：root==null的时候返回什么？</strong></li>
<li><strong>处理过程：对root和root.val 如何处理？</strong></li>
<li><strong>递归条件：对左右子树如何处理？</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;<span class="keyword">return</span> <span class="keyword">false</span>;&#125;  <span class="comment">//为空时返回false,考虑空树和空子树的情况可以得到这个结论</span></span><br><span class="line">        sum-=root.val; <span class="comment">//减去当前val</span></span><br><span class="line">        <span class="keyword">if</span>(root.left==<span class="keyword">null</span> &amp;&amp; root.right==<span class="keyword">null</span>)&#123; <span class="comment">//为叶子节点时，要判断是不是满足条件</span></span><br><span class="line">            <span class="keyword">if</span>(sum==<span class="number">0</span>)&#123;<span class="keyword">return</span> <span class="keyword">true</span>;&#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hasPathSum(root.left,sum) || hasPathSum(root.right,sum); </span><br><span class="line">        <span class="comment">//左右子树一方满足即可</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="100-Same-Tree"><a href="#100-Same-Tree" class="headerlink" title="100. Same Tree"></a><a href="https://leetcode-cn.com/problems/same-tree/" target="_blank" rel="noopener">100. Same Tree</a></h1><p><img src="diagram/image-20200209174712330.png" alt="image-20200209174712330"></p>
<h2 id="解法一：递归遍历-1"><a href="#解法一：递归遍历-1" class="headerlink" title="解法一：递归遍历"></a>解法一：递归遍历</h2><ol>
<li><strong>判空</strong>，分两种情况，两者都为空和只有一者为空</li>
<li><strong>比值</strong>，对比值是否相等</li>
<li><strong>递归</strong>，递归左右子树的结果，取<strong>&amp;&amp;</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSameTree</span><span class="params">(TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="keyword">null</span> &amp;&amp; q==<span class="keyword">null</span>)&#123;<span class="keyword">return</span> <span class="keyword">true</span>;&#125; <span class="comment">//如果都为空，视为相等</span></span><br><span class="line">        <span class="keyword">if</span>(p==<span class="keyword">null</span> || q==<span class="keyword">null</span>)&#123;<span class="keyword">return</span> <span class="keyword">false</span>;&#125; <span class="comment">//如果一方为空，显然是不等</span></span><br><span class="line">        <span class="keyword">if</span>(p.val!=q.val)&#123;<span class="keyword">return</span> <span class="keyword">false</span>;&#125; <span class="comment">//比较val</span></span><br><span class="line">        <span class="keyword">return</span> isSameTree(p.left,q.left) &amp;&amp; isSameTree(p.right,q.right); <span class="comment">//递归左右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解法二：迭代法-没搞懂，以后再看"><a href="#解法二：迭代法-没搞懂，以后再看" class="headerlink" title="解法二：迭代法(==没搞懂，以后再看==)"></a>解法二：迭代法(==没搞懂，以后再看==)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(TreeNode p,TreeNode q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="keyword">null</span> &amp;&amp; q==<span class="keyword">null</span>)&#123;<span class="keyword">return</span> <span class="keyword">true</span>;&#125; <span class="comment">//如果都为空，视为相等</span></span><br><span class="line">        <span class="keyword">if</span>(p==<span class="keyword">null</span> || q==<span class="keyword">null</span>)&#123;<span class="keyword">return</span> <span class="keyword">false</span>;&#125; <span class="comment">//如果一方为空，显然是不等</span></span><br><span class="line">        <span class="keyword">if</span>(p.val!=q.val)&#123;<span class="keyword">return</span> <span class="keyword">false</span>;&#125; <span class="comment">//比较val</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSameTree</span><span class="params">(TreeNode p,TreeNode q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!check(p,q))&#123;<span class="keyword">return</span> <span class="keyword">false</span>;&#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="111-Minimum-Depth-of-Binary-Tree"><a href="#111-Minimum-Depth-of-Binary-Tree" class="headerlink" title="111. Minimum Depth of Binary Tree"></a><a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/" target="_blank" rel="noopener">111. Minimum Depth of Binary Tree</a></h1><p><img src="diagram/image-20200209184152426.png" alt="image-20200209184152426"></p>
<h2 id="解法一：递归遍历-2"><a href="#解法一：递归遍历-2" class="headerlink" title="解法一：递归遍历"></a>解法一：递归遍历</h2><ol>
<li><p><strong>判空</strong>：空时为0</p>
</li>
<li><p><strong>判断是否为叶子节点</strong>：如果是返回1</p>
</li>
<li><p><strong>判断是否有一边为null</strong>：如果只有一边为null的话，应该对其忽略不计，否则会把此处错误地当做最小深度</p>
</li>
<li><p><strong>递归</strong>：最小深度为左右子树的最小深度中更小的那者再+1</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;<span class="keyword">return</span> <span class="number">0</span>;&#125; <span class="comment">//判空</span></span><br><span class="line">        <span class="keyword">if</span>(root.left==<span class="keyword">null</span> &amp;&amp; root.right==<span class="keyword">null</span>)&#123;<span class="keyword">return</span> <span class="number">1</span>;&#125; <span class="comment">//对叶子节点的处理</span></span><br><span class="line">        <span class="keyword">if</span>(root.left==<span class="keyword">null</span> || root.right==<span class="keyword">null</span>)&#123; <span class="comment">//如果只有一方为空要忽略处理，这里用的是max的方法</span></span><br><span class="line">            <span class="keyword">return</span> Math.max(<span class="number">1</span>+minDepth(root.left),<span class="number">1</span>+minDepth(root.right));&#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+Math.min(minDepth(root.left),minDepth(root.right)); <span class="comment">//递归的最小值+1即为结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="257-Binary-Tree-Paths"><a href="#257-Binary-Tree-Paths" class="headerlink" title="257. Binary Tree Paths"></a><a href="https://leetcode-cn.com/problems/binary-tree-paths/" target="_blank" rel="noopener">257. Binary Tree Paths</a></h1><p><img src="diagram/image-20200209185315166.png" alt="image-20200209185315166"></p>
<h2 id="解法一：-标准DFS"><a href="#解法一：-标准DFS" class="headerlink" title="解法一： 标准DFS"></a>解法一： 标准DFS</h2><p>没啥可说的，标准DFS不会剁手</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">binaryTreePaths</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> TreePaths(root,<span class="string">""</span>,<span class="keyword">new</span> ArrayList&lt;String&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">TreePaths</span><span class="params">(TreeNode root,String path,List&lt;String&gt; paths)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="keyword">null</span>)&#123; <span class="comment">//判空，为空不加入</span></span><br><span class="line">            path+=root.val; <span class="comment">//先拼val</span></span><br><span class="line">            <span class="keyword">if</span>(root.left==<span class="keyword">null</span>&amp;root.right==<span class="keyword">null</span>)&#123; <span class="comment">//如果是叶子节点，那么add path</span></span><br><span class="line">                paths.add(path);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123; <span class="comment">//否则继续递归，拼上 '-&gt;'</span></span><br><span class="line">                path+=<span class="string">"-&gt;"</span>;</span><br><span class="line">                TreePaths(root.left,path,paths);</span><br><span class="line">                TreePaths(root.right,path,paths);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> paths; <span class="comment">//返回结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


        
      </div>
    </div>

  

  
  
    
  

    <div class="post-list-item article">
      <h3 class="article-header">
        <a href="https://github.com/GabbyYam/overyam/2020/02/25/Algorithm/Leetcode/String-Easy/" target="_blank" rel="noopener" >
  Algorithm/Leetcode/String-Easy
</a>

      </h3>
      

      <div class="article-info">
        <a href="https://github.com/GabbyYam/overyam/2020/02/25/Algorithm/Leetcode/String-Easy/" target="_blank" rel="noopener"><span class="article-date">
  2020-02-25
</span>
</a>
        

        

      </div>
      <div class="article-entry">
        
          <p>[TOC]</p>
<h1 id="13-Roman-to-Integer"><a href="#13-Roman-to-Integer" class="headerlink" title="13. Roman to Integer"></a><a href="https://leetcode-cn.com/problems/roman-to-integer/" target="_blank" rel="noopener">13. Roman to Integer</a></h1><p><img src="diagram/image-20200212125406712.png" alt="image-20200212125406712"></p>
<h2 id="解法一：Hash表"><a href="#解法一：Hash表" class="headerlink" title="解法一：Hash表"></a>解法一：Hash表</h2><p>优先判定两个字符的值，其他没什么可说的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">"I"</span>, <span class="number">1</span>);</span><br><span class="line">        map.put(<span class="string">"IV"</span>, <span class="number">4</span>);</span><br><span class="line">        map.put(<span class="string">"V"</span>, <span class="number">5</span>);</span><br><span class="line">        map.put(<span class="string">"IX"</span>, <span class="number">9</span>);</span><br><span class="line">        map.put(<span class="string">"X"</span>, <span class="number">10</span>);</span><br><span class="line">        map.put(<span class="string">"XL"</span>, <span class="number">40</span>);</span><br><span class="line">        map.put(<span class="string">"L"</span>, <span class="number">50</span>);</span><br><span class="line">        map.put(<span class="string">"XC"</span>, <span class="number">90</span>);</span><br><span class="line">        map.put(<span class="string">"C"</span>, <span class="number">100</span>);</span><br><span class="line">        map.put(<span class="string">"CD"</span>, <span class="number">400</span>);</span><br><span class="line">        map.put(<span class="string">"D"</span>, <span class="number">500</span>);</span><br><span class="line">        map.put(<span class="string">"CM"</span>, <span class="number">900</span>);</span><br><span class="line">        map.put(<span class="string">"M"</span>, <span class="number">1000</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i+<span class="number">1</span>&lt;s.length() &amp;&amp; map.containsKey(s.substring(i,i+<span class="number">2</span>)))&#123;</span><br><span class="line">                ans+=map.get(s.substring(i,i+<span class="number">2</span>));</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> ans+=map.get(s.substring(i,i+<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="14-Longest-Common-Prefix"><a href="#14-Longest-Common-Prefix" class="headerlink" title="14. Longest Common Prefix"></a><a href="https://leetcode-cn.com/problems/longest-common-prefix/" target="_blank" rel="noopener">14. Longest Common Prefix</a></h1><p><img src="diagram/image-20200212131738275.png" alt="image-20200212131738275"></p>
<h2 id="解法一：线性扫描（从前往后）"><a href="#解法一：线性扫描（从前往后）" class="headerlink" title="解法一：线性扫描（从前往后）"></a>解法一：线性扫描（从前往后）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(strs.length==<span class="number">0</span> || strs==<span class="keyword">null</span>)&#123;<span class="keyword">return</span> <span class="string">""</span>;&#125;</span><br><span class="line">        String common=<span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> min_len=Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(String s:strs)&#123;min_len=Math.min(min_len,s.length());&#125; <span class="comment">//先找最小长度min_len</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> curr=<span class="number">0</span>;curr&lt;min_len;curr++)&#123;</span><br><span class="line">            <span class="keyword">char</span> c=strs[<span class="number">0</span>].charAt(curr); <span class="comment">//以第一个为准</span></span><br><span class="line">            <span class="keyword">for</span>(String s:strs)&#123;<span class="keyword">if</span>(s.charAt(curr)!=c)<span class="keyword">return</span> common;&#125;</span><br><span class="line">            common+=c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> common;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>==<strong>[改进版]</strong>==</p>
<ul>
<li><strong>String</strong>：改进了String的操作相关，String重载的==+操作==相当耗时，因此不使用<strong>字符串拼接</strong>，<strong>而是substring</strong>的方法</li>
<li><strong>遍历：</strong>根本不需要找到最短的字符串，只要遍历时多判断一次是否超出就行了</li>
<li><strong>效果：</strong>12ms -&gt;2ms</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(strs.length==<span class="number">0</span> || strs==<span class="keyword">null</span>)&#123;<span class="keyword">return</span> <span class="string">""</span>;&#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> curr=<span class="number">0</span>;curr&lt;strs[<span class="number">0</span>].length();curr++)&#123;</span><br><span class="line">            <span class="keyword">char</span> c=strs[<span class="number">0</span>].charAt(curr);</span><br><span class="line">            <span class="keyword">for</span>(String s:strs)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.length()==curr || s.charAt(curr)!=c) <span class="comment">//新增s.length()==curr判断一下就行</span></span><br><span class="line">                    <span class="keyword">return</span> strs[<span class="number">0</span>].substring(<span class="number">0</span>,curr); <span class="comment">//改为substring,String+操作是相当费时的</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> strs[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="解法二：线性扫描（从后往前）"><a href="#解法二：线性扫描（从后往前）" class="headerlink" title="解法二：线性扫描（从后往前）"></a>解法二：线性扫描（从后往前）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (strs.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">   String prefix = strs[<span class="number">0</span>];</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; strs.length; i++)</span><br><span class="line">       <span class="keyword">while</span> (strs[i].indexOf(prefix) != <span class="number">0</span>) &#123; <span class="comment">//以第一个为准</span></span><br><span class="line">           prefix = prefix.substring(<span class="number">0</span>, prefix.length() - <span class="number">1</span>); <span class="comment">//如果不满足，每次缩小一个字符</span></span><br><span class="line">           <span class="keyword">if</span> (prefix.isEmpty()) <span class="keyword">return</span> <span class="string">""</span>; <span class="comment">//直到为空</span></span><br><span class="line">       &#125;        </span><br><span class="line">   <span class="keyword">return</span> prefix;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="20-Valid-Parentheses"><a href="#20-Valid-Parentheses" class="headerlink" title="20. Valid Parentheses"></a><a href="https://leetcode-cn.com/problems/valid-parentheses/" target="_blank" rel="noopener">20. Valid Parentheses</a></h1><p><img src="diagram/image-20200212165453479.png" alt="image-20200212165453479"></p>
<h2 id="解法一：栈（标准解法）"><a href="#解法一：栈（标准解法）" class="headerlink" title="解法一：栈（标准解法）"></a>解法一：栈（标准解法）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;Character&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> curr=<span class="number">0</span>;curr&lt;s.length();curr++)&#123;</span><br><span class="line">            <span class="keyword">char</span> c=s.charAt(curr);</span><br><span class="line">            <span class="keyword">if</span>(c==<span class="string">'('</span> || c==<span class="string">'['</span> || c==<span class="string">'&#123;'</span>) <span class="comment">//如果是左括号，压入栈中</span></span><br><span class="line">                stack.push(c);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">')'</span>)&#123;               <span class="comment">//如果是右括号，检查栈是否为空，不为空的话检查是否匹配</span></span><br><span class="line">                <span class="keyword">if</span>(stack.isEmpty() || stack.pop()!=<span class="string">'('</span>)<span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">//注意isEmpty在前</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">']'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(stack.isEmpty() || stack.pop()!=<span class="string">'['</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">'&#125;'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(stack.isEmpty() || stack.pop()!=<span class="string">'&#123;'</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();<span class="comment">//最后如果栈空则为ture,否则为false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="28-Implement-strStr"><a href="#28-Implement-strStr" class="headerlink" title="28. Implement strStr()"></a><a href="https://leetcode-cn.com/problems/implement-strstr/" target="_blank" rel="noopener">28. Implement strStr()</a></h1><p><img src="diagram/image-20200212170257180.png" alt="image-20200212170257180"></p>
<h2 id="解法一：猥琐API法（-脏脏脏！-）"><a href="#解法一：猥琐API法（-脏脏脏！-）" class="headerlink" title="解法一：猥琐API法（==脏脏脏！==）"></a>解法一：猥琐API法（==脏脏脏！==）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String haystack, String needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> haystack.indexOf(needle); <span class="comment">//这题要实现的就是indexOf的功能</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解法二：暴力匹配"><a href="#解法二：暴力匹配" class="headerlink" title="解法二：暴力匹配"></a>解法二：暴力匹配</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String haystack, String needle)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//以下三者均会卡掉for循环，需要特别处理，且equals要第一个判定，否则第二条需要进一步限定</span></span><br><span class="line">        <span class="keyword">if</span>(haystack.equals(needle))<span class="keyword">return</span> <span class="number">0</span>;                     <span class="comment">//字典等于词</span></span><br><span class="line">        <span class="keyword">if</span>(haystack.length()==<span class="number">0</span>)<span class="keyword">return</span> -<span class="number">1</span>;                       <span class="comment">//字典为空</span></span><br><span class="line">        <span class="keyword">if</span>(needle.length()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;                         <span class="comment">//词为空</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//注意curr_hay&lt;haystack.length()-needle.length()+1，必须+1，否则匹配不到最后一位</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> curr_hay=<span class="number">0</span>;curr_hay&lt;haystack.length()-needle.length()+<span class="number">1</span>;curr_hay++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> curr_nee=<span class="number">0</span>;curr_nee&lt;needle.length();curr_nee++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(haystack.charAt(curr_hay+curr_nee)!=needle.charAt(curr_nee))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span>(curr_nee==needle.length()-<span class="number">1</span>)<span class="comment">//匹配到最后一个依然正确，返回此时的curr_hay</span></span><br><span class="line">                    <span class="keyword">return</span> curr_hay;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">//没找到则返回-1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解法三：KMP（-以后再说吧-）"><a href="#解法三：KMP（-以后再说吧-）" class="headerlink" title="解法三：KMP（==以后再说吧==）"></a>解法三：KMP（==以后再说吧==）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="58-Length-of-Last-Word"><a href="#58-Length-of-Last-Word" class="headerlink" title="58. Length of Last Word"></a><a href="https://leetcode-cn.com/problems/length-of-last-word/" target="_blank" rel="noopener">58. Length of Last Word</a></h1><p><img src="diagram/image-20200212174837678.png" alt="image-20200212174837678"></p>
<h2 id="要点分析"><a href="#要点分析" class="headerlink" title="要点分析"></a>要点分析</h2><ul>
<li><strong>特殊情况：</strong>末尾有空格</li>
<li>如何找到最后一个空格？</li>
<li>连续空格怎么处理？</li>
</ul>
<h2 id="解法一：分段切割"><a href="#解法一：分段切割" class="headerlink" title="解法一：分段切割"></a>解法一：分段切割</h2><ul>
<li><strong>缺点：</strong>substring耗时，trim耗时</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLastWord</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">       s=s.trim(); <span class="comment">//开局剪切，保证末尾没有空格</span></span><br><span class="line">       String res=s;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(s.charAt(i)==<span class="string">' '</span>)res=s.substring(i+<span class="number">1</span>,s.length()); <span class="comment">//每遇到一个空格，把前面的砍掉</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> res.length(); <span class="comment">//最后的长度即为所求</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>改进版，从后往前切割，大大节省时间</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLastWord</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">       s=s.trim(); <span class="comment">//开局剪切，保证末尾没有空格</span></span><br><span class="line">       String res=s;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=s.length()-<span class="number">1</span>;i&gt;-<span class="number">1</span>;i--)&#123; <span class="comment">//从后往前砍</span></span><br><span class="line">           <span class="keyword">if</span>(s.charAt(i)==<span class="string">' '</span>)&#123;<span class="keyword">return</span> s.substring(i+<span class="number">1</span>,s.length());&#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> res.length(); <span class="comment">//最后的长度即为所求</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


        
      </div>
    </div>

  

  
  
    
  

    <div class="post-list-item article">
      <h3 class="article-header">
        <a href="https://github.com/GabbyYam/overyam/2020/02/25/Algorithm/Leetcode/Linked%20List-Easy/" target="_blank" rel="noopener" >
  Algorithm/Leetcode/Linked List-Easy
</a>

      </h3>
      

      <div class="article-info">
        <a href="https://github.com/GabbyYam/overyam/2020/02/25/Algorithm/Leetcode/Linked%20List-Easy/" target="_blank" rel="noopener"><span class="article-date">
  2020-02-25
</span>
</a>
        

        

      </div>
      <div class="article-entry">
        
          <p>[TOC]</p>
<h1 id="21-Merge-Two-Sorted-Lists"><a href="#21-Merge-Two-Sorted-Lists" class="headerlink" title="21. Merge Two Sorted Lists"></a><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/" target="_blank" rel="noopener">21. Merge Two Sorted Lists</a></h1><p><img src="diagram/image-20200212190007438.png" alt="image-20200212190007438"></p>
<h2 id="解法一：递归法"><a href="#解法一：递归法" class="headerlink" title="解法一：递归法"></a>解法一：递归法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1==<span class="keyword">null</span>)<span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(l2==<span class="keyword">null</span>)<span class="keyword">return</span> l1;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(l1.val&lt;l2.val)&#123;</span><br><span class="line">            l1.next=mergeTwoLists(l1.next,l2);</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            l2.next=mergeTwoLists(l2.next,l1);</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解法二：迭代法"><a href="#解法二：迭代法" class="headerlink" title="解法二：迭代法"></a>解法二：迭代法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        ListNode pre_head=<span class="keyword">new</span> ListNode(-<span class="number">1</span>);  <span class="comment">//合并结果的头结点，pre_head.next开始为答案</span></span><br><span class="line">        ListNode curr=pre_head;              <span class="comment">//指向当前访问节点</span></span><br><span class="line">        <span class="keyword">while</span>(l1!=<span class="keyword">null</span> &amp;&amp; l2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1.val&lt;l2.val)&#123;               <span class="comment">//根据大小判断先放谁</span></span><br><span class="line">                curr.next=l1;</span><br><span class="line">                l1=l1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                curr.next=l2;</span><br><span class="line">                l2=l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            curr=curr.next;</span><br><span class="line">        &#125;</span><br><span class="line">        curr.next=l1==<span class="keyword">null</span>?l2:l1;           <span class="comment">//当一方为null时，另一方的剩余部分放入解的尾部</span></span><br><span class="line">        <span class="keyword">return</span> pre_head.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="83-Remove-Duplicates-from-Sorted-List"><a href="#83-Remove-Duplicates-from-Sorted-List" class="headerlink" title="83. Remove Duplicates from Sorted List"></a><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/" target="_blank" rel="noopener">83. Remove Duplicates from Sorted List</a></h1><p><img src="diagram/image-20200212203421696.png" alt="image-20200212203421696"></p>
<h2 id="解法一：迭代法"><a href="#解法一：迭代法" class="headerlink" title="解法一：迭代法"></a>解法一：迭代法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(head==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       ListNode curr=head;</span><br><span class="line">       <span class="keyword">while</span>(curr!=<span class="keyword">null</span> &amp;&amp; curr.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">if</span>(curr.val==curr.next.val)</span><br><span class="line">               curr.next=curr.next.next;</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">               curr=curr.next;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="206-Reverse-Linked-List"><a href="#206-Reverse-Linked-List" class="headerlink" title="206. Reverse Linked List"></a><a href="https://leetcode-cn.com/problems/reverse-linked-list/" target="_blank" rel="noopener">206. Reverse Linked List</a></h1><p><img src="diagram/image-20200212204051451.png" alt="image-20200212204051451"></p>
<h2 id="解法一：递归法-1"><a href="#解法一：递归法-1" class="headerlink" title="解法一：递归法"></a>解法一：递归法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span> || head.next==<span class="keyword">null</span>)<span class="keyword">return</span> head; <span class="comment">//递归结束条件</span></span><br><span class="line">        </span><br><span class="line">        ListNode n_head=reverseList(head.next); <span class="comment">//next为翻转后部分的头部,即原先的尾部</span></span><br><span class="line">        head.next.next=head;                    <span class="comment">//翻转后部分的尾部，本来为null，先将它指向head</span></span><br><span class="line">        head.next=<span class="keyword">null</span>;						    <span class="comment">//将原先的head.next设为null，防止出现循环链表</span></span><br><span class="line">        <span class="keyword">return</span> n_head;                          <span class="comment">//返回新的头部</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解法二：迭代法-1"><a href="#解法二：迭代法-1" class="headerlink" title="解法二：迭代法"></a>解法二：迭代法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode prev=<span class="keyword">null</span>;          <span class="comment">//prev初始为null,所以不必担心出现循环链表</span></span><br><span class="line">        ListNode curr=head;</span><br><span class="line">        <span class="keyword">while</span>(curr!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode next=curr.next; <span class="comment">//保存curr.next</span></span><br><span class="line">            curr.next=prev;          <span class="comment">//翻转</span></span><br><span class="line">            prev=curr;</span><br><span class="line">            curr=next;               <span class="comment">//prev,curr向前移动一格</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="160-Intersection-of-Two-Linked-Lists"><a href="#160-Intersection-of-Two-Linked-Lists" class="headerlink" title="160. Intersection of Two Linked Lists"></a><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/" target="_blank" rel="noopener">160. Intersection of Two Linked Lists</a></h1><p><img src="diagram/image-20200213000309889.png" alt="image-20200213000309889"></p>
<h2 id="解法一：HashSet"><a href="#解法一：HashSet" class="headerlink" title="解法一：HashSet"></a>解法一：HashSet</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        Set&lt;ListNode&gt; set=<span class="keyword">new</span> HashSet&lt;ListNode&gt;();</span><br><span class="line">        ListNode curr_a=headA;</span><br><span class="line">        ListNode curr_b=headB;</span><br><span class="line">        <span class="keyword">while</span>(curr_a!=<span class="keyword">null</span>)&#123; <span class="comment">//遍历链表A，将所有节点加入HashSet</span></span><br><span class="line">            set.add(curr_a);</span><br><span class="line">            curr_a=curr_a.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(curr_b!=<span class="keyword">null</span>)&#123; <span class="comment">//遍历链表B，看是否有节点在HashSet存在</span></span><br><span class="line">            <span class="keyword">if</span>(set.contains(curr_b))<span class="keyword">return</span> curr_b;</span><br><span class="line">            curr_b=curr_b.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解法二：双指针"><a href="#解法二：双指针" class="headerlink" title="解法二：双指针"></a>解法二：双指针</h2><p><img src="diagram/image-20200213002852014.png" alt="image-20200213002852014"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        ListNode curr_a=headA;</span><br><span class="line">        ListNode curr_b=headB;</span><br><span class="line">        <span class="keyword">while</span>(curr_a!=<span class="keyword">null</span> &amp;&amp; curr_b!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(curr_a==curr_b)<span class="keyword">return</span> curr_a; <span class="comment">//交点</span></span><br><span class="line">            curr_a=curr_a.next;</span><br><span class="line">            curr_b=curr_b.next;</span><br><span class="line">            <span class="keyword">if</span>(curr_a==<span class="keyword">null</span> &amp;&amp; curr_b==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">null</span>;<span class="comment">//到达终点，证明不存在</span></span><br><span class="line">            <span class="keyword">if</span>(curr_a==<span class="keyword">null</span>)curr_a=headB; <span class="comment">//a接入b链</span></span><br><span class="line">            <span class="keyword">if</span>(curr_b==<span class="keyword">null</span>)curr_b=headA; <span class="comment">//b接入a链</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="234-Palindrome-Linked-List"><a href="#234-Palindrome-Linked-List" class="headerlink" title="234. Palindrome Linked List"></a><a href="https://leetcode-cn.com/problems/palindrome-linked-list/" target="_blank" rel="noopener">234. Palindrome Linked List</a></h1><p><img src="diagram/image-20200213010025647.png" alt="image-20200213010025647"></p>
<h2 id="解法一：栈"><a href="#解法一：栈" class="headerlink" title="解法一：栈"></a>解法一：栈</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack=<span class="keyword">new</span> Stack&lt;Integer&gt;(); <span class="comment">//空间复杂度O(n)</span></span><br><span class="line">        ListNode curr=head;</span><br><span class="line">        <span class="keyword">while</span>(curr!=<span class="keyword">null</span>)&#123; <span class="comment">//第一次遍历，将所有值压入栈内</span></span><br><span class="line">            stack.push(curr.val);</span><br><span class="line">            curr=curr.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="keyword">null</span>)&#123; <span class="comment">//第二次遍历，逐一比对</span></span><br><span class="line">            <span class="keyword">if</span>(stack.pop()!=head.val)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            head=head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


        
      </div>
    </div>

  

  
  
    
  

    <div class="post-list-item article">
      <h3 class="article-header">
        <a href="https://github.com/GabbyYam/overyam/2020/02/25/Algorithm/Leetcode/Greedy-Easy/" target="_blank" rel="noopener" >
  Algorithm/Leetcode/Greedy-Easy
</a>

      </h3>
      

      <div class="article-info">
        <a href="https://github.com/GabbyYam/overyam/2020/02/25/Algorithm/Leetcode/Greedy-Easy/" target="_blank" rel="noopener"><span class="article-date">
  2020-02-25
</span>
</a>
        

        

      </div>
      <div class="article-entry">
        
          <p>[TOC]</p>
<h1 id="122-Best-Time-to-Buy-and-Sell-Stock-II"><a href="#122-Best-Time-to-Buy-and-Sell-Stock-II" class="headerlink" title="122. Best Time to Buy and Sell Stock II"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/" target="_blank" rel="noopener">122. Best Time to Buy and Sell Stock II</a></h1><p><img src="diagram/image-20200210190105241.png" alt="image-20200210190105241"></p>
<h2 id="解法一：贪心"><a href="#解法一：贪心" class="headerlink" title="解法一：贪心"></a>解法一：贪心</h2><p>显然，如果允许无限次交易的话，那么只要有差价就能赚，因此总利润就是升价之和</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.length&lt;=<span class="number">1</span>)&#123;<span class="keyword">return</span> <span class="number">0</span>;&#125; <span class="comment">//特殊情况</span></span><br><span class="line">        <span class="keyword">int</span> profit=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> check=prices[i]-prices[i-<span class="number">1</span>];</span><br><span class="line">            profit+=check&gt;<span class="number">0</span>?check:<span class="number">0</span>; <span class="comment">//只要本次交易有利可得就去赚，必定能使利益最大化</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="455-Assign-Cookies"><a href="#455-Assign-Cookies" class="headerlink" title="455. Assign Cookies"></a><a href="https://leetcode-cn.com/problems/assign-cookies/" target="_blank" rel="noopener">455. Assign Cookies</a></h1><p><img src="diagram/image-20200210192349700.png" alt="image-20200210192349700"></p>
<h2 id="解法一：贪心-1"><a href="#解法一：贪心-1" class="headerlink" title="解法一：贪心"></a>解法一：贪心</h2><ul>
<li><strong>策略</strong>：先排序，用最小的饼干先喂胃口最小的小鬼</li>
<li><strong>特殊情况</strong>：两者可能为空要注意，但是本题不会有不良影响就是了</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findContentChildren</span><span class="params">(<span class="keyword">int</span>[] g, <span class="keyword">int</span>[] s)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(g);</span><br><span class="line">        Arrays.sort(s);<span class="comment">//先排序</span></span><br><span class="line">        <span class="keyword">int</span> cookie=<span class="number">0</span>,maxAssign=<span class="number">0</span>;<span class="comment">//记录饼干的位置和最大人数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;g.length;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(cookie&lt;s.length)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[cookie]&gt;=g[i])&#123;<span class="comment">//如果满足的话，人数++，饼干用掉了所以移动到下一块，cookie++</span></span><br><span class="line">                    maxAssign++;</span><br><span class="line">                    cookie++;</span><br><span class="line">                    <span class="keyword">break</span>;<span class="comment">//代码中注意不要出现break，影响美观，这里是反面教材了</span></span><br><span class="line">                &#125;</span><br><span class="line">                cookie++;<span class="comment">//不满足的话就换下一个饼干</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxAssign;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>简洁版</strong>：根本不需要专门记录最大人数，而且要去掉break这样的不良编程习惯</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findContentChildren</span><span class="params">(<span class="keyword">int</span>[] g, <span class="keyword">int</span>[] s)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(g);</span><br><span class="line">        Arrays.sort(s);<span class="comment">//先排序</span></span><br><span class="line">        <span class="keyword">int</span> cookie=<span class="number">0</span>,greedy=<span class="number">0</span>;<span class="comment">//记录饼干的位置、小鬼位置</span></span><br><span class="line">        <span class="keyword">while</span>(cookie&lt;s.length &amp;&amp; greedy&lt;g.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(g[greedy]&lt;=s[cookie])greedy++;</span><br><span class="line">            cookie++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> greedy;<span class="comment">//根本不需要记录最大人数，greedy的最终值就是最大人数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="1046-Last-Stone-Weight（-TopK问题-）"><a href="#1046-Last-Stone-Weight（-TopK问题-）" class="headerlink" title="1046. Last Stone Weight（==TopK问题==）"></a><a href="https://leetcode-cn.com/problems/last-stone-weight/" target="_blank" rel="noopener">1046. Last Stone Weight（==TopK问题==）</a></h1><p><img src="diagram/image-20200210205821512.png" alt="image-20200210205821512"></p>
<h2 id="解法一：排序"><a href="#解法一：排序" class="headerlink" title="解法一：排序"></a>解法一：排序</h2><p>依题意，每次都用最重的两块石头，那么就每轮排一次序就行了</p>
<p>虽然简洁易懂，但是==缺点是快排空间消耗比较大==，另外数据规模大时额外消耗的时间也比较大</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastStoneWeight</span><span class="params">(<span class="keyword">int</span>[] stones)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stones==<span class="keyword">null</span> || stones.length==<span class="number">0</span>)&#123;<span class="keyword">return</span> <span class="number">0</span>;&#125; <span class="comment">//特殊情况 null或为空</span></span><br><span class="line">        <span class="keyword">int</span> stoneNum=stones.length,len=stones.length;</span><br><span class="line">        <span class="keyword">while</span>(stoneNum&gt;<span class="number">1</span>)&#123;<span class="comment">//每轮都排一次序，直到石头小于一颗</span></span><br><span class="line">            Arrays.sort(stones); </span><br><span class="line">            stones[len-<span class="number">1</span>]=stones[len-<span class="number">1</span>]-stones[len-<span class="number">2</span>];</span><br><span class="line">            stones[len-<span class="number">2</span>]=<span class="number">0</span>;</span><br><span class="line">            stoneNum--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stones[len-<span class="number">1</span>];<span class="comment">//返回最后一颗石子的重量即为答案</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="解法二：优先队列"><a href="#解法二：优先队列" class="headerlink" title="解法二：优先队列"></a>解法二：优先队列</h2><p>由于问题本质是TopK问题，因此用优先队列是相当王道的做法</p>
<p>小数据下比简单排序略逊，但是数据量增大时优于排序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastStoneWeight</span><span class="params">(<span class="keyword">int</span>[] stones)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stones==<span class="keyword">null</span> || stones.length==<span class="number">0</span>)&#123;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">        Queue&lt;Integer&gt; stoneQ=</span><br><span class="line">            <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;(Collections.reverseOrder());<span class="comment">//优先队列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> stone:stones)&#123;stoneQ.add(stone);&#125;<span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">while</span>(stoneQ.size()&gt;<span class="number">2</span>)&#123;<span class="comment">//边界处理，如果&gt;1的话可能会让空队列poll</span></span><br><span class="line">            <span class="keyword">int</span> stoneSmashed=stoneQ.poll()-stoneQ.poll();</span><br><span class="line">            <span class="keyword">if</span>(stoneSmashed&gt;<span class="number">0</span>)stoneQ.add(stoneSmashed);<span class="comment">//如果没彻底smashed，就放回队列中</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stoneQ.size()&gt;<span class="number">1</span>?stoneQ.poll()-stoneQ.poll():stoneQ.peek();</span><br><span class="line">        <span class="comment">//依据情况返回对应结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="860-Lemonade-Change"><a href="#860-Lemonade-Change" class="headerlink" title="860. Lemonade Change"></a><a href="https://leetcode-cn.com/problems/lemonade-change/" target="_blank" rel="noopener">860. Lemonade Change</a></h1><p><img src="diagram/image-20200210221955255.png" alt="image-20200210221955255"></p>
<h2 id="解法一：贪心-2"><a href="#解法一：贪心-2" class="headerlink" title="解法一：贪心"></a>解法一：贪心</h2><p>如果是5块和10块没什么可说的，<strong>重点是20块</strong></p>
<p><strong>如果是20块</strong>，要优先找10块和5块组合，实在不行才用三张5块</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lemonadeChange</span><span class="params">(<span class="keyword">int</span>[] bills)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> five=<span class="number">0</span>,ten=<span class="number">0</span>;<span class="comment">//分别记录5块和10块</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;bills.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(bills[i]==<span class="number">5</span>)five++; <span class="comment">//5块时直接++</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(bills[i]==<span class="number">10</span>)&#123; <span class="comment">//10块时直接找5块，没有就gg</span></span><br><span class="line">                <span class="keyword">if</span>(five&gt;<span class="number">0</span>)&#123;ten++;five--;&#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(bills[i]==<span class="number">20</span>)&#123; <span class="comment">//优先找10块</span></span><br><span class="line">                <span class="keyword">if</span>(ten&gt;<span class="number">0</span> &amp;&amp; five&gt;<span class="number">0</span>)&#123;ten--;five--;&#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(five&gt;=<span class="number">3</span>)&#123;five-=<span class="number">3</span>;&#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="874-Walking-Robot-Simulation"><a href="#874-Walking-Robot-Simulation" class="headerlink" title="874. Walking Robot Simulation"></a><a href="https://leetcode-cn.com/problems/walking-robot-simulation/" target="_blank" rel="noopener">874. Walking Robot Simulation</a></h1><p><img src="diagram/image-20200211131354857.png" alt="image-20200211131354857"></p>
<h2 id="解法一：HashSet-模拟"><a href="#解法一：HashSet-模拟" class="headerlink" title="解法一：HashSet+模拟"></a>解法一：HashSet+模拟</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">robotSim</span><span class="params">(<span class="keyword">int</span>[] commands, <span class="keyword">int</span>[][] obstacles)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x=<span class="number">0</span>,y=<span class="number">0</span>,turn=<span class="number">0</span>,maxDistance=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] moves = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//借用官方的编码模式</span></span><br><span class="line">        Set&lt;Long&gt; obstacleSet = <span class="keyword">new</span> HashSet();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] obstacle: obstacles) &#123;</span><br><span class="line">            <span class="keyword">long</span> ox = (<span class="keyword">long</span>) obstacle[<span class="number">0</span>] + <span class="number">30000</span>;</span><br><span class="line">            <span class="keyword">long</span> oy = (<span class="keyword">long</span>) obstacle[<span class="number">1</span>] + <span class="number">30000</span>;</span><br><span class="line">            obstacleSet.add((ox &lt;&lt; <span class="number">16</span>) + oy);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;commands.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(commands[i] == -<span class="number">1</span>)&#123;turn=(turn+<span class="number">1</span>)%<span class="number">4</span>;&#125; <span class="comment">//右转90度</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(commands[i] == -<span class="number">2</span>)&#123;turn=(turn+<span class="number">3</span>)%<span class="number">4</span>;&#125; <span class="comment">//左转90度，注意不要--，负数不能%</span></span><br><span class="line">            <span class="keyword">else</span>&#123; <span class="comment">//否则应该是移动</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;commands[i];k++)&#123; <span class="comment">//一格一格地走</span></span><br><span class="line">                    moves = move(turn,moves); <span class="comment">//根据方向和command计算移动的(x,y)</span></span><br><span class="line">                    <span class="keyword">int</span> nx=x+moves[<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">int</span> ny=y+moves[<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">long</span> code = (((<span class="keyword">long</span>) nx + <span class="number">30000</span>) &lt;&lt; <span class="number">16</span>) + ((<span class="keyword">long</span>) ny + <span class="number">30000</span>);</span><br><span class="line">                    <span class="keyword">if</span> (!obstacleSet.contains(code)) &#123;</span><br><span class="line">                        x = nx;</span><br><span class="line">                        y = ny;</span><br><span class="line">                        maxDistance = Math.max(maxDistance, x*x + y*y);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxDistance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] move(<span class="keyword">int</span> turn,<span class="keyword">int</span>[] moves)&#123; <span class="comment">//判断移动的x,y</span></span><br><span class="line">        <span class="keyword">if</span>(turn%<span class="number">4</span> == <span class="number">0</span>)&#123;moves[<span class="number">0</span>]=<span class="number">0</span>;moves[<span class="number">1</span>]=<span class="number">1</span>;<span class="keyword">return</span> moves;&#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(turn%<span class="number">4</span> == <span class="number">1</span>)&#123;moves[<span class="number">0</span>]=<span class="number">1</span>;moves[<span class="number">1</span>]=<span class="number">0</span>;<span class="keyword">return</span> moves;&#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(turn%<span class="number">4</span> == <span class="number">2</span>)&#123;moves[<span class="number">0</span>]=<span class="number">0</span>;moves[<span class="number">1</span>]=-<span class="number">1</span>;<span class="keyword">return</span> moves;&#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(turn%<span class="number">4</span> == <span class="number">3</span>)&#123;moves[<span class="number">0</span>]=-<span class="number">1</span>;moves[<span class="number">1</span>]=<span class="number">0</span>;<span class="keyword">return</span> moves;&#125;</span><br><span class="line">        <span class="keyword">return</span> moves;</span><br><span class="line">        <span class="comment">//throw new IllegalArgumentException;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


        
      </div>
    </div>

  

  
  
    
  

    <div class="post-list-item article">
      <h3 class="article-header">
        <a href="https://github.com/GabbyYam/overyam/2020/02/25/Algorithm/Leetcode/DP-Easy/" target="_blank" rel="noopener" >
  Algorithm/Leetcode/DP-Easy
</a>

      </h3>
      

      <div class="article-info">
        <a href="https://github.com/GabbyYam/overyam/2020/02/25/Algorithm/Leetcode/DP-Easy/" target="_blank" rel="noopener"><span class="article-date">
  2020-02-25
</span>
</a>
        

        

      </div>
      <div class="article-entry">
        
          <p>[TOC]</p>
<h1 id="70-Climbing-Stairs"><a href="#70-Climbing-Stairs" class="headerlink" title="70. Climbing Stairs"></a><a href="https://leetcode-cn.com/problems/climbing-stairs/" target="_blank" rel="noopener">70. Climbing Stairs</a></h1><p><img src="diagram/image-20200210141009273.png" alt="image-20200210141009273"></p>
<h2 id="解法一：DP"><a href="#解法一：DP" class="headerlink" title="解法一：DP"></a>解法一：DP</h2><ul>
<li><strong>基本情况</strong>：一层楼梯有一种方法，两层楼梯两种方法，因此dp[0]=1,dp[1]=2</li>
<li><strong>转移方程</strong>：对于大于等于2的层数，dp[n-1]=dp[n-2]+dp[n-3]，即为一般解</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">1</span>)&#123;<span class="keyword">return</span> <span class="number">1</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">2</span>)&#123;<span class="keyword">return</span> <span class="number">2</span>;&#125;</span><br><span class="line">        <span class="keyword">int</span>[] dp=<span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>]=<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;n;i++)&#123;dp[i]=dp[i-<span class="number">1</span>]+dp[i-<span class="number">2</span>];&#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="121-Best-Time-to-Buy-and-Sell-Stock"><a href="#121-Best-Time-to-Buy-and-Sell-Stock" class="headerlink" title="121. Best Time to Buy and Sell Stock"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/" target="_blank" rel="noopener">121. Best Time to Buy and Sell Stock</a></h1><p><img src="diagram/image-20200210141943340.png" alt="image-20200210141943340"></p>
<h2 id="解法一：线性扫描"><a href="#解法一：线性扫描" class="headerlink" title="解法一：线性扫描"></a>解法一：线性扫描</h2><p>线性扫描，考虑到不能只求最大值和最小值，但是记录Index也是无用功</p>
<p>不妨只更新最小值，那么计算利润的值就必定是在最小值之后，那就只需无脑更新最大利润就行了</p>
<p>时间复杂度：$ O(N) $</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxProfit=<span class="number">0</span>,minPrice=Integer.MAX_VALUE; <span class="comment">//只需要最大利润和最小值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line">            minPrice=Math.min(prices[i],minPrice); </span><br><span class="line">            maxProfit=Math.max(maxProfit,prices[i]-minPrice);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxProfit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="解法二：DP"><a href="#解法二：DP" class="headerlink" title="解法二：DP"></a>解法二：DP</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="198-House-Robber"><a href="#198-House-Robber" class="headerlink" title="198. House Robber"></a><a href="https://leetcode-cn.com/problems/house-robber/" target="_blank" rel="noopener">198. House Robber</a></h1><p><img src="diagram/image-20200210145604103.png" alt="image-20200210145604103"></p>
<h2 id="解法一：DP-1"><a href="#解法一：DP-1" class="headerlink" title="解法一：DP"></a>解法一：DP</h2><ul>
<li><p><strong>特殊情况</strong>：可抢劫的房子不到三家，即0,1,2</p>
</li>
<li><p><strong>基本情况</strong>：第一家的价值是其自身，第二家的价值是第一家和第二家价值的最大值，即</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[<span class="number">0</span>]=nums[<span class="number">0</span>];</span><br><span class="line">dp[<span class="number">1</span>]=Math.max(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>转移方程</strong>：由基本情况可以推出，第n家的价值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dp[n]=Math.max(</span><br><span class="line">    dp[n-<span class="number">2</span>]+nums[n],</span><br><span class="line">	dp[n-<span class="number">1</span>]</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>结果</strong>：不是最后一家就是倒数第二家，取最大值即可</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//三种特殊情况,不考虑会越界</span></span><br><span class="line">        <span class="keyword">if</span>(nums.length==<span class="number">0</span> || nums==<span class="keyword">null</span>)&#123;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span>(nums.length==<span class="number">1</span>)&#123;<span class="keyword">return</span> nums[<span class="number">0</span>];&#125;</span><br><span class="line">        <span class="keyword">if</span>(nums.length==<span class="number">2</span>)&#123;<span class="keyword">return</span> Math.max(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);&#125;</span><br><span class="line">        <span class="keyword">int</span>[] dp=<span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="comment">//两种基本情况</span></span><br><span class="line">        dp[<span class="number">0</span>]=nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>]=Math.max(dp[<span class="number">0</span>],nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">//状态转移</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;nums.length;i++)&#123;dp[i]=Math.max((dp[i-<span class="number">2</span>]+nums[i]),dp[i-<span class="number">1</span>]);&#125;</span><br><span class="line">        <span class="comment">//最后两家的价值取最大值即可</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(dp[nums.length-<span class="number">1</span>],dp[nums.length-<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="303-Range-Sum-Query-Immutable"><a href="#303-Range-Sum-Query-Immutable" class="headerlink" title="303. Range Sum Query - Immutable"></a><a href="https://leetcode-cn.com/problems/range-sum-query-immutable/" target="_blank" rel="noopener">303. Range Sum Query - Immutable</a></h1><p><img src="diagram/image-20200210151642862.png" alt="image-20200210151642862"></p>
<h2 id="解法一：缓存"><a href="#解法一：缓存" class="headerlink" title="解法一：缓存"></a>解法一：缓存</h2><p>由于会大量调用，所以如果每次都遍历一次来计算会很慢，所以这里需要加入缓存</p>
<p>nums传入初始化时，就把到n为止的sum计算出来，结果返回两个边界的差值就行了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] sum;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NumArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        sum=<span class="keyword">new</span> <span class="keyword">int</span>[nums.length+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            sum[i+<span class="number">1</span>]=nums[i]+sum[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sum[j+<span class="number">1</span>]-sum[i];</span><br><span class="line">        <span class="comment">//注意这里是j+1 和 i ，因为如果是i+1的话，会把nums[i]也算进去，那得到的和就没有nums[i]了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="62-Unique-Paths（-Medium？Easy？-）"><a href="#62-Unique-Paths（-Medium？Easy？-）" class="headerlink" title="62. Unique Paths（==Medium？Easy？==）"></a><a href="https://leetcode-cn.com/problems/unique-paths/" target="_blank" rel="noopener">62. Unique Paths（==Medium？Easy？==）</a></h1><p><img src="diagram/image-20200210165721753.png" alt="image-20200210165721753"></p>
<h2 id="解法一：DP-2"><a href="#解法一：DP-2" class="headerlink" title="解法一：DP"></a>解法一：DP</h2><ul>
<li><p><strong>基本情况</strong>：每个格子对应的解数应为</p>
</li>
<li><p><strong>转移方程</strong>：每个格子对应的解数应为 左方格子的解数+上方格子的解数，因此</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j]=dp[i-<span class="number">1</span>][j]+dp[i][j-<span class="number">1</span>];</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>边界问题</strong>：由于边界上的格子上方或左方没有格子，直接计算会导致越界，因此长宽各扩展一格==val=0==的格子来作辅助格子</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m+<span class="number">1</span>][n+<span class="number">1</span>]; <span class="comment">//长宽都+1，自动初始化为0作为辅助</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                dp[i][j]=(i==<span class="number">1</span>&amp;&amp;j==<span class="number">1</span>)?<span class="number">1</span>:dp[i-<span class="number">1</span>][j]+dp[i][j-<span class="number">1</span>];</span><br><span class="line">                <span class="comment">//dp[1][1]为1，其他则由其按转移方程推得</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];<span class="comment">//右下角即为结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


        
      </div>
    </div>

  



  <div class="pagination">
    <a class="extend prev" rel="prev noopener" href="https://github.com/GabbyYam/overyam/archives/2020/02/page/3/" target="_blank">Prev</a><a class="page-number" href="https://github.com/GabbyYam/overyam/archives/2020/02/" target="_blank" rel="noopener">1</a><a class="page-number" href="https://github.com/GabbyYam/overyam/archives/2020/02/page/2/" target="_blank" rel="noopener">2</a><a class="page-number" href="https://github.com/GabbyYam/overyam/archives/2020/02/page/3/" target="_blank" rel="noopener">3</a><span class="page-number current">4</span><a class="page-number" href="https://github.com/GabbyYam/overyam/archives/2020/02/page/5/" target="_blank" rel="noopener">5</a><a class="extend next" rel="next noopener" href="https://github.com/GabbyYam/overyam/archives/2020/02/page/5/" target="_blank">Next</a>
  </div>




          <div class="main-footer">
  
    © 2020 OverYam - Powered by <a href="http://hexo.io" target="_blank">Hexo</a> - Theme <a href="https://github.com/denjones/hexo-theme-chan" target="_blank">Chan</a>
  
</div>

      
        </div>
      
    </div>
  </div>
  
<script src="//apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>


  
<link rel="stylesheet" href="https://github.com/GabbyYam/overyam/PhotoSwipe/photoswipe.css">

  
<link rel="stylesheet" href="https://github.com/GabbyYam/overyam/PhotoSwipe/default-skin/default-skin.css">


  <!-- Root element of PhotoSwipe. Must have class pswp. -->
  <div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe.
             It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

      <!-- Container that holds slides.
                PhotoSwipe keeps only 3 of them in the DOM to save memory.
                Don't modify these 3 pswp__item elements, data is added later on. -->
      <div class="pswp__container">
        <div class="pswp__item"></div>
        <div class="pswp__item"></div>
        <div class="pswp__item"></div>
      </div>

      <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
      <div class="pswp__ui pswp__ui--hidden">

        <div class="pswp__top-bar">

          <!--  Controls are self-explanatory. Order can be changed. -->

          <div class="pswp__counter"></div>

          <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

          <button class="pswp__button pswp__button--share" title="Share"></button>

          <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

          <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

          <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
          <!-- element will get class pswp__preloader--active when preloader is running -->
          <div class="pswp__preloader">
            <div class="pswp__preloader__icn">
              <div class="pswp__preloader__cut">
                <div class="pswp__preloader__donut"></div>
              </div>
            </div>
          </div>
        </div>

        <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
          <div class="pswp__share-tooltip"></div>
        </div>

        <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>

        <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button>

        <div class="pswp__caption">
          <div class="pswp__caption__center"></div>
        </div>
      </div>
    </div>
  </div>

  
<script src="https://github.com/GabbyYam/overyam/PhotoSwipe/photoswipe.js"></script>

  
<script src="https://github.com/GabbyYam/overyam/PhotoSwipe/photoswipe-ui-default.js"></script>




<script src="https://github.com/GabbyYam/overyam/perfect-scrollbar/js/min/perfect-scrollbar.min.js"></script>


<script src="https://github.com/GabbyYam/overyam/scripts/main.js"></script>


</body>
</html>
