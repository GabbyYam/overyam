<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



<title>
  
    Tree-Medium
  
</title>

<meta property="og:type" content="article">
<meta property="og:title" content="Tree-Medium">
<meta property="og:url" content="https://gabbyyam.github.io/overyam/posts/1d499a5/">
<meta property="og:site_name" content="Overyam">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gabbyyam.github.io/overyam/posts/1d499a5/image-20200227000049240.png">
<meta property="og:image" content="https://gabbyyam.github.io/overyam/posts/1d499a5/image-20200227000119239.png">
<meta property="og:image" content="https://gabbyyam.github.io/overyam/posts/1d499a5/image-20200227000238249.png">
<meta property="og:image" content="https://gabbyyam.github.io/overyam/posts/1d499a5/image-20200227000418519.png">
<meta property="og:image" content="https://gabbyyam.github.io/overyam/posts/1d499a5/image-20200227000435747.png">
<meta property="og:image" content="https://gabbyyam.github.io/overyam/posts/1d499a5/image-20200503131307056.png">
<meta property="og:image" content="https://gabbyyam.github.io/overyam/posts/1d499a5/image-20200503142403228.png">
<meta property="og:image" content="https://gabbyyam.github.io/overyam/posts/1d499a5/image-20200503143559912.png">
<meta property="og:image" content="https://gabbyyam.github.io/overyam/posts/1d499a5/image-20200503150648854.png">
<meta property="og:image" content="https://gabbyyam.github.io/overyam/posts/1d499a5/image-20200504012809929.png">
<meta property="og:image" content="https://gabbyyam.github.io/overyam/posts/1d499a5/image-20200505024854849.png">
<meta property="og:image" content="https://gabbyyam.github.io/overyam/posts/1d499a5/image-20200507125648455.png">
<meta property="og:image" content="https://gabbyyam.github.io/overyam/posts/1d499a5/image-20200507195447964.png">
<meta property="og:image" content="https://gabbyyam.github.io/overyam/posts/1d499a5/image-20200509121247264.png">
<meta property="og:image" content="https://gabbyyam.github.io/overyam/posts/1d499a5/image-20200510141728283.png">
<meta property="og:image" content="https://gabbyyam.github.io/overyam/posts/1d499a5/image-20200924062834644.png">
<meta property="article:published_time" content="2020-02-26T15:17:10.000Z">
<meta property="article:modified_time" content="2020-09-23T22:37:48.813Z">
<meta property="article:author" content="GabbyYam">
<meta property="article:tag" content="leetcode">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gabbyyam.github.io/overyam/posts/1d499a5/image-20200227000049240.png">


  <link rel="alternative" href="/atom.xml" title="Overyam" type="application/atom+xml">



  <link rel="icon" href="https://github.com/GabbyYam/img_repo/raw/master/img/438428e9bcec7d7793a6a132b4476f55.png">


//
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/semantic-ui/2.4.1/semantic.min.css">


<link rel="stylesheet" href="/overyam/perfect-scrollbar/css/perfect-scrollbar.min.css">


<link rel="stylesheet" href="/overyam/styles/main.css">








  <script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/semantic-ui/2.4.1/semantic.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.24.0/moment.min.js"></script>
  <script src="https://ajax.googleapis.com/ajax/libs/jqueryui/1.11.2/jquery-ui.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jplayer/2.6.4/jquery.jplayer/jquery.jplayer.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jplayer/2.6.4/add-on/jplayer.playlist.min.js"></script>
  <script type="text/javascript">
        $(document).ready(function(){


      var playlist = [{
          title:"every day is night",
          artist:"",
          mp3:"http://music.163.com/song/media/outer/url?id=441491887.mp3",
          oga:"",
          poster: "https://i.ytimg.com/vi/LSIafJnomgU/hqdefault.jpg"
        },{
          title:"Cro Magnon Man",
          artist:"",
          mp3:"http://www.jplayer.org/audio/mp3/TSP-01-Cro_magnon_man.mp3",
          poster: "https://i.imgur.com/lXvsuBu.png"
        },{
          title:"Bubble",
          m4a: "http://www.jplayer.org/audio/m4a/Miaow-07-Bubble.m4a",
          oga: "http://www.jplayer.org/audio/ogg/Miaow-07-Bubble.ogg",
          poster: "https://i.imgur.com/klJKSVZ.jpg"
      }];
      
      var cssSelector = {
        jPlayer: "#jquery_jplayer",
        cssSelectorAncestor: ".music-player"
      };
      
      var options = {
        swfPath: "https://cdnjs.cloudflare.com/ajax/libs/jplayer/2.6.4/jquery.jplayer/Jplayer.swf",
        supplied: "ogv, m4v, mp3",
        volumechange: function(event) {
          $( ".volume-level" ).slider("value", event.jPlayer.options.volume);
        },
        timeupdate: function(event) {
          $( ".progress" ).slider("value", event.jPlayer.status.currentPercentAbsolute);
        }
      };
      
      var myPlaylist = new jPlayerPlaylist(cssSelector, playlist,options);
      var PlayerData = $(cssSelector.jPlayer).data("jPlayer");
      
      
      // Create the volume slider control
      $( ".volume-level" ).slider({
         animate: "fast",
        max: 1,
        range: "min",
        step: 0.01,
        value : $.jPlayer.prototype.options.volume,
        slide: function(event, ui) {
          $(cssSelector.jPlayer).jPlayer("option", "muted", false);
          $(cssSelector.jPlayer).jPlayer("option", "volume", ui.value);
        }
      });
      
      // Create the progress slider control
      $(".progress").slider({
        animate: "fast",
        max: 100,
        range: "min",
        step: 0.1,
        value : 0,
        slide: function(event, ui) {
          var sp = PlayerData.status.seekPercent;
          if(sp > 0) {
            // Move the play-head to the value and factor in the seek percent.
            $(cssSelector.jPlayer).jPlayer("playHead", ui.value * (100 / sp));
          } else {
            // Create a timeout to reset this slider to zero.
            setTimeout(function() {
               $( ".progress" ).slider("value", 0);
            }, 0);
          }
        }
      });

      
    });
  </script>
  <!-- click-heart -->
  <!-- <script type="text/javascript">!function(e,t,a){function n(){c(".heart{width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 500%;-moz-border-radius: 50%;position: fixed;}.heart:after{top: -5px;}.heart:before{left: -5px;}"),o(),r()}function r(){for(var e=0;e<d.length;e++)d[e].alpha<=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText="left:"+d[e].x+"px;top:"+d[e].y+"px;opacity:"+d[e].alpha+";transform:scale("+d[e].scale+","+d[e].scale+") rotate(45deg);background:"+d[e].color+";z-index:99999");requestAnimationFrame(r)}function o(){var t="function"==typeof e.onclick&&e.onclick;e.onclick=function(e){t&&t(),i(e)}}function i(e){var a=t.createElement("div");a.className="heart",d.push({el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()}),t.body.appendChild(a)}function c(e){var a=t.createElement("style");a.type="text/css";try{a.appendChild(t.createTextNode(e))}catch(t){a.styleSheet.cssText=e}t.getElementsByTagName("head")[0].appendChild(a)}function s(){return"rgb("+~~(255*Math.random())+","+~~(255*Math.random())+","+~~(255*Math.random())+")"}var d=[];e.requestAnimationFrame=function(){return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e){setTimeout(e,1e3/60)}}(),n()}(window,document);
  </script> -->

  <!-- 标题变换 -->
  <script type="text/javascript">
    var OriginTitle = document.title;
    var titleTime;
    document.addEventListener('visibilitychange', function () {
       if (document.hidden) {
           $('[rel="icon"]').attr('href', "https://github.com/GabbyYam/img_repo/raw/master/img/438428e9bcec7d7793a6a132b4476f55.png");
           document.title = '**遁入幻想**';
           clearTimeout(titleTime);
       }
       else {
           $('[rel="icon"]').attr('href', "https://github.com/GabbyYam/img_repo/raw/master/img/438428e9bcec7d7793a6a132b4476f55.png");
           document.title = '即将抵达月面..';
           titleTime = setTimeout(function () {
               document.title = '欢迎回来！';
           }, 1000);
           titleTime = setTimeout(function () {
               document.title = OriginTitle;
           }, 2000);
       }
    });
  </script>

  <!-- night mode -->
  <script type="text/javascript">
    $(function(){
      btn = $('.set-view-mode');
      if(sessionStorage.mode=="night"){
          $('body').addClass('night-mode');
          btn.find('i').attr('class','icon moon outline');
      }
      $('.set-view-mode').click(function(){
          var next_mode = $('body').hasClass('night-mode') ? 'day':'night';
          if(next_mode!='day'){
              $('body').addClass('night-mode');
              btn.find('i').attr('class','icon moon');
              sessionStorage.mode="night";   
          }else{
              $('body').removeClass('night-mode');
              btn.find('i').attr('class','icon moon outline');
              sessionStorage.mode="day";
          }
      });     
  });
  </script>


  <!-- Highlight.js -->
  <link rel="stylesheet" href="//cdn.bootcss.com/highlight.js/9.2.0/styles/kimbie.dark.min.css">
  <script src="//cdn.bootcss.com/highlight.js/9.2.0/highlight.min.js">
  </script>
  <script>
    hljs.initHighlightingOnLoad();
  </script>
<meta name="generator" content="Hexo 4.2.0"></head>
<body 
  
    class="monochrome night-mode"
  
  >
  <div id="topAnchor"></div>
  <div class="mobile-header">
  <button class="sidebar-toggle" type="button">
    <span class="icon-bar"></span>
    <span class="icon-bar"></span>
    <span class="icon-bar"></span>
  </button>
  <a class="title" href="/overyam/">Overyam</a>
</div>

  <div class="main-container">

    
    <div class="sidebar">
  <div class="header">
    <h1 class="title"><a href="/overyam/">Overyam</a></h1>
    
    <div class="info">
      <div class="content">
        
        
      </div>
      
        <div class="avatar" data-tooltip="Hey~" data-position="left center">
            
              <img src="https://avatars3.githubusercontent.com/u/33481136?v=4">
                <a href="/overyam/about"></a>
              </img>
            
            

        </div>

      

    </div>
  </div>
  <div class="body">
    
      
        <ul class="nav">
          
            
              <li class="category-list-container">
                <a href="javascript:;">分类</a>
                <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/overyam/categories/Algorithm/">Algorithm</a><span class="category-list-count">37</span></li><li class="category-list-item"><a class="category-list-link" href="/overyam/categories/Java/">Java</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/overyam/categories/Reading-report/">Reading report</a><span class="category-list-count">1</span></li></ul>
              </li>
            
          
            
              <li class="tag-list-container">
                <a href="javascript:;">标签</a>
                <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/overyam/tags/Leetcode/" rel="tag">-Leetcode</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/overyam/tags/Astronomy/" rel="tag">Astronomy</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/overyam/tags/CSP/" rel="tag">CSP</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/overyam/tags/Leetcode/" rel="tag">Leetcode</a><span class="tag-list-count">13</span></li><li class="tag-list-item"><a class="tag-list-link" href="/overyam/tags/PAT-A/" rel="tag">PAT-A</a><span class="tag-list-count">9</span></li><li class="tag-list-item"><a class="tag-list-link" href="/overyam/tags/PAT-Advanced/" rel="tag">PAT-Advanced</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/overyam/tags/Reading-report/" rel="tag">Reading report</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/overyam/tags/cache/" rel="tag">cache</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/overyam/tags/concurrency/" rel="tag">concurrency</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/overyam/tags/leetcode/" rel="tag">leetcode</a><span class="tag-list-count">11</span></li></ul>
              </li>
            
          
            
              <li class="archive-list-container">
                <a href="javascript:;">归档</a>
                <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/overyam/archives/2020/">2020</a><span class="archive-list-count">45</span></li></ul>
              </li>
            
          
        </ul>

      
        <ul class="nav">
          
            
              <li>
                <a href="/overyam/" title="文章列表" external="false">文章列表</a>
              </li>
            
          
            
              <li>
                <a href="/overyam/logs" title="主页" external="false">主页</a>
              </li>
            
          
            
              <li>
                <a href="/overyam/about" title="关于我" external="false">关于我</a>
              </li>
            
          
        </ul>

      
    
    
<link href="https://fonts.googleapis.com/css?family=Lato" rel="stylesheet">

<ul class="content__container__text text_header">
      Thinking
</ul>
<div class="content">

  <div class="content__container"> 
    <ul class="content__container__text">
      In
    </ul>
    
    <ul class="content__container__list">
      <li class="content__container__list__item">Java</li>
      <li class="content__container__list__item">Graphics</li>
      <li class="content__container__list__item">Algorithm</li>
      <li class="content__container__list__item">Programming</li>
    </ul>
  </div>
</div>
<textarea tabindex="-1"></textarea>
<div class="mask"></div>
<div class="note" contenteditable>
  Just relaxed, and drink a cup of coffee huh?
</div>

  </div>
</div>

    <div class="main-content">

      <div class="trans-box">
          <div class="music-player">
                  <div style="background-image: url(https://i.imgur.com/yqB0erk.jpg);" class="album"></div>
                  
                  <div class="info">
                    
                    <div class="left">
                      <a href="javascript:;" class="icon-shuffle" data-tooltip="just a decoration^_^" data-position="bottom left"></a>
                      <a href="javascript:;" class="icon-heart" data-tooltip="just a decoration^_^" data-position="bottom left"></a>
                    </div>
                    
                    <div class="center">
                      <div class="jp-playlist">
                        <ul>
                          <li></li>
                        </ul>
                      </div> 
                    </div>
                    
                    <div class="right">
                      <a href="javascript:;" class="icon-repeat" data-tooltip="just a decoration^_^" data-position="bottom right"></a>
                      <a href="javascript:;" class="icon-share" data-tooltip="just a decoration^_^" data-position="bottom right"></a>
                    </div>
                    
                    <div class="progress"></div>
                    
                  </div>
                      
                  <div class="controls">
                    <div class="current jp-current-time">00:00</div>
                    <div class="play-controls">
                      <i href="javascript:;" class="backward icon jp-previous" title="previous"></i>
                      <i href="javascript:;" class="play icon jp-play" title="play"></i>
                      <i href="javascript:;" class="pause icon jp-pause" title="pause"></i>
                      <i href="javascript:;" class="forward icon jp-next" title="next"></i>
                    </div>
                    <div class="volume-level">
                      <i href="javascript:;" class="icon volume down" title="max volume"></i>
                      <i href="javascript:;" class="icon volume off" title="mute"></i>
                    </div>
                  </div>
                  
                  <div id="jquery_jplayer" class="jp-jplayer"></div>
                </div>

      
        <div style="max-width: 1000px">
      
          

<article id="post-Tree-Medium" class="article article-type-post">

  
    <h1 class="article-header">
      Tree-Medium
    </h1>
  
  
  

    
  <div class="article-info">
    <span class="article-date">
  2020-02-26
</span>

    
	<span class="article-category tagcloud">
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/overyam/categories/Algorithm/">Algorithm</a></li></ul>
	</span>


    
	<span class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/overyam/tags/leetcode/" rel="tag">leetcode</a></li></ul>
	</span>


  </div>
  <div class="article-entry">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css"><div class=".article-gallery" <p><strong>Abstract：</strong> 更新部分<code>Medium</code>难度 <code>Tree</code>相关题解<p></p>
<a id="more"></a>
<h1 id="94-Binary-Tree-Inorder-Traversal"><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/" target="_blank" rel="noopener">94. Binary Tree Inorder Traversal</a></h1>
<p><a href="Tree-Medium/image-20200227000049240.png" title="image-20200227000049240" class="gallery-item"><img src="image-20200227000049240.png" alt="image-20200227000049240"></a></p>
<h2 id="解法一：递归法">解法一：递归法</h2>
<p>没什么好说的，不会砍手</p>
<pre><code class="language-java">class Solution {
    List&lt;Integer&gt; inorder=new ArrayList&lt;Integer&gt;();
    public List&lt;Integer&gt; inorderTraversal(TreeNode root) {
        if(root!=null){
        inorder=inorderTraversal(root.left);
        inorder.add(root.val);
        inorder=inorderTraversal(root.right);}
        
        return inorder;
    }
}
</code></pre>
<h2 id="解法二：迭代法">解法二：迭代法</h2>
<p>比递归法难理解一些，重点是理解好如何回溯</p>
<pre><code class="language-java">class Solution {
    List&lt;Integer&gt; inorder=new ArrayList&lt;Integer&gt;();
    Stack&lt;TreeNode&gt; stack=new Stack&lt;TreeNode&gt;();
    public List&lt;Integer&gt; inorderTraversal(TreeNode root) {
        TreeNode curr=root; //辅助接点curr，指向当前访问的TreeNode
        while(curr!=null || !stack.isEmpty()){ //当前访问的节点不为空或栈不为空，说明还没遍历完
            while(curr!=null){ //不断压入左节点
                stack.push(curr);
                curr=curr.left;
            }
            curr=stack.pop(); //**回溯**
            inorder.add(curr.val); //将当前访问的节点加入
            curr=curr.right; //如果有右节点则访问右节点，如果没有将在下一轮回溯或者结束
        }
        return inorder;
    }
}
</code></pre>
<h2 id="解法三：-莫比斯遍历">解法三： 莫比斯遍历</h2>
<pre><code class="language-java">//待补全
</code></pre>
<h1 id="96-Unique-Binary-Search-Trees"><a href="https://leetcode-cn.com/problems/unique-binary-search-trees/" target="_blank" rel="noopener">96. Unique Binary Search Trees</a></h1>
<p><a href="Tree-Medium/image-20200227000119239.png" title="image-20200227000119239" class="gallery-item"><img src="image-20200227000119239.png" alt="image-20200227000119239"></a></p>
<h2 id="解法一：递归法-v2">解法一：递归法</h2>
<ul>
<li>
<p>**思路：**分别以1-n的任意整数为根，那么左右子树有哪些值是可以确定的，因此可以递归地来做</p>
</li>
<li>
<p><strong>要点：</strong>{4,5,6,7,8}在此处可以等价于{1,2,3,4,5}，因此可以很方便的进行递归，但是在这里只是个取巧的做法</p>
</li>
<li>
<p>**缺点：**没有保存递归结果，增加了许多重复的操作，下一个解法考虑对结果进行缓存</p>
</li>
</ul>
<pre><code class="language-java">class Solution {
    public int numTrees(int n) {
        if(n&lt;=1)return 1; //特殊情况，以及递归的基准
        int uniqueNum=0;
        for(int i=1;i&lt;=n;i++){uniqueNum+=numTrees(i-1)*numTrees(n-i);} //递归左右区间的乘积
        return uniqueNum;
    }
}
</code></pre>
<h2 id="解法二：记忆化递归">解法二：记忆化递归</h2>
<p>直接递归的缺点是重复递归很多地方，所以需要剪枝</p>
<pre><code class="language-java">class Solution {
    public int numTrees(int n) {
        int[] dp=new int[n+1];
        return dynamicNumTrees(n,dp);
    }

    public int dynamicNumTrees(int n,int[] dp){
        if(n&lt;=1){return 1;}
        if(dp[n]!=0){return dp[n];} //加入缓存
        for(int i=1;i&lt;=n;i++){dp[n]+=dynamicNumTrees(i-1,dp)*dynamicNumTrees(n-i,dp);}
        return dp[n];
    }
}
</code></pre>
<h1 id="95-Unique-Binary-Search-Trees-II"><a href="https://leetcode-cn.com/problems/unique-binary-search-trees-ii/" target="_blank" rel="noopener">95. Unique Binary Search Trees II</a></h1>
<p><a href="Tree-Medium/image-20200227000238249.png" title="image-20200227000238249" class="gallery-item"><img src="image-20200227000238249.png" alt="image-20200227000238249"></a></p>
<h2 id="解法一：递归法-v3">解法一：递归法</h2>
<p>和上题类似的递归思路，不过注意<mark>root的创建时机</mark></p>
<pre><code class="language-java">class Solution {
    public List&lt;TreeNode&gt; generateTrees(int n) {
        if(n==0)return new LinkedList&lt;TreeNode&gt;(); //特殊情况
        return generate(1,n);
    }

    public List&lt;TreeNode&gt; generate(int lo,int hi){
        List&lt;TreeNode&gt; BSTs=new LinkedList&lt;TreeNode&gt;();     //注意ArrayList不能加入null
        if(lo&gt;hi){BSTs.add(null);return BSTs;}              //加入null
        if(lo==hi){BSTs.add(new TreeNode(lo));return BSTs;} //递归边界
        for(int i=lo;i&lt;=hi;i++){
            List&lt;TreeNode&gt; leftList=generate(lo,i-1);
            List&lt;TreeNode&gt; rightList=generate(i+1,hi); //分别取得左右子树的递归结果
            for(TreeNode leftRoot:leftList){
                for(TreeNode rightRoot:rightList){    
                    TreeNode root=new TreeNode(i);//root应该在循环体内new，否则会和上一轮的混淆
                    root.left=leftRoot;
                    root.right=rightRoot;
                    BSTs.add(root);
                }
            }
        }
        return BSTs;
    }
}
</code></pre>
<h2 id="解法二：记忆化递归-v2">解法二：记忆化递归</h2>
<pre><code class="language-java">//这是啥?
</code></pre>
<h1 id="105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal"><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/" target="_blank" rel="noopener">105. Construct Binary Tree from Preorder and Inorder Traversal</a></h1>
<p><a href="Tree-Medium/image-20200227000418519.png" title="image-20200227000418519" class="gallery-item"><img src="image-20200227000418519.png" alt="image-20200227000418519"></a></p>
<h2 id="解法一：递归法-v4">解法一：递归法</h2>
<p>这题的重点是如何分别在inorder和preorder中划分左右子树</p>
<ul>
<li><strong>preorder的头部是root</strong></li>
<li>**inorder如何划分：**在inorder中找到root，那么在此之前的为left，之后的为right</li>
<li>**preorder如何划分：**inorder中，left-root即为left的长度leftSize，由此推出以下关系</li>
</ul>
<pre><code class="language-java">//左子树
next_p_lo=p_lo+1;
next_p_hi=p_lo+leftSize;
next_i_lo=i_lo;
next_i_hi=i_lo+leftSize+1;
//右子树
next_p_lo=p_lo+leftSize+1;
next_p_hi=p_hi;
next_i_lo=i_lo+leftSize+1;
next_i_hi=p_hi;
</code></pre>
<pre><code class="language-java">class Solution {
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        int len=preorder.length-1;
        return build(preorder,inorder,0,len,0,len);
    }

    public TreeNode build(int[] preorder,int[] inorder,int p_lo,int p_hi,int i_lo,int i_hi){
        if(p_lo&gt;p_hi || i_lo&gt;i_hi){return null;} //越界判定 &amp; 递归结束
        int leftSize=0;
        for(int i=i_lo;i&lt;=i_hi;i++){ //在inorder中找到root并算出leftSize
            if(inorder[i]==preorder[p_lo]){leftSize=i-i_lo;}
        }
        TreeNode root=new TreeNode(preorder[p_lo]); //依据已有关系，构造根节点和左右子树
        root.left=build(preorder,inorder,p_lo+1,p_lo+leftSize,i_lo,i_lo+leftSize-1);
        root.right=build(preorder,inorder,p_lo+leftSize+1,p_hi,i_lo+leftSize+1,i_hi);
        return root;
    }
}
</code></pre>
<h3 id="新写法，忘了上面那个愚蠢的玩意儿吧">新写法，忘了上面那个愚蠢的玩意儿吧</h3>
<pre><code class="language-cpp">class Solution {
public:
    TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) {
        int last = preorder.size() - 1;
        return build(preorder, inorder, 0, 0, last);
    }

    TreeNode* build(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder, int root, int start, int end) {
        if(start &gt; end) return NULL;
        int val = preorder[root], i = start;
        while(i &lt; end &amp;&amp; val != inorder[i]) i++;
        TreeNode* r = new TreeNode(val);
        r-&gt;left  = build(preorder, inorder, root + 1, start, i - 1);
        r-&gt;right = build(preorder, inorder, root + i + 1 - start, i + 1, end);
        return r;
    }
};
</code></pre>
<h1 id="98-Validate-Binary-Search-Tree"><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/" target="_blank" rel="noopener">98. Validate Binary Search Tree</a></h1>
<p><a href="Tree-Medium/image-20200227000435747.png" title="image-20200227000435747" class="gallery-item"><img src="image-20200227000435747.png" alt="image-20200227000435747"></a></p>
<h2 id="解法一：中序遍历">解法一：中序遍历</h2>
<p>判断BST，<strong>容易简单认为是</strong>只要左子树比根节点小，右子树比根节点大，以此递归就行</p>
<p>但是，上述策略忽略了一点：<mark>左子树&lt;右子树</mark></p>
<p>因此必须保证这一点，考虑到<mark>BST的特性：中序遍历</mark>，得出以下解法</p>
<pre><code class="language-java">class Solution {
    List&lt;Integer&gt; inorder=new ArrayList&lt;Integer&gt;();
    public boolean isValidBST(TreeNode root) {
        inorder(root);
        for(int i=1;i&lt;inorder.size();i++){ //检查中序遍历结果是否顺序即可
            if(inorder.get(i)&lt;=inorder.get(i-1))return false;
        }
        return true;
    }

    public void inorder(TreeNode root){
        if(root!=null){
            inorder(root.left);
            inorder.add(root.val);
            inorder(root.right);
        }
    }
}
</code></pre>
<h2 id="解法二：迭代法-v2">解法二：迭代法</h2>
<p>边迭代边检查，还可以写成递归法，不过同理就不写了</p>
<pre><code class="language-java">class Solution {
    Stack&lt;TreeNode&gt; stack=new Stack&lt;TreeNode&gt;();
    public boolean isValidBST(TreeNode root) {
        if(root==null)return true;
        TreeNode curr=root;
        Integer val=null; //注意这里要用Integer而不是int，因为可以用null,不然无论设成什么都能被卡掉
        while(curr!=null || !stack.isEmpty()){
            while(curr!=null){
                stack.push(curr);
                curr=curr.left;
            }
            curr=stack.pop();
            if(val!=null &amp;&amp; curr.val&lt;=val){return false;} //错误判定
            val=curr.val;
            curr=curr.right;
        }
        return true;
    }
}
</code></pre>
<h1 id="102-Binary-Tree-Level-Order-Traversal"><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">102. Binary Tree Level Order Traversal</a></h1>
<p><a href="Tree-Medium/image-20200503131307056.png" title="image-20200503131307056" class="gallery-item"><img src="image-20200503131307056.png" alt="image-20200503131307056"></a></p>
<h2 id="解法一：队列">解法一：队列</h2>
<p>标准层次遍历</p>
<pre><code class="language-cpp">class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) {
        if(root == NULL) return {};
        std::queue&lt;TreeNode*&gt; q;
        q.push(root);
        vector&lt;int&gt; tmp;
        vector&lt;vector&lt;int&gt;&gt; res;
        while(!q.empty()){
            int len = q.size();
            for(int i = 0; i &lt; len; i++){
                TreeNode* curr = q.front(); q.pop();
                tmp.push_back(curr-&gt;val);
                if(curr-&gt;left)  q.push(curr-&gt;left);
                if(curr-&gt;right) q.push(curr-&gt;right);
            }
            res.push_back(tmp);
            tmp.clear();
        }
        return res;
    }
};
</code></pre>
<h1 id="103-Binary-Tree-Zigzag-Level-Order-Traversal"><a href="https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/" target="_blank" rel="noopener">103. Binary Tree Zigzag Level Order Traversal</a></h1>
<p><a href="Tree-Medium/image-20200503142403228.png" title="image-20200503142403228" class="gallery-item"><img src="image-20200503142403228.png" alt="image-20200503142403228"></a></p>
<h2 id="解法一：队列-v2">解法一：队列</h2>
<p>同上题，但是要求每一层反转顺序，因此</p>
<ul>
<li>如果从左往右，那么同上题</li>
<li>如果从右往左，从队列尾端取节点，并且对应子节点逆序送入队首</li>
</ul>
<pre><code class="language-cpp">class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; zigzagLevelOrder(TreeNode* root) {
        if(root == NULL) return {};
        deque&lt;TreeNode*&gt; q; q.push_back(root);
        vector&lt;int&gt; tmp; vector&lt;vector&lt;int&gt;&gt; res;
        bool left = true;
        while(!q.empty()){
            int len = q.size();
            for(int i = 0; i &lt; len; i++){
                TreeNode* curr;
                if(left) {
                    curr = q.front(); q.pop_front();
                    if(curr-&gt;left)  q.push_back(curr-&gt;left);
                    if(curr-&gt;right) q.push_back(curr-&gt;right);
                }
                else {
                    curr = q.back(); q.pop_back();
                    if(curr-&gt;right) q.push_front(curr-&gt;right);
                    if(curr-&gt;left)  q.push_front(curr-&gt;left);
                }
                tmp.push_back(curr-&gt;val);
            }
            res.push_back(tmp);
            tmp.clear();
            left = !left;
        }
        return res;
    }
};
</code></pre>
<h1 id="113-Path-Sum-II"><a href="https://leetcode-cn.com/problems/path-sum-ii/" target="_blank" rel="noopener">113. Path Sum II</a></h1>
<p><a href="Tree-Medium/image-20200503143559912.png" title="image-20200503143559912" class="gallery-item"><img src="image-20200503143559912.png" alt="image-20200503143559912"></a></p>
<h2 id="解法一：递归法-v5">解法一：递归法</h2>
<p>递归就完了，和Ⅰ完全一样</p>
<pre><code class="language-cpp">class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; res;
    vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int sum) {
        vector&lt;int&gt; tmp;
        findSum(root, sum, tmp);
        return res;
    }

    void findSum(TreeNode* root, int sum, vector&lt;int&gt; tmp){
        if(root == NULL) return;
        sum -= root-&gt;val;
        tmp.push_back(root-&gt;val);
        if(sum == 0 &amp;&amp; !root-&gt;left &amp;&amp; !root-&gt;right){
            res.push_back(tmp);
            return;
        }
        findSum(root-&gt;left, sum, tmp);
        findSum(root-&gt;right, sum, tmp);
        return;
    }
};
</code></pre>
<h1 id="114-Flatten-Binary-Tree-to-Linked-List"><a href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/" target="_blank" rel="noopener">114. Flatten Binary Tree to Linked List</a></h1>
<p><a href="Tree-Medium/image-20200503150648854.png" title="image-20200503150648854" class="gallery-item"><img src="image-20200503150648854.png" alt="image-20200503150648854"></a></p>
<h2 id="解法一：递归法-v6">解法一：递归法</h2>
<p>基本原则就是，把左子树删除，并接到右子树，而原来的右子树再接到新的右子树的最右处，递归展开左右子树</p>
<pre><code class="language-cpp">class Solution {
public:
    void flatten(TreeNode* root) {
        if(root == NULL || (!root-&gt;left &amp;&amp; !root-&gt;right)) return;
        TreeNode* left = root-&gt;left, * right = root-&gt;right, * curr = root;
        flatten(left);
        flatten(right);
        curr-&gt;left  = NULL;
        curr-&gt;right = left;
        while(curr-&gt;right) curr = curr-&gt;right;
        curr-&gt;right = right;
        return;
    }
};
</code></pre>
<h1 id="129-Sum-Root-to-Leaf-Numbers"><a href="https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/" target="_blank" rel="noopener">129. Sum Root to Leaf Numbers</a></h1>
<p><a href="Tree-Medium/image-20200504012809929.png" title="image-20200504012809929" class="gallery-item"><img src="image-20200504012809929.png" alt="image-20200504012809929"></a></p>
<h2 id="解法一：递归法-v7">解法一：递归法</h2>
<p>同pathSum系列，先把所有pathSum算出来存到一个vector，最后再累加</p>
<pre><code class="language-cpp">class Solution {
public:
    vector&lt;int&gt; vals;
    int sumNumbers(TreeNode* root) {
        getSum(root, 0);
        int sum = 0;
        for(int i : vals)
            sum += i;
        return sum;
    }

    void getSum(TreeNode* root, int sum){
        if(root == NULL) return;
        sum = sum * 10 + root-&gt;val;
        if(root-&gt;left == NULL &amp;&amp; root-&gt;right == NULL)
            vals.push_back(sum);
        getSum(root-&gt;left , sum);
        getSum(root-&gt;right, sum);
    }
};
</code></pre>
<h1 id="116-Populating-Next-Right-Pointers-in-Each-Node"><a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/" target="_blank" rel="noopener">116. Populating Next Right Pointers in Each Node</a></h1>
<p><a href="Tree-Medium/image-20200505024854849.png" title="image-20200505024854849" class="gallery-item"><img src="image-20200505024854849.png" alt="image-20200505024854849"></a></p>
<h2 id="解法一：层序遍历">解法一：层序遍历</h2>
<p>第一想法应该就是这个了吧</p>
<pre><code class="language-cpp">class Solution {
public:
    Node* connect(Node* root) {
        if(root == NULL) return NULL;
        queue&lt;Node*&gt; q;
        q.push(root);
        while(q.size()){
            int len = q.size();;
            for(int i = 0; i &lt; len; i++) {
                Node* curr = q.front(); q.pop();
                if(i != len - 1) curr-&gt;next = q.front();
                if(curr-&gt;left  != NULL)  q.push(curr-&gt;left);
                if(curr-&gt;right != NULL)  q.push(curr-&gt;right);
            }
        }
        return root;
    }
};
</code></pre>
<h1 id="572-Subtree-of-Another-Tree"><a href="https://leetcode-cn.com/problems/subtree-of-another-tree/" target="_blank" rel="noopener">572. Subtree of Another Tree</a></h1>
<p><a href="Tree-Medium/image-20200507125648455.png" title="image-20200507125648455" class="gallery-item"><img src="image-20200507125648455.png" alt="image-20200507125648455"></a></p>
<p><strong>虽然标的是简单，但是这题多解作为medium不过分</strong></p>
<h2 id="解法一：dfs">解法一：dfs</h2>
<p>最直接的思路，用判同的方法来分别测试s的每个子节点是否和t是相同的，但是显然会有很多重复的搜索</p>
<pre><code class="language-cpp">class Solution {
public:
    bool isSubtree(TreeNode* s, TreeNode* t) {
        if(s == nullptr) return false;
        return isSame(s, t) || isSubtree(s-&gt;left, t) || isSubtree(s-&gt;right, t);
    }
    bool isSame(TreeNode* s, TreeNode* t) {
        if(s == nullptr &amp;&amp; t == nullptr) return true;
        if(s == nullptr || t == nullptr || s-&gt;val != t-&gt;val) return false;
        return isSame(s-&gt;left, t-&gt;left) &amp;&amp; isSame(s-&gt;right, t-&gt;right);
    }
};
</code></pre>
<h1 id="230-Kth-Smallest-Element-in-a-BST"><a href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/" target="_blank" rel="noopener">230. Kth Smallest Element in a BST</a></h1>
<p><a href="Tree-Medium/image-20200507195447964.png" title="image-20200507195447964" class="gallery-item"><img src="image-20200507195447964.png" alt="image-20200507195447964"></a></p>
<h2 id="解法一：先序遍历">解法一：先序遍历</h2>
<p>直接先序遍历出来，取第k个</p>
<pre><code class="language-cpp">class Solution {
public:
    int kthSmallest(TreeNode* root, int k) {
        if(root == NULL) return 0;
        vector&lt;int&gt; inorder = dfs(root, vector&lt;int&gt;());
        return inorder[k - 1];
    }

    vector&lt;int&gt; dfs(TreeNode* root, vector&lt;int&gt; v) {
        if(root == NULL) return v;
        v = dfs(root-&gt;left, v);
        v.push_back(root-&gt;val);
        v = dfs(root-&gt;right, v);
        return v;
    }
};
</code></pre>
<p>**优化版：**遍历到第k个时就可以直接return了</p>
<pre><code class="language-cpp">class Solution {
public:
    int cnt;
    vector&lt;int&gt; inorder; 
    int kthSmallest(TreeNode* root, int k) {
        if(root == NULL) return 0;
        cnt = k;
        dfs(root);
        int len = inorder.size();
        return inorder[len - 1];
    }

    void dfs(TreeNode* root) {
        if(root == NULL) return;
        dfs(root-&gt;left);
        if(inorder.size() &lt; cnt) inorder.push_back(root-&gt;val);
        dfs(root-&gt;right);
    }
};
</code></pre>
<p><strong>迭代法：</strong></p>
<pre><code class="language-cpp">class Solution {
public:
    int kthSmallest(TreeNode* root, int k) {
        stack&lt;TreeNode*&gt; stack;
        TreeNode* curr = root;
        while (curr != NULL || !stack.empty()) {
            while(curr != NULL) {
                stack.push(curr);
                curr = curr-&gt;left;
            }
            curr = stack.top(); stack.pop();
            if(--k == 0) return curr-&gt;val;
            curr = curr-&gt;right;
        }
        return -1;
    }
};
</code></pre>
<h1 id="109-Convert-Sorted-List-to-Binary-Search-Tree"><a href="https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/" target="_blank" rel="noopener">109. Convert Sorted List to Binary Search Tree</a></h1>
<p><a href="Tree-Medium/image-20200509121247264.png" title="image-20200509121247264" class="gallery-item"><img src="image-20200509121247264.png" alt="image-20200509121247264"></a></p>
<h2 id="解法一：直接法">解法一：直接法</h2>
<p>链表查中点和重建BST的组合题</p>
<pre><code class="language-cpp">class Solution {
public:
    TreeNode* sortedListToBST(ListNode* head) {
        if(head == NULL) return NULL;
        if(head-&gt;next == NULL) return new TreeNode(head-&gt;val);
        ListNode* dummy = new ListNode(-1);
        dummy-&gt;next = head;
        ListNode* slow = dummy, * fast = dummy-&gt;next;
        while(fast &amp;&amp; fast-&gt;next) {
            slow = slow-&gt;next;
            fast = fast-&gt;next-&gt;next;
        }
        TreeNode* root = new TreeNode(slow-&gt;next-&gt;val);
        TreeNode* right = sortedListToBST(slow-&gt;next-&gt;next);
        slow-&gt;next = NULL;
        TreeNode* left = sortedListToBST(dummy-&gt;next);
        root-&gt;left = left;
        root-&gt;right = right;
        return root;
    }
};
</code></pre>
<h2 id="解法二：先转数组">解法二：先转数组</h2>
<p>难度还降一级，但是更快一点，因为数组找中点可以直接算出来，注意取中点要向上取整</p>
<pre><code class="language-cpp">class Solution {
public:
    TreeNode* sortedListToBST(ListNode* head) {
        if(head == NULL) return NULL;
        vector&lt;int&gt; list;
        ListNode* curr = head;
        for(curr; curr != NULL; curr = curr-&gt;next)
            list.push_back(curr-&gt;val);
        return arrayListToBST(list, 0, list.size() - 1);
    }

    TreeNode* arrayListToBST(const vector&lt;int&gt;&amp; nums, int i, int j) {
        if(i &gt; j) return NULL;
        if(i == j) return new TreeNode(nums[i]);
        int mid = ceil((i + j) / 2.0);
        TreeNode* root = new TreeNode(nums[mid]), * left, * right;
        left = arrayListToBST(nums, i, mid - 1);
        right = arrayListToBST(nums, mid + 1, j);
        root-&gt;left = left;
        root-&gt;right = right;
        return root;
    }
};
</code></pre>
<p>​</p>
<h1 id="236-二叉树的最近公共祖先"><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/" target="_blank" rel="noopener">236. 二叉树的最近公共祖先</a></h1>
<p><a href="Tree-Medium/image-20200510141728283.png" title="image-20200510141728283" class="gallery-item"><img src="image-20200510141728283.png" alt="image-20200510141728283"></a></p>
<h2 id="解法一：递归法-v8">解法一：递归法</h2>
<ul>
<li>
<p>首先判断两个子节点之间的父子关系，能省掉很多时间1200ms -&gt; 20ms的区别</p>
</li>
<li>
<p>然后递归判断左右子树是否是父节点，如果是则往下走，否则判断根节点是否满足</p>
<ul>
<li>如果满足，则返回根节点</li>
<li>否则返回NULL</li>
</ul>
</li>
</ul>
<pre><code class="language-cpp">class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if(!root || !p || !q) return NULL;
        if(isSubNode(p, q)) return p;
        if(isSubNode(q, p)) return q;
        return checkDeeper(root, p, q);
    }

    TreeNode* checkDeeper(TreeNode* root, TreeNode* p, TreeNode* q) {
        if(!root) return NULL;
        TreeNode* left = checkDeeper(root-&gt;left, p, q);
        TreeNode* right = checkDeeper(root-&gt;right, p, q);
        
        if(isSubNode(root, p) &amp;&amp; isSubNode(root, q)) {
            if(!left &amp;&amp; !right) return root;
            return left == NULL ? right : left;
        }
        return NULL;
    }

    bool isSubNode(TreeNode* s, TreeNode* t) {
        if(!s) return false;
        if(s == t) return true;
        return isSubNode(s-&gt;left, t) || isSubNode(s-&gt;right, t);
    }
};
</code></pre>
<p>**优化版，**减少了一些重复搜索</p>
<pre><code class="language-cpp">class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if(!root) return NULL;
        if(root == p || root == q) return root;
        TreeNode* left = lowestCommonAncestor(root-&gt;left, p, q);
        TreeNode* right = lowestCommonAncestor(root-&gt;right, p, q);
        if(left &amp;&amp; right) return root;
        return left ? left : right;
    }
};
</code></pre>
<h1 id="501-Find-Mode-in-Binary-Search-Tree"><a href="https://leetcode-cn.com/problems/find-mode-in-binary-search-tree/" target="_blank" rel="noopener">501. Find Mode in Binary Search Tree</a></h1>
<p><a href="Tree-Medium/image-20200924062834644.png" title="image-20200924062834644" class="gallery-item"><img src="image-20200924062834644.png" alt="image-20200924062834644"></a></p>
<h2 id="解法一：递归法-v9">解法一：递归法</h2>
<p>本来是很简单的统计问题，但是要求原地解决</p>
<ul>
<li>利用BST的有序特性</li>
<li>问题转换为有序数组求众数的问题</li>
</ul>
<pre><code class="language-cpp">class Solution {
public:
    vector&lt;int&gt; findMode(TreeNode* root) {
        if(!root) return {};
        vector&lt;int&gt; inorder;
        dfs(root, inorder);
        vector&lt;int&gt; res = { inorder[0] };
        int max_cnt = 1, cnt = 1, base = inorder[0];
        for(int i = 1; i &lt; inorder.size(); ++i) {
            if(inorder[i] == base)
                ++cnt;
            else {
                cnt = 1;
                base = inorder[i];
            }
            if(cnt == max_cnt)
                res.push_back(inorder[i]);
            else if (cnt &gt; max_cnt) {
                max_cnt = cnt;
                res = { base };
            }
        }
        return res;
    }

    void dfs(TreeNode* root, vector&lt;int&gt;&amp; inorder) {
        if(!root) return;
        dfs(root-&gt;left, inorder);
        inorder.push_back(root-&gt;val);
        dfs(root-&gt;right, inorder);
    }
};
</code></pre>
<h2 id="解法二：迭代法-v3">解法二：迭代法</h2>
<pre><code class="language-cpp">class Solution {
public:
    int base, count, maxCount;
    vector&lt;int&gt; answer;

    void update(int x) {
        if (x == base) {
            ++count;
        } else {
            count = 1;
            base = x;
        }
        if (count == maxCount) {
            answer.push_back(base);
        }
        if (count &gt; maxCount) {
            maxCount = count;
            answer = vector&lt;int&gt; {base};
        }
    }

    vector&lt;int&gt; findMode(TreeNode* root) {
        TreeNode *cur = root, *pre = nullptr;
        while (cur) {
            if (!cur-&gt;left) {
                update(cur-&gt;val);
                cur = cur-&gt;right;
                continue;
            }
            pre = cur-&gt;left;
            while (pre-&gt;right &amp;&amp; pre-&gt;right != cur) {
                pre = pre-&gt;right;
            }
            if (!pre-&gt;right) {
                pre-&gt;right = cur;
                cur = cur-&gt;left;
            } else {
                pre-&gt;right = nullptr;
                update(cur-&gt;val);
                cur = cur-&gt;right;
            }
        }
        return answer;
    }
};
</code></pre>
</div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {
        var options = {
            selector: '.gallery-item'
        };
        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);
        }</script>
  </div>
  <footer class="article-footer">
    
  <div class="cc">
    <a href="http://creativecommons.org/licenses/by-sa/4.0/deed.z" target="_blank" title="署名-相同方式共享">
      <img src="/overyam/images/cc/cc.png">
      
          <img src="/overyam/images/cc/by.png">
        
          <img src="/overyam/images/cc/sa.png">
      
      <span>
        本作品采用知识共享 署名-相同方式共享 4.0 国际许可协议进行许可。
      </span>
    </a>
  </div>


    

  </footer>

</article>










          <div class="main-footer">
  
    © 2020 Overyam - Powered by <a href="http://hexo.io" target="_blank">Hexo</a> - Theme <a href="https://github.com/denjones/hexo-theme-chan" target="_blank">Chan</a>
  
</div>


      
      <!-- night mode -->
        </div>
        <button class="set-view-mode circular ui medium icon button" href="javascript:void(0)" data-tooltip="Click here to switch night mode" data-position="left center">
          <i class="icon moon outline"></i>
        </button>

        <button class="top ui circular icon button" href="javascript:void(0)" data-tooltip="return to top" data-position="left center">
          
          <i class="icon arrow up"></i>
        </button>

        <div class="cup" >
          <div class="coffee"></div>
        </div>
        <div class="smoke" ></div>
        <a href="#topAnchor"></a>
      
      </div>

    </div>

  </div>
  
  
<link rel="stylesheet" href="/overyam/PhotoSwipe/photoswipe.css">

  
<link rel="stylesheet" href="/overyam/PhotoSwipe/default-skin/default-skin.css">


  <!-- Root element of PhotoSwipe. Must have class pswp. -->
  <div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe.
             It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

      <!-- Container that holds slides.
                PhotoSwipe keeps only 3 of them in the DOM to save memory.
                Don't modify these 3 pswp__item elements, data is added later on. -->
      <div class="pswp__container">
        <div class="pswp__item"></div>
        <div class="pswp__item"></div>
        <div class="pswp__item"></div>
      </div>

      <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
      <div class="pswp__ui pswp__ui--hidden">

        <div class="pswp__top-bar">

          <!--  Controls are self-explanatory. Order can be changed. -->

          <div class="pswp__counter"></div>

          <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

          <button class="pswp__button pswp__button--share" title="Share"></button>

          <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

          <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

          <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
          <!-- element will get class pswp__preloader--active when preloader is running -->
          <div class="pswp__preloader">
            <div class="pswp__preloader__icn">
              <div class="pswp__preloader__cut">
                <div class="pswp__preloader__donut"></div>
              </div>
            </div>
          </div>
        </div>

        <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
          <div class="pswp__share-tooltip"></div>
        </div>

        <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>

        <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button>

        <div class="pswp__caption">
          <div class="pswp__caption__center"></div>
        </div>
      </div>
    </div>
  </div>

  
<script src="/overyam/PhotoSwipe/photoswipe.js"></script>

  
<script src="/overyam/PhotoSwipe/photoswipe-ui-default.js"></script>




<script src="/overyam/perfect-scrollbar/js/min/perfect-scrollbar.min.js"></script>


<script src="/overyam/scripts/main.js"></script>




<script src="/overyam/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginModelPath":"assets/","model":{"scale":0.8,"hHeadPos":0.5,"vHeadPos":0.618,"jsonPath":"/overyam/live2dw/assets/hibiki.model.json"},"display":{"superSample":2,"width":200,"height":400,"position":"right","hOffset":0,"vOffset":-20},"mobile":{"show":true,"scale":0.2},"react":{"opacityDefault":0.7,"opacityOnHover":0.2},"log":false,"pluginJsPath":"lib/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
