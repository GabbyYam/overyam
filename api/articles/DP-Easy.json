{"title":"DP-Easy","slug":"DP-Easy","date":"2020-02-26T15:15:30.000Z","updated":"2020-02-27T03:25:46.192Z","comments":true,"path":"api/articles/DP-Easy.json","excerpt":"Abstract： 更新部分Easy难度 DP相关题解","covers":["image-20200226232711629.png","image-20200226232749188.png","image-20200226232821593.png","image-20200226233021616.png","image-20200226232924335.png"],"content":"<link rel=\"stylesheet\" type=\"text/css\" href=\"https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css\"><div class=\".article-gallery\" <p><strong>Abstract：</strong> 更新部分<code>Easy</code>难度 <code>DP</code>相关题解<p></p>\n<a id=\"more\"></a>\n<h1 id=\"70-Climbing-Stairs\"><a href=\"https://leetcode-cn.com/problems/climbing-stairs/\" target=\"_blank\" rel=\"noopener\">70. Climbing Stairs</a></h1>\n<p><a href=\"DP-Easy/image-20200226232711629.png\" title=\"image-20200226232711629\" class=\"gallery-item\"><img src=\"image-20200226232711629.png\" alt=\"image-20200226232711629\"></a></p>\n<h2 id=\"解法一：DP\">解法一：DP</h2>\n<ul>\n<li><strong>基本情况</strong>：一层楼梯有一种方法，两层楼梯两种方法，因此dp[0]=1,dp[1]=2</li>\n<li><strong>转移方程</strong>：对于大于等于2的层数，dp[n-1]=dp[n-2]+dp[n-3]，即为一般解</li>\n</ul>\n<pre><code class=\"language-java\">class Solution {\n    public int climbStairs(int n) {\n        if(n&lt;=1){return 1;}\n        if(n==2){return 2;}\n        int[] dp=new int[n];\n        dp[0]=1;\n        dp[1]=2;\n        for(int i=2;i&lt;n;i++){dp[i]=dp[i-1]+dp[i-2];}\n        return dp[n-1];\n    }\n}\n</code></pre>\n<h1 id=\"121-Best-Time-to-Buy-and-Sell-Stock\"><a href=\"https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/\" target=\"_blank\" rel=\"noopener\">121. Best Time to Buy and Sell Stock</a></h1>\n<p><a href=\"DP-Easy/image-20200226232749188.png\" title=\"image-20200226232749188\" class=\"gallery-item\"><img src=\"image-20200226232749188.png\" alt=\"image-20200226232749188\"></a></p>\n<h2 id=\"解法一：线性扫描\">解法一：线性扫描</h2>\n<p>线性扫描，考虑到不能只求最大值和最小值，但是记录Index也是无用功</p>\n<p>不妨只更新最小值，那么计算利润的值就必定是在最小值之后，那就只需无脑更新最大利润就行了</p>\n<p>时间复杂度：$ O(N) $</p>\n<pre><code class=\"language-java\">class Solution {\n    public int maxProfit(int[] prices) {\n        int maxProfit=0,minPrice=Integer.MAX_VALUE; //只需要最大利润和最小值\n        for(int i=0;i&lt;prices.length;i++){\n            minPrice=Math.min(prices[i],minPrice); \n            maxProfit=Math.max(maxProfit,prices[i]-minPrice);\n        }\n        return maxProfit;\n    }\n}\n</code></pre>\n<h2 id=\"解法二：DP\">解法二：DP</h2>\n<pre><code class=\"language-java\">//下次写(?)\n</code></pre>\n<h1 id=\"198-House-Robber\"><a href=\"https://leetcode-cn.com/problems/house-robber/\" target=\"_blank\" rel=\"noopener\">198. House Robber</a></h1>\n<p><a href=\"DP-Easy/image-20200226232821593.png\" title=\"image-20200226232821593\" class=\"gallery-item\"><img src=\"image-20200226232821593.png\" alt=\"image-20200226232821593\"></a></p>\n<h2 id=\"解法一：DP-v2\">解法一：DP</h2>\n<ul>\n<li>\n<p><strong>特殊情况</strong>：可抢劫的房子不到三家，即0,1,2</p>\n</li>\n<li>\n<p><strong>基本情况</strong>：第一家的价值是其自身，第二家的价值是第一家和第二家价值的最大值，即</p>\n<pre><code class=\"language-java\">dp[0]=nums[0];\ndp[1]=Math.max(nums[0],nums[1]);\n</code></pre>\n</li>\n<li>\n<p><strong>转移方程</strong>：由基本情况可以推出，第n家的价值</p>\n<pre><code class=\"language-java\">dp[n]=Math.max(\n    dp[n-2]+nums[n],\n\tdp[n-1]\n);\n</code></pre>\n</li>\n<li>\n<p><strong>结果</strong>：不是最后一家就是倒数第二家，取最大值即可</p>\n</li>\n</ul>\n<pre><code class=\"language-java\">class Solution {\n    public int rob(int[] nums) {\n        //三种特殊情况,不考虑会越界\n        if(nums.length==0 || nums==null){return 0;}\n        if(nums.length==1){return nums[0];}\n        if(nums.length==2){return Math.max(nums[0],nums[1]);}\n        int[] dp=new int[nums.length];\n        //两种基本情况\n        dp[0]=nums[0];\n        dp[1]=Math.max(dp[0],nums[1]);\n        //状态转移\n        for(int i=2;i&lt;nums.length;i++){dp[i]=Math.max((dp[i-2]+nums[i]),dp[i-1]);}\n        //最后两家的价值取最大值即可\n        return Math.max(dp[nums.length-1],dp[nums.length-2]);\n    }\n}\n</code></pre>\n<h1 id=\"303-Range-Sum-Query-Immutable\"><a href=\"https://leetcode-cn.com/problems/range-sum-query-immutable/\" target=\"_blank\" rel=\"noopener\">303. Range Sum Query - Immutable</a></h1>\n<p><a href=\"DP-Easy/image-20200226233021616.png\" title=\"image-20200226233021616\" class=\"gallery-item\"><img src=\"image-20200226233021616.png\" alt=\"image-20200226233021616\"></a></p>\n<h2 id=\"解法一：缓存\">解法一：缓存</h2>\n<p>由于会大量调用，所以如果每次都遍历一次来计算会很慢，所以这里需要加入缓存</p>\n<p>nums传入初始化时，就把到n为止的sum计算出来，结果返回两个边界的差值就行了</p>\n<pre><code class=\"language-java\">class NumArray {\n\n    private int[] sum;\n\n    public NumArray(int[] nums) {\n        sum=new int[nums.length+1];\n        for(int i=0;i&lt;nums.length;i++){\n            sum[i+1]=nums[i]+sum[i];\n        }\n    }\n    \n    public int sumRange(int i, int j) {\n        return sum[j+1]-sum[i];\n        //注意这里是j+1 和 i ，因为如果是i+1的话，会把nums[i]也算进去，那得到的和就没有nums[i]了\n    }\n}\n</code></pre>\n<h1 id=\"62-Unique-Paths（Medium？Easy？）\"><a href=\"https://leetcode-cn.com/problems/unique-paths/\" target=\"_blank\" rel=\"noopener\">62. Unique Paths（<mark>Medium？Easy？</mark>）</a></h1>\n<p><a href=\"DP-Easy/image-20200226232924335.png\" title=\"image-20200226232924335\" class=\"gallery-item\"><img src=\"image-20200226232924335.png\" alt=\"image-20200226232924335\"></a></p>\n<h2 id=\"解法一：DP-v3\">解法一：DP</h2>\n<ul>\n<li>\n<p><strong>基本情况</strong>：每个格子对应的解数应为</p>\n</li>\n<li>\n<p><strong>转移方程</strong>：每个格子对应的解数应为 左方格子的解数+上方格子的解数，因此</p>\n<pre><code class=\"language-java\">dp[i][j]=dp[i-1][j]+dp[i][j-1];\n</code></pre>\n</li>\n<li>\n<p><strong>边界问题</strong>：由于边界上的格子上方或左方没有格子，直接计算会导致越界，因此长宽各扩展一格<mark>val=0</mark>的格子来作辅助</p>\n</li>\n</ul>\n<pre><code class=\"language-java\">class Solution {\n    public int uniquePaths(int m, int n) {\n        int[][] dp = new int[m+1][n+1]; //长宽都+1，自动初始化为0作为辅助\n        for(int i=1;i&lt;=m;i++){\n            for(int j=1;j&lt;=n;j++){\n                dp[i][j]=(i==1&amp;&amp;j==1)?1:dp[i-1][j]+dp[i][j-1];\n                //dp[1][1]为1，其他则由其按转移方程推得\n            }\n        }\n        return dp[m][n];//右下角即为结果\n    }\n}\n</code></pre>\n</div><script src=\"https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js\"></script><script>if (typeof lightGallery !== 'undefined') {\n        var options = {\n            selector: '.gallery-item'\n        };\n        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);\n        }</script>","more":"<h1 id=\"70-Climbing-Stairs\"><a href=\"https://leetcode-cn.com/problems/climbing-stairs/\" target=\"_blank\" rel=\"noopener\">70. Climbing Stairs</a></h1>\n<p><a href=\"DP-Easy/image-20200226232711629.png\" title=\"image-20200226232711629\" class=\"gallery-item\"><img src=\"image-20200226232711629.png\" alt=\"image-20200226232711629\"></a></p>\n<h2 id=\"解法一：DP\">解法一：DP</h2>\n<ul>\n<li><strong>基本情况</strong>：一层楼梯有一种方法，两层楼梯两种方法，因此dp[0]=1,dp[1]=2</li>\n<li><strong>转移方程</strong>：对于大于等于2的层数，dp[n-1]=dp[n-2]+dp[n-3]，即为一般解</li>\n</ul>\n<pre><code class=\"language-java\">class Solution {\n    public int climbStairs(int n) {\n        if(n&lt;=1){return 1;}\n        if(n==2){return 2;}\n        int[] dp=new int[n];\n        dp[0]=1;\n        dp[1]=2;\n        for(int i=2;i&lt;n;i++){dp[i]=dp[i-1]+dp[i-2];}\n        return dp[n-1];\n    }\n}\n</code></pre>\n<h1 id=\"121-Best-Time-to-Buy-and-Sell-Stock\"><a href=\"https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/\" target=\"_blank\" rel=\"noopener\">121. Best Time to Buy and Sell Stock</a></h1>\n<p><a href=\"DP-Easy/image-20200226232749188.png\" title=\"image-20200226232749188\" class=\"gallery-item\"><img src=\"image-20200226232749188.png\" alt=\"image-20200226232749188\"></a></p>\n<h2 id=\"解法一：线性扫描\">解法一：线性扫描</h2>\n<p>线性扫描，考虑到不能只求最大值和最小值，但是记录Index也是无用功</p>\n<p>不妨只更新最小值，那么计算利润的值就必定是在最小值之后，那就只需无脑更新最大利润就行了</p>\n<p>时间复杂度：$ O(N) $</p>\n<pre><code class=\"language-java\">class Solution {\n    public int maxProfit(int[] prices) {\n        int maxProfit=0,minPrice=Integer.MAX_VALUE; //只需要最大利润和最小值\n        for(int i=0;i&lt;prices.length;i++){\n            minPrice=Math.min(prices[i],minPrice); \n            maxProfit=Math.max(maxProfit,prices[i]-minPrice);\n        }\n        return maxProfit;\n    }\n}\n</code></pre>\n<h2 id=\"解法二：DP\">解法二：DP</h2>\n<pre><code class=\"language-java\">//下次写(?)\n</code></pre>\n<h1 id=\"198-House-Robber\"><a href=\"https://leetcode-cn.com/problems/house-robber/\" target=\"_blank\" rel=\"noopener\">198. House Robber</a></h1>\n<p><a href=\"DP-Easy/image-20200226232821593.png\" title=\"image-20200226232821593\" class=\"gallery-item\"><img src=\"image-20200226232821593.png\" alt=\"image-20200226232821593\"></a></p>\n<h2 id=\"解法一：DP-v2\">解法一：DP</h2>\n<ul>\n<li>\n<p><strong>特殊情况</strong>：可抢劫的房子不到三家，即0,1,2</p>\n</li>\n<li>\n<p><strong>基本情况</strong>：第一家的价值是其自身，第二家的价值是第一家和第二家价值的最大值，即</p>\n<pre><code class=\"language-java\">dp[0]=nums[0];\ndp[1]=Math.max(nums[0],nums[1]);\n</code></pre>\n</li>\n<li>\n<p><strong>转移方程</strong>：由基本情况可以推出，第n家的价值</p>\n<pre><code class=\"language-java\">dp[n]=Math.max(\n    dp[n-2]+nums[n],\n\tdp[n-1]\n);\n</code></pre>\n</li>\n<li>\n<p><strong>结果</strong>：不是最后一家就是倒数第二家，取最大值即可</p>\n</li>\n</ul>\n<pre><code class=\"language-java\">class Solution {\n    public int rob(int[] nums) {\n        //三种特殊情况,不考虑会越界\n        if(nums.length==0 || nums==null){return 0;}\n        if(nums.length==1){return nums[0];}\n        if(nums.length==2){return Math.max(nums[0],nums[1]);}\n        int[] dp=new int[nums.length];\n        //两种基本情况\n        dp[0]=nums[0];\n        dp[1]=Math.max(dp[0],nums[1]);\n        //状态转移\n        for(int i=2;i&lt;nums.length;i++){dp[i]=Math.max((dp[i-2]+nums[i]),dp[i-1]);}\n        //最后两家的价值取最大值即可\n        return Math.max(dp[nums.length-1],dp[nums.length-2]);\n    }\n}\n</code></pre>\n<h1 id=\"303-Range-Sum-Query-Immutable\"><a href=\"https://leetcode-cn.com/problems/range-sum-query-immutable/\" target=\"_blank\" rel=\"noopener\">303. Range Sum Query - Immutable</a></h1>\n<p><a href=\"DP-Easy/image-20200226233021616.png\" title=\"image-20200226233021616\" class=\"gallery-item\"><img src=\"image-20200226233021616.png\" alt=\"image-20200226233021616\"></a></p>\n<h2 id=\"解法一：缓存\">解法一：缓存</h2>\n<p>由于会大量调用，所以如果每次都遍历一次来计算会很慢，所以这里需要加入缓存</p>\n<p>nums传入初始化时，就把到n为止的sum计算出来，结果返回两个边界的差值就行了</p>\n<pre><code class=\"language-java\">class NumArray {\n\n    private int[] sum;\n\n    public NumArray(int[] nums) {\n        sum=new int[nums.length+1];\n        for(int i=0;i&lt;nums.length;i++){\n            sum[i+1]=nums[i]+sum[i];\n        }\n    }\n    \n    public int sumRange(int i, int j) {\n        return sum[j+1]-sum[i];\n        //注意这里是j+1 和 i ，因为如果是i+1的话，会把nums[i]也算进去，那得到的和就没有nums[i]了\n    }\n}\n</code></pre>\n<h1 id=\"62-Unique-Paths（Medium？Easy？）\"><a href=\"https://leetcode-cn.com/problems/unique-paths/\" target=\"_blank\" rel=\"noopener\">62. Unique Paths（<mark>Medium？Easy？</mark>）</a></h1>\n<p><a href=\"DP-Easy/image-20200226232924335.png\" title=\"image-20200226232924335\" class=\"gallery-item\"><img src=\"image-20200226232924335.png\" alt=\"image-20200226232924335\"></a></p>\n<h2 id=\"解法一：DP-v3\">解法一：DP</h2>\n<ul>\n<li>\n<p><strong>基本情况</strong>：每个格子对应的解数应为</p>\n</li>\n<li>\n<p><strong>转移方程</strong>：每个格子对应的解数应为 左方格子的解数+上方格子的解数，因此</p>\n<pre><code class=\"language-java\">dp[i][j]=dp[i-1][j]+dp[i][j-1];\n</code></pre>\n</li>\n<li>\n<p><strong>边界问题</strong>：由于边界上的格子上方或左方没有格子，直接计算会导致越界，因此长宽各扩展一格<mark>val=0</mark>的格子来作辅助</p>\n</li>\n</ul>\n<pre><code class=\"language-java\">class Solution {\n    public int uniquePaths(int m, int n) {\n        int[][] dp = new int[m+1][n+1]; //长宽都+1，自动初始化为0作为辅助\n        for(int i=1;i&lt;=m;i++){\n            for(int j=1;j&lt;=n;j++){\n                dp[i][j]=(i==1&amp;&amp;j==1)?1:dp[i-1][j]+dp[i][j-1];\n                //dp[1][1]为1，其他则由其按转移方程推得\n            }\n        }\n        return dp[m][n];//右下角即为结果\n    }\n}\n</code></pre>\n<script src=\"https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js\"></script><script>if (typeof lightGallery !== 'undefined') {\n        var options = {\n            selector: '.gallery-item'\n        };\n        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);\n        }</script>","categories":[{"name":"Algorithm","path":"api/categories/Algorithm.json"}],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"}]}