{"title":"PAT-Advanced Vector","slug":"PAT-Advanced-HashTable","date":"2020-04-02T12:05:54.000Z","updated":"2020-04-03T12:47:43.372Z","comments":true,"path":"api/articles/PAT-Advanced-HashTable.json","excerpt":"Abstract：不定长Vector &amp; STL","covers":["image-20200402200838359.png","image-20200401163415171.png"],"content":"<link rel=\"stylesheet\" type=\"text/css\" href=\"https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css\"><div class=\".article-gallery\" <p><strong>Abstract</strong>：不定长Vector &amp; STL<p></p>\n<a id=\"more\"></a>\n<h1 id=\"1039-Course-List-for-Student-25分\"><a href=\"https://pintia.cn/problem-sets/994805342720868352/problems/994805447855292416\" target=\"_blank\" rel=\"noopener\">1039 Course List for Student (25分)</a></h1>\n<p><a href=\"PAT-Advanced-HashTable/image-20200402200838359.png\" title=\"image-20200402200838359\" class=\"gallery-item\"><img src=\"image-20200402200838359.png\" alt=\"image-20200402200838359\"></a></p>\n<h2 id=\"解法一：unordered-map【超时】\">解法一：unordered_map【超时】</h2>\n<p>第一反应hashmap，提交发现居然超时，看了<a href=\"https://www.liuchuo.net/archives/2145\" target=\"_blank\" rel=\"noopener\">柳婼のblog</a>才知道是string cin cout这几个东西速度不行</p>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;unordered_map&gt;\n#include &lt;string&gt;\n\nint c_num, s_num;\nint curr_idx, curr_num;\nstd::string curr_name;\nstd::unordered_map&lt;std::string, std::string&gt; map;\n\nvoid ParseInput() {\n\tstd::cin &gt;&gt; s_num &gt;&gt; c_num;\n\tfor (int i = 0; i &lt; c_num; i++) {\n\t\tstd::cin &gt;&gt; curr_idx &gt;&gt; curr_num;\n\t\tfor (int j = 0; j &lt; curr_num; j++) {\n\t\t\tstd::cin &gt;&gt; curr_name;\n\t\t\tauto key = map.find(curr_name);\n\t\t\tif (key != map.end()) key-&gt;second += &quot; &quot; + std::to_string(curr_idx);\n\t\t\telse map.insert(std::make_pair(curr_name,&quot; &quot; + std::to_string(curr_idx)));\n\t\t}\n\t}\n}\n\nint main() {\n\tParseInput();\n\tfor (int i = 0; i &lt; s_num; i++) {\n\t\tstd::cin &gt;&gt; curr_name;\n\t\tstd::cout &lt;&lt; curr_name;\n\t\tauto key = map.find(curr_name);\n\t\tif (key != map.end())std::cout &lt;&lt; key-&gt;second &lt;&lt; std::endl;\n\t\telse std::cout &lt;&lt; &quot; 0&quot; &lt;&lt; std::endl;\n\t}\t\n}\n</code></pre>\n<h2 id=\"解法二：手动hash-cstdio\">解法二：手动hash + cstdio</h2>\n<p>手动hash对我来说还是比较少见的操作，唯一一次是在Jdk1.8的String源码里看到过类似的东西</p>\n<pre><code class=\"language-cpp\">#include &lt;cstdio&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nint s_num, c_num, curr_idx, curr_num, id = 0;\nchar curr_name[5];\n\nconst int maxn = 26 * 26 * 26 * 10 + 10;\nstd::vector&lt;int&gt; map[maxn];\n\nint hash(char* name) {\n    int id = 0;\n    for (int i = 0; i &lt; 3; i++)\n        id = 26 * id + (name[i] - 'A');\n    id = id * 10 + (name[3] - '0');\n    return id;\n}\n\nvoid ParseInput() {\n    scanf(&quot;%d %d&quot;, &amp;s_num, &amp;c_num);\n\n    for (int i = 0; i &lt; c_num; i++) {\n        scanf(&quot;%d %d&quot;, &amp;curr_idx, &amp;curr_num);\n\n        for (int j = 0; j &lt; curr_num; j++) {\n            scanf(&quot;%s&quot;, curr_name);\n            id = hash(curr_name);\n            map[id].push_back(curr_idx);\n        }\n    }\n}\n\nint main() {\n    ParseInput();\n\n    for (int i = 0; i &lt; s_num; i++) {\n        scanf(&quot;%s&quot;, curr_name);\n\n        id = hash(curr_name);\n        std::sort(map[id].begin(), map[id].end());\n\n        printf(&quot;%s %lu&quot;, curr_name, map[id].size());\n\n        for (int j = 0; j &lt; map[id].size(); j++)\n            printf(&quot; %d&quot;, map[id][j]);\n\n        printf(&quot;\\n&quot;);\n    }\n    return 0;\n}\n</code></pre>\n<h1 id=\"1002-A-B-for-Polynomials-25分\"><a href=\"https://pintia.cn/problem-sets/994805342720868352/problems/994805526272000000\" target=\"_blank\" rel=\"noopener\">1002 A+B for Polynomials (25分)</a></h1>\n<p><a href=\"PAT-Advanced-HashTable/image-20200401163415171.png\" title=\"image-20200401163415171\" class=\"gallery-item\"><img src=\"image-20200401163415171.png\" alt=\"image-20200401163415171\"></a></p>\n<h2 id=\"解法一：unordered-map\">解法一：unordered_map</h2>\n<p>也就是哈希表，剩下的就是将输入解析到map中再遍历输出，但是由于输出顺序原因没法通过的样子…</p>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;unordered_map&gt;\n\nstd::unordered_map&lt;float, float&gt; map;\n\n// Parse input\nvoid ParseInput() {\n\tint num;\n\tfloat coef, exp;\n\tstd::cin &gt;&gt; num;\n\tfor (int i = 0; i &lt; num; i++) {\n\t\tstd::cin &gt;&gt; exp &gt;&gt; coef;\n\t\tauto key = map.find(exp);                   // find exp\n\t\tif (key != map.end()) key-&gt;second += coef;  // Update value\n\t\telse map.insert(std::make_pair(exp, coef)); // If not exist , insert a new node\n\t}\n}\n\nint main() {\n\tParseInput(); // First line\n\tParseInput(); // Second line\n\n\t// Output\n\tstd::cout &lt;&lt; map.size(); \n\tfor (const auto &amp;it : map) {\n\t\tstd::cout &lt;&lt; &quot; &quot; &lt;&lt; it.first &lt;&lt; &quot; &quot; &lt;&lt; it.second;\n\t}\n\treturn 0;\n}\n</code></pre>\n<h2 id=\"解法二：数组模拟哈希表\">解法二：数组模拟哈希表</h2>\n<p>比上面更消耗空间，如果有更多的exp的话是没法这样做的，但这里只有1000个而且这种办法可以逆序遍历</p>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n\nfloat map[1005] = { 0 };\nint size = 0;\n\n// Parse input\nvoid ParseInput() {\n    int num, exp;\n    float coef;\n    std::cin &gt;&gt; num;\n    for (int i = 0; i &lt; num; i++) {\n        std::cin &gt;&gt; exp &gt;&gt; coef;\n        if (map[exp] == 0)size++;       // Count size\n        map[exp] += coef;               // Update value\n        if (map[exp] == 0)size--;       // If coef back to zero , delete it , or you have to transverse the map again\n    }\n}\n\nint main() {\n    ParseInput(); // First line\n    ParseInput(); // Second line\n\n    std::cout &lt;&lt; size;\n\n    for (int i = 1000; i &gt;= 0; i--) {\n        if (map[i] != 0.0)\n            std::cout &lt;&lt; &quot; &quot; &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; std::setiosflags(std::ios::fixed) &lt;&lt; std::setprecision(1) &lt;&lt; map[i]; \n        // fix the format of float\n    }\n    return 0;\n}\n</code></pre>\n<h1 id=\"New-Trick-in-coding\">New Trick in coding</h1>\n<ul>\n<li>\n<p>C++下的精度控制</p>\n<pre><code class=\"language-cpp\">// include others\n#include &lt;iomanip&gt;\n\n// main ...\nstd::cout &lt;&lt; std::setiosflags(std::ios::fixed) &lt;&lt; std::setprecision(1) &lt;&lt; floatNumber;\n</code></pre>\n</li>\n<li>\n<p>Lambda遍历unordered_map</p>\n<pre><code class=\"language-cpp\">for(const auto&amp; it : map){\n    std::cout &lt;&lt; it-&gt;first &lt;&lt; &quot; &quot; &lt;&lt; it-&gt;second &lt;&lt; std::endl;\n}\n</code></pre>\n</li>\n</ul>\n</div><script src=\"https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js\"></script><script>if (typeof lightGallery !== 'undefined') {\n        var options = {\n            selector: '.gallery-item'\n        };\n        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);\n        }</script>","more":"<h1 id=\"1039-Course-List-for-Student-25分\"><a href=\"https://pintia.cn/problem-sets/994805342720868352/problems/994805447855292416\" target=\"_blank\" rel=\"noopener\">1039 Course List for Student (25分)</a></h1>\n<p><a href=\"PAT-Advanced-HashTable/image-20200402200838359.png\" title=\"image-20200402200838359\" class=\"gallery-item\"><img src=\"image-20200402200838359.png\" alt=\"image-20200402200838359\"></a></p>\n<h2 id=\"解法一：unordered-map【超时】\">解法一：unordered_map【超时】</h2>\n<p>第一反应hashmap，提交发现居然超时，看了<a href=\"https://www.liuchuo.net/archives/2145\" target=\"_blank\" rel=\"noopener\">柳婼のblog</a>才知道是string cin cout这几个东西速度不行</p>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;unordered_map&gt;\n#include &lt;string&gt;\n\nint c_num, s_num;\nint curr_idx, curr_num;\nstd::string curr_name;\nstd::unordered_map&lt;std::string, std::string&gt; map;\n\nvoid ParseInput() {\n\tstd::cin &gt;&gt; s_num &gt;&gt; c_num;\n\tfor (int i = 0; i &lt; c_num; i++) {\n\t\tstd::cin &gt;&gt; curr_idx &gt;&gt; curr_num;\n\t\tfor (int j = 0; j &lt; curr_num; j++) {\n\t\t\tstd::cin &gt;&gt; curr_name;\n\t\t\tauto key = map.find(curr_name);\n\t\t\tif (key != map.end()) key-&gt;second += &quot; &quot; + std::to_string(curr_idx);\n\t\t\telse map.insert(std::make_pair(curr_name,&quot; &quot; + std::to_string(curr_idx)));\n\t\t}\n\t}\n}\n\nint main() {\n\tParseInput();\n\tfor (int i = 0; i &lt; s_num; i++) {\n\t\tstd::cin &gt;&gt; curr_name;\n\t\tstd::cout &lt;&lt; curr_name;\n\t\tauto key = map.find(curr_name);\n\t\tif (key != map.end())std::cout &lt;&lt; key-&gt;second &lt;&lt; std::endl;\n\t\telse std::cout &lt;&lt; &quot; 0&quot; &lt;&lt; std::endl;\n\t}\t\n}\n</code></pre>\n<h2 id=\"解法二：手动hash-cstdio\">解法二：手动hash + cstdio</h2>\n<p>手动hash对我来说还是比较少见的操作，唯一一次是在Jdk1.8的String源码里看到过类似的东西</p>\n<pre><code class=\"language-cpp\">#include &lt;cstdio&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nint s_num, c_num, curr_idx, curr_num, id = 0;\nchar curr_name[5];\n\nconst int maxn = 26 * 26 * 26 * 10 + 10;\nstd::vector&lt;int&gt; map[maxn];\n\nint hash(char* name) {\n    int id = 0;\n    for (int i = 0; i &lt; 3; i++)\n        id = 26 * id + (name[i] - 'A');\n    id = id * 10 + (name[3] - '0');\n    return id;\n}\n\nvoid ParseInput() {\n    scanf(&quot;%d %d&quot;, &amp;s_num, &amp;c_num);\n\n    for (int i = 0; i &lt; c_num; i++) {\n        scanf(&quot;%d %d&quot;, &amp;curr_idx, &amp;curr_num);\n\n        for (int j = 0; j &lt; curr_num; j++) {\n            scanf(&quot;%s&quot;, curr_name);\n            id = hash(curr_name);\n            map[id].push_back(curr_idx);\n        }\n    }\n}\n\nint main() {\n    ParseInput();\n\n    for (int i = 0; i &lt; s_num; i++) {\n        scanf(&quot;%s&quot;, curr_name);\n\n        id = hash(curr_name);\n        std::sort(map[id].begin(), map[id].end());\n\n        printf(&quot;%s %lu&quot;, curr_name, map[id].size());\n\n        for (int j = 0; j &lt; map[id].size(); j++)\n            printf(&quot; %d&quot;, map[id][j]);\n\n        printf(&quot;\\n&quot;);\n    }\n    return 0;\n}\n</code></pre>\n<h1 id=\"1002-A-B-for-Polynomials-25分\"><a href=\"https://pintia.cn/problem-sets/994805342720868352/problems/994805526272000000\" target=\"_blank\" rel=\"noopener\">1002 A+B for Polynomials (25分)</a></h1>\n<p><a href=\"PAT-Advanced-HashTable/image-20200401163415171.png\" title=\"image-20200401163415171\" class=\"gallery-item\"><img src=\"image-20200401163415171.png\" alt=\"image-20200401163415171\"></a></p>\n<h2 id=\"解法一：unordered-map\">解法一：unordered_map</h2>\n<p>也就是哈希表，剩下的就是将输入解析到map中再遍历输出，但是由于输出顺序原因没法通过的样子…</p>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;unordered_map&gt;\n\nstd::unordered_map&lt;float, float&gt; map;\n\n// Parse input\nvoid ParseInput() {\n\tint num;\n\tfloat coef, exp;\n\tstd::cin &gt;&gt; num;\n\tfor (int i = 0; i &lt; num; i++) {\n\t\tstd::cin &gt;&gt; exp &gt;&gt; coef;\n\t\tauto key = map.find(exp);                   // find exp\n\t\tif (key != map.end()) key-&gt;second += coef;  // Update value\n\t\telse map.insert(std::make_pair(exp, coef)); // If not exist , insert a new node\n\t}\n}\n\nint main() {\n\tParseInput(); // First line\n\tParseInput(); // Second line\n\n\t// Output\n\tstd::cout &lt;&lt; map.size(); \n\tfor (const auto &amp;it : map) {\n\t\tstd::cout &lt;&lt; &quot; &quot; &lt;&lt; it.first &lt;&lt; &quot; &quot; &lt;&lt; it.second;\n\t}\n\treturn 0;\n}\n</code></pre>\n<h2 id=\"解法二：数组模拟哈希表\">解法二：数组模拟哈希表</h2>\n<p>比上面更消耗空间，如果有更多的exp的话是没法这样做的，但这里只有1000个而且这种办法可以逆序遍历</p>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n\nfloat map[1005] = { 0 };\nint size = 0;\n\n// Parse input\nvoid ParseInput() {\n    int num, exp;\n    float coef;\n    std::cin &gt;&gt; num;\n    for (int i = 0; i &lt; num; i++) {\n        std::cin &gt;&gt; exp &gt;&gt; coef;\n        if (map[exp] == 0)size++;       // Count size\n        map[exp] += coef;               // Update value\n        if (map[exp] == 0)size--;       // If coef back to zero , delete it , or you have to transverse the map again\n    }\n}\n\nint main() {\n    ParseInput(); // First line\n    ParseInput(); // Second line\n\n    std::cout &lt;&lt; size;\n\n    for (int i = 1000; i &gt;= 0; i--) {\n        if (map[i] != 0.0)\n            std::cout &lt;&lt; &quot; &quot; &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; std::setiosflags(std::ios::fixed) &lt;&lt; std::setprecision(1) &lt;&lt; map[i]; \n        // fix the format of float\n    }\n    return 0;\n}\n</code></pre>\n<h1 id=\"New-Trick-in-coding\">New Trick in coding</h1>\n<ul>\n<li>\n<p>C++下的精度控制</p>\n<pre><code class=\"language-cpp\">// include others\n#include &lt;iomanip&gt;\n\n// main ...\nstd::cout &lt;&lt; std::setiosflags(std::ios::fixed) &lt;&lt; std::setprecision(1) &lt;&lt; floatNumber;\n</code></pre>\n</li>\n<li>\n<p>Lambda遍历unordered_map</p>\n<pre><code class=\"language-cpp\">for(const auto&amp; it : map){\n    std::cout &lt;&lt; it-&gt;first &lt;&lt; &quot; &quot; &lt;&lt; it-&gt;second &lt;&lt; std::endl;\n}\n</code></pre>\n</li>\n</ul>\n<script src=\"https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js\"></script><script>if (typeof lightGallery !== 'undefined') {\n        var options = {\n            selector: '.gallery-item'\n        };\n        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);\n        }</script>","categories":[{"name":"Algorithm","path":"api/categories/Algorithm.json"}],"tags":[{"name":"PAT-Advanced","path":"api/tags/PAT-Advanced.json"}]}