{"title":"Greedy-Easy","slug":"Greedy-Easy","date":"2020-02-26T15:16:39.000Z","updated":"2020-02-26T15:41:41.138Z","comments":true,"path":"api/articles/Greedy-Easy.json","excerpt":"Abstract： 更新部分Easy难度 Greedy相关题解","covers":["image-20200226233308396.png","image-20200226233611100.png","image-20200226233902644.png","image-20200226234019301.png","image-20200226234055973.png"],"content":"<p><strong>Abstract：</strong> 更新部分<code>Easy</code>难度 <code>Greedy</code>相关题解</p>\n<a id=\"more\"></a>\n<h1 id=\"122-Best-Time-to-Buy-and-Sell-Stock-II\"><a href=\"https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/\" target=\"_blank\" rel=\"noopener\">122. Best Time to Buy and Sell Stock II</a></h1>\n<p><img src=\"image-20200226233308396.png\" alt=\"image-20200226233308396\"></p>\n<h2 id=\"解法一：贪心\">解法一：贪心</h2>\n<p>显然，如果允许无限次交易的话，那么只要有差价就能赚，因此总利润就是升价之和</p>\n<p class=\"code-caption\" data-lang=\"java\" data-line_number=\"frontend\" data-trim_indent=\"backend\" data-label_position=\"outer\" data-labels_left=\"Code\" data-labels_right=\":\" data-labels_copy=\"Copy Code\"><span class=\"code-caption-label\"></span></p>\n<pre><code class=\"language-java\">class Solution {\n    public int maxProfit(int[] prices) {\n        if(prices.length&lt;=1){return 0;} //特殊情况\n        int profit=0;\n        for(int i=1;i&lt;prices.length;i++){\n            int check=prices[i]-prices[i-1];\n            profit+=check&gt;0?check:0; //只要本次交易有利可得就去赚，必定能使利益最大化\n        }\n        return profit;\n    }\n}\n</code></pre>\n<h1 id=\"455-Assign-Cookies\"><a href=\"https://leetcode-cn.com/problems/assign-cookies/\" target=\"_blank\" rel=\"noopener\">455. Assign Cookies</a></h1>\n<p><img src=\"image-20200226233611100.png\" alt=\"image-20200226233611100\"></p>\n<h2 id=\"解法一：贪心-v2\">解法一：贪心</h2>\n<ul>\n<li><strong>策略</strong>：先排序，用最小的饼干先喂胃口最小的小鬼</li>\n<li><strong>特殊情况</strong>：两者可能为空要注意，但是本题不会有不良影响就是了</li>\n</ul>\n<p class=\"code-caption\" data-lang=\"java\" data-line_number=\"frontend\" data-trim_indent=\"backend\" data-label_position=\"outer\" data-labels_left=\"Code\" data-labels_right=\":\" data-labels_copy=\"Copy Code\"><span class=\"code-caption-label\"></span></p>\n<pre><code class=\"language-java\">class Solution {\n    public int findContentChildren(int[] g, int[] s) {\n        Arrays.sort(g);\n        Arrays.sort(s);//先排序\n        int cookie=0,maxAssign=0;//记录饼干的位置和最大人数\n        for(int i=0;i&lt;g.length;i++){\n            while(cookie&lt;s.length){\n                if(s[cookie]&gt;=g[i]){//如果满足的话，人数++，饼干用掉了所以移动到下一块，cookie++\n                    maxAssign++;\n                    cookie++;\n                    break;//代码中注意不要出现break，影响美观，这里是反面教材了\n                }\n                cookie++;//不满足的话就换下一个饼干\n            }\n        }\n        return maxAssign;\n    }\n}\n</code></pre>\n<ul>\n<li><strong>简洁版</strong>：根本不需要专门记录最大人数，另外改掉<code>break</code>这样的不良习惯，出现<code>break</code>只会让代码丑且丢人</li>\n</ul>\n<p class=\"code-caption\" data-lang=\"java\" data-line_number=\"frontend\" data-trim_indent=\"backend\" data-label_position=\"outer\" data-labels_left=\"Code\" data-labels_right=\":\" data-labels_copy=\"Copy Code\"><span class=\"code-caption-label\"></span></p>\n<pre><code class=\"language-java\">class Solution {\n    public int findContentChildren(int[] g, int[] s) {\n        Arrays.sort(g);\n        Arrays.sort(s);//先排序\n        int cookie=0,greedy=0;//记录饼干的位置、小鬼位置\n        while(cookie&lt;s.length &amp;&amp; greedy&lt;g.length){\n            if(g[greedy]&lt;=s[cookie])greedy++;\n            cookie++;\n        }\n        return greedy;//根本不需要记录最大人数，greedy的最终值就是最大人数\n    }\n}\n</code></pre>\n<h1 id=\"1046-Last-Stone-Weight（TopK问题）\"><a href=\"https://leetcode-cn.com/problems/last-stone-weight/\" target=\"_blank\" rel=\"noopener\">1046. Last Stone Weight（<mark>TopK问题</mark>）</a></h1>\n<p><img src=\"image-20200226233902644.png\" alt=\"image-20200226233902644\"></p>\n<h2 id=\"解法一：排序\">解法一：排序</h2>\n<p>依题意，每次都用最重的两块石头，那么就每轮排一次序就行了</p>\n<p>虽然简洁易懂，但是<mark>缺点是快排空间消耗比较大</mark>，另外数据规模大时额外消耗的时间也比较大</p>\n<p class=\"code-caption\" data-lang=\"java\" data-line_number=\"frontend\" data-trim_indent=\"backend\" data-label_position=\"outer\" data-labels_left=\"Code\" data-labels_right=\":\" data-labels_copy=\"Copy Code\"><span class=\"code-caption-label\"></span></p>\n<pre><code class=\"language-java\">class Solution {\n    public int lastStoneWeight(int[] stones) {\n        if(stones==null || stones.length==0){return 0;} //特殊情况 null或为空\n        int stoneNum=stones.length,len=stones.length;\n        while(stoneNum&gt;1){//每轮都排一次序，直到石头小于一颗\n            Arrays.sort(stones); \n            stones[len-1]=stones[len-1]-stones[len-2];\n            stones[len-2]=0;\n            stoneNum--;\n        }\n        return stones[len-1];//返回最后一颗石子的重量即为答案\n    }\n}\n</code></pre>\n<h2 id=\"解法二：优先队列\">解法二：优先队列</h2>\n<p>由于问题本质是TopK问题，因此用优先队列是相当王道的做法</p>\n<p>小数据下比简单排序略逊，但是数据量增大时优于排序</p>\n<p class=\"code-caption\" data-lang=\"java\" data-line_number=\"frontend\" data-trim_indent=\"backend\" data-label_position=\"outer\" data-labels_left=\"Code\" data-labels_right=\":\" data-labels_copy=\"Copy Code\"><span class=\"code-caption-label\"></span></p>\n<pre><code class=\"language-java\">class Solution {\n    public int lastStoneWeight(int[] stones) {\n        if(stones==null || stones.length==0){return 0;}\n        Queue&lt;Integer&gt; stoneQ=\n            new PriorityQueue&lt;Integer&gt;(Collections.reverseOrder());//优先队列\n        for(int stone:stones){stoneQ.add(stone);}//初始化\n        while(stoneQ.size()&gt;2){//边界处理，如果&gt;1的话可能会让空队列poll\n            int stoneSmashed=stoneQ.poll()-stoneQ.poll();\n            if(stoneSmashed&gt;0)stoneQ.add(stoneSmashed);//如果没彻底smashed，就放回队列中\n        }\n        return stoneQ.size()&gt;1?stoneQ.poll()-stoneQ.poll():stoneQ.peek();\n        //依据情况返回对应结果\n    }\n}\n</code></pre>\n<h1 id=\"860-Lemonade-Change\"><a href=\"https://leetcode-cn.com/problems/lemonade-change/\" target=\"_blank\" rel=\"noopener\">860. Lemonade Change</a></h1>\n<p><img src=\"image-20200226234019301.png\" alt=\"image-20200226234019301\"></p>\n<h2 id=\"解法一：贪心-v3\">解法一：贪心</h2>\n<p>如果是5块和10块没什么可说的，<strong>重点是20块</strong></p>\n<p><strong>如果是20块</strong>，要优先找10块和5块组合，实在不行才用三张5块</p>\n<p class=\"code-caption\" data-lang=\"java\" data-line_number=\"frontend\" data-trim_indent=\"backend\" data-label_position=\"outer\" data-labels_left=\"Code\" data-labels_right=\":\" data-labels_copy=\"Copy Code\"><span class=\"code-caption-label\"></span></p>\n<pre><code class=\"language-java\">class Solution {\n    public boolean lemonadeChange(int[] bills) {\n        int five=0,ten=0;//分别记录5块和10块\n        for(int i=0;i&lt;bills.length;i++){\n            if(bills[i]==5)five++; //5块时直接++\n            \n            else if(bills[i]==10){ //10块时直接找5块，没有就gg\n                if(five&gt;0){ten++;five--;}\n                else return false;\n            }\n            else if(bills[i]==20){ //优先找10块\n                if(ten&gt;0 &amp;&amp; five&gt;0){ten--;five--;}\n                else if(five&gt;=3){five-=3;}\n                else return false;\n            }\n        }\n        return true;\n    }\n}\n</code></pre>\n<h1 id=\"874-Walking-Robot-Simulation\"><a href=\"https://leetcode-cn.com/problems/walking-robot-simulation/\" target=\"_blank\" rel=\"noopener\">874. Walking Robot Simulation</a></h1>\n<p><img src=\"image-20200226234055973.png\" alt=\"image-20200226234055973\"></p>\n<h2 id=\"解法一：HashSet-模拟\">解法一：HashSet+模拟</h2>\n<p><mark>麻烦在写逻辑</mark></p>\n<p class=\"code-caption\" data-lang=\"java\" data-line_number=\"frontend\" data-trim_indent=\"backend\" data-label_position=\"outer\" data-labels_left=\"Code\" data-labels_right=\":\" data-labels_copy=\"Copy Code\"><span class=\"code-caption-label\"></span></p>\n<pre><code class=\"language-java\">class Solution {\n    public int robotSim(int[] commands, int[][] obstacles) {\n        int x=0,y=0,turn=0,maxDistance=0;\n        int[] moves = new int[2];\n\n        //借用官方的编码模式\n        Set&lt;Long&gt; obstacleSet = new HashSet();\n        for (int[] obstacle: obstacles) {\n            long ox = (long) obstacle[0] + 30000;\n            long oy = (long) obstacle[1] + 30000;\n            obstacleSet.add((ox &lt;&lt; 16) + oy);\n        }\n\n        for(int i=0;i&lt;commands.length;i++){\n            if(commands[i] == -1){turn=(turn+1)%4;} //右转90度\n            else if(commands[i] == -2){turn=(turn+3)%4;} //左转90度，注意不要--，因为负数不能%\n            else{ //否则应该是移动\n                for(int k=0;k&lt;commands[i];k++){ //一格一格地走\n                    moves = move(turn,moves); //根据方向和command计算移动的(x,y)\n                    int nx=x+moves[0];\n                    int ny=y+moves[1];\n                    long code = (((long) nx + 30000) &lt;&lt; 16) + ((long) ny + 30000);\n                    if (!obstacleSet.contains(code)) {\n                        x = nx;\n                        y = ny;\n                        maxDistance = Math.max(maxDistance, x*x + y*y);\n                    }\n                }\n            }\n        }\n        return maxDistance;\n    }\n\n    public int[] move(int turn,int[] moves){ //判断移动的x,y\n        if(turn%4 == 0){moves[0]=0;moves[1]=1;return moves;}\n        else if(turn%4 == 1){moves[0]=1;moves[1]=0;return moves;}\n        else if(turn%4 == 2){moves[0]=0;moves[1]=-1;return moves;}\n        else if(turn%4 == 3){moves[0]=-1;moves[1]=0;return moves;}\n        return moves;\n        //throw new IllegalArgumentException;\n    }\n}\n</code></pre>\n","more":"<h1 id=\"122-Best-Time-to-Buy-and-Sell-Stock-II\"><a href=\"https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/\" target=\"_blank\" rel=\"noopener\">122. Best Time to Buy and Sell Stock II</a></h1>\n<p><img src=\"image-20200226233308396.png\" alt=\"image-20200226233308396\"></p>\n<h2 id=\"解法一：贪心\">解法一：贪心</h2>\n<p>显然，如果允许无限次交易的话，那么只要有差价就能赚，因此总利润就是升价之和</p>\n<p class=\"code-caption\" data-lang=\"java\" data-line_number=\"frontend\" data-trim_indent=\"backend\" data-label_position=\"outer\" data-labels_left=\"Code\" data-labels_right=\":\" data-labels_copy=\"Copy Code\"><span class=\"code-caption-label\"></span></p>\n<pre><code class=\"language-java\">class Solution {\n    public int maxProfit(int[] prices) {\n        if(prices.length&lt;=1){return 0;} //特殊情况\n        int profit=0;\n        for(int i=1;i&lt;prices.length;i++){\n            int check=prices[i]-prices[i-1];\n            profit+=check&gt;0?check:0; //只要本次交易有利可得就去赚，必定能使利益最大化\n        }\n        return profit;\n    }\n}\n</code></pre>\n<h1 id=\"455-Assign-Cookies\"><a href=\"https://leetcode-cn.com/problems/assign-cookies/\" target=\"_blank\" rel=\"noopener\">455. Assign Cookies</a></h1>\n<p><img src=\"image-20200226233611100.png\" alt=\"image-20200226233611100\"></p>\n<h2 id=\"解法一：贪心-v2\">解法一：贪心</h2>\n<ul>\n<li><strong>策略</strong>：先排序，用最小的饼干先喂胃口最小的小鬼</li>\n<li><strong>特殊情况</strong>：两者可能为空要注意，但是本题不会有不良影响就是了</li>\n</ul>\n<p class=\"code-caption\" data-lang=\"java\" data-line_number=\"frontend\" data-trim_indent=\"backend\" data-label_position=\"outer\" data-labels_left=\"Code\" data-labels_right=\":\" data-labels_copy=\"Copy Code\"><span class=\"code-caption-label\"></span></p>\n<pre><code class=\"language-java\">class Solution {\n    public int findContentChildren(int[] g, int[] s) {\n        Arrays.sort(g);\n        Arrays.sort(s);//先排序\n        int cookie=0,maxAssign=0;//记录饼干的位置和最大人数\n        for(int i=0;i&lt;g.length;i++){\n            while(cookie&lt;s.length){\n                if(s[cookie]&gt;=g[i]){//如果满足的话，人数++，饼干用掉了所以移动到下一块，cookie++\n                    maxAssign++;\n                    cookie++;\n                    break;//代码中注意不要出现break，影响美观，这里是反面教材了\n                }\n                cookie++;//不满足的话就换下一个饼干\n            }\n        }\n        return maxAssign;\n    }\n}\n</code></pre>\n<ul>\n<li><strong>简洁版</strong>：根本不需要专门记录最大人数，另外改掉<code>break</code>这样的不良习惯，出现<code>break</code>只会让代码丑且丢人</li>\n</ul>\n<p class=\"code-caption\" data-lang=\"java\" data-line_number=\"frontend\" data-trim_indent=\"backend\" data-label_position=\"outer\" data-labels_left=\"Code\" data-labels_right=\":\" data-labels_copy=\"Copy Code\"><span class=\"code-caption-label\"></span></p>\n<pre><code class=\"language-java\">class Solution {\n    public int findContentChildren(int[] g, int[] s) {\n        Arrays.sort(g);\n        Arrays.sort(s);//先排序\n        int cookie=0,greedy=0;//记录饼干的位置、小鬼位置\n        while(cookie&lt;s.length &amp;&amp; greedy&lt;g.length){\n            if(g[greedy]&lt;=s[cookie])greedy++;\n            cookie++;\n        }\n        return greedy;//根本不需要记录最大人数，greedy的最终值就是最大人数\n    }\n}\n</code></pre>\n<h1 id=\"1046-Last-Stone-Weight（TopK问题）\"><a href=\"https://leetcode-cn.com/problems/last-stone-weight/\" target=\"_blank\" rel=\"noopener\">1046. Last Stone Weight（<mark>TopK问题</mark>）</a></h1>\n<p><img src=\"image-20200226233902644.png\" alt=\"image-20200226233902644\"></p>\n<h2 id=\"解法一：排序\">解法一：排序</h2>\n<p>依题意，每次都用最重的两块石头，那么就每轮排一次序就行了</p>\n<p>虽然简洁易懂，但是<mark>缺点是快排空间消耗比较大</mark>，另外数据规模大时额外消耗的时间也比较大</p>\n<p class=\"code-caption\" data-lang=\"java\" data-line_number=\"frontend\" data-trim_indent=\"backend\" data-label_position=\"outer\" data-labels_left=\"Code\" data-labels_right=\":\" data-labels_copy=\"Copy Code\"><span class=\"code-caption-label\"></span></p>\n<pre><code class=\"language-java\">class Solution {\n    public int lastStoneWeight(int[] stones) {\n        if(stones==null || stones.length==0){return 0;} //特殊情况 null或为空\n        int stoneNum=stones.length,len=stones.length;\n        while(stoneNum&gt;1){//每轮都排一次序，直到石头小于一颗\n            Arrays.sort(stones); \n            stones[len-1]=stones[len-1]-stones[len-2];\n            stones[len-2]=0;\n            stoneNum--;\n        }\n        return stones[len-1];//返回最后一颗石子的重量即为答案\n    }\n}\n</code></pre>\n<h2 id=\"解法二：优先队列\">解法二：优先队列</h2>\n<p>由于问题本质是TopK问题，因此用优先队列是相当王道的做法</p>\n<p>小数据下比简单排序略逊，但是数据量增大时优于排序</p>\n<p class=\"code-caption\" data-lang=\"java\" data-line_number=\"frontend\" data-trim_indent=\"backend\" data-label_position=\"outer\" data-labels_left=\"Code\" data-labels_right=\":\" data-labels_copy=\"Copy Code\"><span class=\"code-caption-label\"></span></p>\n<pre><code class=\"language-java\">class Solution {\n    public int lastStoneWeight(int[] stones) {\n        if(stones==null || stones.length==0){return 0;}\n        Queue&lt;Integer&gt; stoneQ=\n            new PriorityQueue&lt;Integer&gt;(Collections.reverseOrder());//优先队列\n        for(int stone:stones){stoneQ.add(stone);}//初始化\n        while(stoneQ.size()&gt;2){//边界处理，如果&gt;1的话可能会让空队列poll\n            int stoneSmashed=stoneQ.poll()-stoneQ.poll();\n            if(stoneSmashed&gt;0)stoneQ.add(stoneSmashed);//如果没彻底smashed，就放回队列中\n        }\n        return stoneQ.size()&gt;1?stoneQ.poll()-stoneQ.poll():stoneQ.peek();\n        //依据情况返回对应结果\n    }\n}\n</code></pre>\n<h1 id=\"860-Lemonade-Change\"><a href=\"https://leetcode-cn.com/problems/lemonade-change/\" target=\"_blank\" rel=\"noopener\">860. Lemonade Change</a></h1>\n<p><img src=\"image-20200226234019301.png\" alt=\"image-20200226234019301\"></p>\n<h2 id=\"解法一：贪心-v3\">解法一：贪心</h2>\n<p>如果是5块和10块没什么可说的，<strong>重点是20块</strong></p>\n<p><strong>如果是20块</strong>，要优先找10块和5块组合，实在不行才用三张5块</p>\n<p class=\"code-caption\" data-lang=\"java\" data-line_number=\"frontend\" data-trim_indent=\"backend\" data-label_position=\"outer\" data-labels_left=\"Code\" data-labels_right=\":\" data-labels_copy=\"Copy Code\"><span class=\"code-caption-label\"></span></p>\n<pre><code class=\"language-java\">class Solution {\n    public boolean lemonadeChange(int[] bills) {\n        int five=0,ten=0;//分别记录5块和10块\n        for(int i=0;i&lt;bills.length;i++){\n            if(bills[i]==5)five++; //5块时直接++\n            \n            else if(bills[i]==10){ //10块时直接找5块，没有就gg\n                if(five&gt;0){ten++;five--;}\n                else return false;\n            }\n            else if(bills[i]==20){ //优先找10块\n                if(ten&gt;0 &amp;&amp; five&gt;0){ten--;five--;}\n                else if(five&gt;=3){five-=3;}\n                else return false;\n            }\n        }\n        return true;\n    }\n}\n</code></pre>\n<h1 id=\"874-Walking-Robot-Simulation\"><a href=\"https://leetcode-cn.com/problems/walking-robot-simulation/\" target=\"_blank\" rel=\"noopener\">874. Walking Robot Simulation</a></h1>\n<p><img src=\"image-20200226234055973.png\" alt=\"image-20200226234055973\"></p>\n<h2 id=\"解法一：HashSet-模拟\">解法一：HashSet+模拟</h2>\n<p><mark>麻烦在写逻辑</mark></p>\n<p class=\"code-caption\" data-lang=\"java\" data-line_number=\"frontend\" data-trim_indent=\"backend\" data-label_position=\"outer\" data-labels_left=\"Code\" data-labels_right=\":\" data-labels_copy=\"Copy Code\"><span class=\"code-caption-label\"></span></p>\n<pre><code class=\"language-java\">class Solution {\n    public int robotSim(int[] commands, int[][] obstacles) {\n        int x=0,y=0,turn=0,maxDistance=0;\n        int[] moves = new int[2];\n\n        //借用官方的编码模式\n        Set&lt;Long&gt; obstacleSet = new HashSet();\n        for (int[] obstacle: obstacles) {\n            long ox = (long) obstacle[0] + 30000;\n            long oy = (long) obstacle[1] + 30000;\n            obstacleSet.add((ox &lt;&lt; 16) + oy);\n        }\n\n        for(int i=0;i&lt;commands.length;i++){\n            if(commands[i] == -1){turn=(turn+1)%4;} //右转90度\n            else if(commands[i] == -2){turn=(turn+3)%4;} //左转90度，注意不要--，因为负数不能%\n            else{ //否则应该是移动\n                for(int k=0;k&lt;commands[i];k++){ //一格一格地走\n                    moves = move(turn,moves); //根据方向和command计算移动的(x,y)\n                    int nx=x+moves[0];\n                    int ny=y+moves[1];\n                    long code = (((long) nx + 30000) &lt;&lt; 16) + ((long) ny + 30000);\n                    if (!obstacleSet.contains(code)) {\n                        x = nx;\n                        y = ny;\n                        maxDistance = Math.max(maxDistance, x*x + y*y);\n                    }\n                }\n            }\n        }\n        return maxDistance;\n    }\n\n    public int[] move(int turn,int[] moves){ //判断移动的x,y\n        if(turn%4 == 0){moves[0]=0;moves[1]=1;return moves;}\n        else if(turn%4 == 1){moves[0]=1;moves[1]=0;return moves;}\n        else if(turn%4 == 2){moves[0]=0;moves[1]=-1;return moves;}\n        else if(turn%4 == 3){moves[0]=-1;moves[1]=0;return moves;}\n        return moves;\n        //throw new IllegalArgumentException;\n    }\n}\n</code></pre>","categories":[{"name":"Algorithm","path":"api/categories/Algorithm.json"}],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"}]}