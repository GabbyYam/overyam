{"title":"PAT-Advanced Array","slug":"Array","date":"2020-04-12T16:13:30.000Z","updated":"2020-04-21T06:48:00.535Z","comments":true,"path":"api/articles/Array.json","excerpt":"","covers":["image-20200413001446891.png","image-20200421144622973.png"],"content":"<link rel=\"stylesheet\" type=\"text/css\" href=\"https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css\"><div class=\".article-gallery\" <a id=\"more\">\n<h1 id=\"1007-Maximum-Subsequence-Sum-25分\"><a href=\"https://pintia.cn/problem-sets/994805342720868352/problems/994805514284679168\" target=\"_blank\" rel=\"noopener\">1007 Maximum Subsequence Sum (25分)</a></h1>\n<p><a href=\"Array/image-20200413001446891.png\" title=\"image-20200413001446891\" class=\"gallery-item\"><img src=\"image-20200413001446891.png\" alt=\"image-20200413001446891\"></a></p>\n<h2 id=\"解法一：线性扫描\">解法一：线性扫描</h2>\n<p>太经典了就不说了</p>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\n#include&lt;vector&gt;\n\nint num, sum, max;\nint start, end, index;\nstd::vector&lt;int&gt; array;\n\nvoid parseInput() {\n\tstd::cin &gt;&gt; num;\n\tarray = std::vector&lt;int&gt;(num);\n\tfor (int i = 0; i &lt; num; i++) std::cin &gt;&gt; array[i];\n}\n\nvoid maxSubSequence() {\n\tsum = 0, max = array[0];\n\tstart = 0, end = 0, index = array[0];\n\tfor (int i = 0; i &lt; num; i++) {\n\t\tsum += array[i];\n\t\tif (sum &lt; 0) {\n\t\t\tsum = 0;\n\t\t\tindex = i+1;\n\t\t}\n\t\telse if (sum &gt; max) {\n\t\t\tmax = sum;\n\t\t\tend = i;\n\t\t\tstart = index;\n\t\t}\n\t}\n}\n\nint main() {\n\tparseInput();\n\tmaxSubSequence();\n\tif (max &lt; 0) \n\t\tstd::cout &lt;&lt; 0 &lt;&lt; &quot; &quot; &lt;&lt; array[0] &lt;&lt; &quot; &quot; &lt;&lt; array[num - 1];\n\telse \n\t\tstd::cout &lt;&lt; max &lt;&lt; &quot; &quot; &lt;&lt; array[start] &lt;&lt; &quot; &quot; &lt;&lt; array[end];\n}\n</code></pre>\n<h2 id=\"解法二：分治法\">解法二：分治法</h2>\n<p>同样经典，但是麻烦一点，实战没必要这样做</p>\n<pre><code class=\"language-cpp\">\n</code></pre>\n<h1 id=\"1009-Product-of-Polynomials-25分\"><a href=\"https://pintia.cn/problem-sets/994805342720868352/problems/994805509540921344\" target=\"_blank\" rel=\"noopener\">1009 Product of Polynomials (25分)</a></h1>\n<p><a href=\"Array/image-20200421144622973.png\" title=\"image-20200421144622973\" class=\"gallery-item\"><img src=\"image-20200421144622973.png\" alt=\"image-20200421144622973\"></a></p>\n<h2 id=\"解法一\">解法一</h2>\n<p>开三个大数组+两重循环 憨憨式解法，但是有用</p>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\n\nint num, expo, cnt = 0;\nfloat coef;\nfloat p1[1001] = { 0 }, p2[1001] = { 0 }, p3[2001] = { 0 };\n\nvoid parseInput() {\n\tstd::cin &gt;&gt; num;\n\tfor (int i = 0; i &lt; num; i++) {\n\t\tstd::cin &gt;&gt; expo &gt;&gt; coef;\n\t\tp1[expo] = coef;\n\t}\n\n\tstd::cin &gt;&gt; num;\n\tfor (int i = 0; i &lt; num; i++) {\n\t\tstd::cin &gt;&gt; expo &gt;&gt; coef;\n\t\tp2[expo] = coef;\n\t}\n\n}\n\nvoid genProduct() {\n\tfor (int i = 0; i &lt; 1001; i++) {\n\t\tfor (int j = 0; j &lt; 1001; j++) {\n\t\t\tif (!p1[i] || !p2[j]) continue;\n\t\t\texpo = i + j;\n\t\t\tcoef = p1[i] * p2[j];\n\t\t\tp3[expo] += coef;\n\t\t}\n\t}\n\tfor (int i = 0; i &lt; 2001; i++)\n\t\tif (p3[i] != 0) cnt++;\n}\n\nint main() {\n\tparseInput();\n\tgenProduct();\n\tstd::cout &lt;&lt; cnt;\n\tfor (int i = 2000; i &gt; -1; i--)\n\t\tif (p3[i]) printf(&quot; %d %.1f&quot;, i, p3[i]);\n}\n</code></pre>\n</div><script src=\"https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js\"></script><script>if (typeof lightGallery !== 'undefined') {\n        var options = {\n            selector: '.gallery-item'\n        };\n        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);\n        }</script>","more":"<h1 id=\"1007-Maximum-Subsequence-Sum-25分\"><a href=\"https://pintia.cn/problem-sets/994805342720868352/problems/994805514284679168\" target=\"_blank\" rel=\"noopener\">1007 Maximum Subsequence Sum (25分)</a></h1>\n<p><a href=\"Array/image-20200413001446891.png\" title=\"image-20200413001446891\" class=\"gallery-item\"><img src=\"image-20200413001446891.png\" alt=\"image-20200413001446891\"></a></p>\n<h2 id=\"解法一：线性扫描\">解法一：线性扫描</h2>\n<p>太经典了就不说了</p>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\n#include&lt;vector&gt;\n\nint num, sum, max;\nint start, end, index;\nstd::vector&lt;int&gt; array;\n\nvoid parseInput() {\n\tstd::cin &gt;&gt; num;\n\tarray = std::vector&lt;int&gt;(num);\n\tfor (int i = 0; i &lt; num; i++) std::cin &gt;&gt; array[i];\n}\n\nvoid maxSubSequence() {\n\tsum = 0, max = array[0];\n\tstart = 0, end = 0, index = array[0];\n\tfor (int i = 0; i &lt; num; i++) {\n\t\tsum += array[i];\n\t\tif (sum &lt; 0) {\n\t\t\tsum = 0;\n\t\t\tindex = i+1;\n\t\t}\n\t\telse if (sum &gt; max) {\n\t\t\tmax = sum;\n\t\t\tend = i;\n\t\t\tstart = index;\n\t\t}\n\t}\n}\n\nint main() {\n\tparseInput();\n\tmaxSubSequence();\n\tif (max &lt; 0) \n\t\tstd::cout &lt;&lt; 0 &lt;&lt; &quot; &quot; &lt;&lt; array[0] &lt;&lt; &quot; &quot; &lt;&lt; array[num - 1];\n\telse \n\t\tstd::cout &lt;&lt; max &lt;&lt; &quot; &quot; &lt;&lt; array[start] &lt;&lt; &quot; &quot; &lt;&lt; array[end];\n}\n</code></pre>\n<h2 id=\"解法二：分治法\">解法二：分治法</h2>\n<p>同样经典，但是麻烦一点，实战没必要这样做</p>\n<pre><code class=\"language-cpp\">\n</code></pre>\n<h1 id=\"1009-Product-of-Polynomials-25分\"><a href=\"https://pintia.cn/problem-sets/994805342720868352/problems/994805509540921344\" target=\"_blank\" rel=\"noopener\">1009 Product of Polynomials (25分)</a></h1>\n<p><a href=\"Array/image-20200421144622973.png\" title=\"image-20200421144622973\" class=\"gallery-item\"><img src=\"image-20200421144622973.png\" alt=\"image-20200421144622973\"></a></p>\n<h2 id=\"解法一\">解法一</h2>\n<p>开三个大数组+两重循环 憨憨式解法，但是有用</p>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\n\nint num, expo, cnt = 0;\nfloat coef;\nfloat p1[1001] = { 0 }, p2[1001] = { 0 }, p3[2001] = { 0 };\n\nvoid parseInput() {\n\tstd::cin &gt;&gt; num;\n\tfor (int i = 0; i &lt; num; i++) {\n\t\tstd::cin &gt;&gt; expo &gt;&gt; coef;\n\t\tp1[expo] = coef;\n\t}\n\n\tstd::cin &gt;&gt; num;\n\tfor (int i = 0; i &lt; num; i++) {\n\t\tstd::cin &gt;&gt; expo &gt;&gt; coef;\n\t\tp2[expo] = coef;\n\t}\n\n}\n\nvoid genProduct() {\n\tfor (int i = 0; i &lt; 1001; i++) {\n\t\tfor (int j = 0; j &lt; 1001; j++) {\n\t\t\tif (!p1[i] || !p2[j]) continue;\n\t\t\texpo = i + j;\n\t\t\tcoef = p1[i] * p2[j];\n\t\t\tp3[expo] += coef;\n\t\t}\n\t}\n\tfor (int i = 0; i &lt; 2001; i++)\n\t\tif (p3[i] != 0) cnt++;\n}\n\nint main() {\n\tparseInput();\n\tgenProduct();\n\tstd::cout &lt;&lt; cnt;\n\tfor (int i = 2000; i &gt; -1; i--)\n\t\tif (p3[i]) printf(&quot; %d %.1f&quot;, i, p3[i]);\n}\n</code></pre>\n<script src=\"https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js\"></script><script>if (typeof lightGallery !== 'undefined') {\n        var options = {\n            selector: '.gallery-item'\n        };\n        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);\n        }</script>","categories":[{"name":"Algorithm","path":"api/categories/Algorithm.json"}],"tags":[{"name":"PAT-A","path":"api/tags/PAT-A.json"}]}