{"title":"String-Medium","slug":"String-Medium","date":"2020-04-25T10:51:27.000Z","updated":"2020-05-03T17:58:46.056Z","comments":true,"path":"api/articles/String-Medium.json","excerpt":"Abstract：leetcode 字符串中等难度合集","covers":["image-20200425185253744.png","image-20200426125725779.png","image-20200426152212362.png","image-20200427235742024.png","image-20200504015642936.png"],"content":"<link rel=\"stylesheet\" type=\"text/css\" href=\"https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css\"><div class=\".article-gallery\" <p><strong>Abstract</strong>：leetcode 字符串中等难度合集<p></p>\n<a id=\"more\"></a>\n<h1 id=\"6-ZigZag-Conversion\"><a href=\"https://leetcode-cn.com/problems/zigzag-conversion/\" target=\"_blank\" rel=\"noopener\">6. ZigZag Conversion</a></h1>\n<p><a href=\"String-Medium/image-20200425185253744.png\" title=\"image-20200425185253744\" class=\"gallery-item\"><img src=\"image-20200425185253744.png\" alt=\"image-20200425185253744\"></a></p>\n<h2 id=\"解法一\">解法一</h2>\n<p>逻辑本质上相当于交替输出123212321这样的字符串，所以没什么可说的。。就是要注意一下numRows 为1时记得直接return，否则idx会越界</p>\n<p>不过官方题解和我写的基本上一样呢 /惊/</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    std::vector&lt;std::string&gt; rows;\n    string convert(string s, int numRows) {\n        if(numRows == 1) return s;\n        rows = std::vector&lt;std::string&gt;(numRows);\n        bool turn = false;\n        for (int i = 0, idx = 0;i&lt;s.length();i++) {\n            rows[idx] += s[i];\n            if (idx == 0 || idx == numRows - 1) turn = !turn;\n            idx += turn ? 1 : -1;\n        }\n\n        std::string ans;\n        for (std::string row : rows) \n            ans += row;\n        return ans;\n    }\n};\n</code></pre>\n<h1 id=\"522-Longest-Uncommon-Subsequence-II\"><a href=\"https://leetcode-cn.com/problems/longest-uncommon-subsequence-ii/\" target=\"_blank\" rel=\"noopener\">522. Longest Uncommon Subsequence II</a></h1>\n<p><a href=\"String-Medium/image-20200426125725779.png\" title=\"image-20200426125725779\" class=\"gallery-item\"><img src=\"image-20200426125725779.png\" alt=\"image-20200426125725779\"></a></p>\n<h2 id=\"解法一：暴力搜索\">解法一：暴力搜索</h2>\n<p>递归搜索每个字符串的所有子序列，放入unordered_map中，如果出现次数为1，进行比较，求出最大值</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n\tint findLUSlength(vector&lt;string&gt;&amp; strs) {\n\t\tunordered_map&lt;string, int&gt; map;\n\t\tfor (string s : strs)\n\t\t\tmapAllSubseq(s, 0, &quot;&quot;, map);\n\n\t\tint max = 0;\n\t\tfor (auto&amp; key : map) {\n\t\t\tif (key.second == 1)\n\t\t\t\tmax = key.first.length() &gt; max ? key.first.length() : max;\n\t\t}\n        return max == 0 ? -1 : max;\n\t}\n\n\tvoid mapAllSubseq(string s, int idx, string res, unordered_map&lt;string, int&gt;&amp; map) {\n\t\tif (idx == s.length()) {\n\t\t\tmap[res]++;\n\t\t\treturn;\n\t\t}\n\t\tmapAllSubseq(s, idx + 1, res, map);          // 放弃第idx位\n\t\tmapAllSubseq(s, idx + 1, res + s[idx], map); // 不放弃第idx位\n\t}\n};\n</code></pre>\n<h2 id=\"解法二：判断子序列\">解法二：判断子序列</h2>\n<ul>\n<li>\n<p>首先，最大长度肯定是某一串的长度</p>\n</li>\n<li>\n<p>注意第二层循环要从0开始，因为在某串之前的串不一定比此串短，也有可能长度相等，否则会把重复串的长度当成解</p>\n</li>\n</ul>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n\tbool isSubseq(string a, string b) {\n        if(a.length() &gt; b.length()) return false;\n\t\tfor (int i = 0, idx = 0; i &lt; b.length(); i++) {\n\t\t\tif (b[i] == a[idx])     idx++;\n\t\t\tif (idx  == a.length()) return true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tint findLUSlength(vector&lt;string&gt;&amp; strs) {\n        int max = 0;\n\t\tfor (int i = 0, j; i &lt; strs.size(); i++) {\n\t\t\tbool flag = true;\n\t\t\tfor (j = 0; j &lt; strs.size(); j++) {\n\t\t\t\tif (i == j)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (isSubseq(strs[i], strs[j])) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (flag &amp;&amp; strs[i].length() &gt; max)\n                max = strs[i].length(); \n\t\t}\n\t\treturn max == 0 ? -1 : max;\n\t}\n};\n</code></pre>\n<h2 id=\"解法三：先排序再判断子序列\">解法三：先排序再判断子序列</h2>\n<p>先排序，那么按照解法二得到的第一个结果就是解，不需要继续遍历求max</p>\n<p>由于排序的消耗比继续判断子序列的消耗要小，因此排序的结果略快一些</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n\tstatic int compare(string a, string b) {\n\t\treturn a.length() &gt; b.length();\n\t}\n\n\tbool isSubseq(string a, string b) {\n\t\tif (a.length() &gt; b.length()) return false;\n\t\tfor (int i = 0, idx = 0; i &lt; b.length(); i++) {\n\t\t\tif (b[i] == a[idx])     idx++;\n\t\t\tif (idx == a.length()) return true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tint findLUSlength(vector&lt;string&gt;&amp; strs) {\n\t\tstd::sort(strs.begin(), strs.end(), compare);\n\t\tfor (int i = 0, j; i &lt; strs.size(); i++) {\n\t\t\tbool flag = true;\n\t\t\tfor (j = 0; j &lt; strs.size(); j++) {\n\t\t\t\tif (i == j)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (isSubseq(strs[i], strs[j])) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (flag)\n\t\t\t\treturn strs[i].length();\n\t\t}\n\t\treturn -1;\n\t}\n};\n</code></pre>\n<h1 id=\"537-Complex-Number-Multiplication\"><a href=\"https://leetcode-cn.com/problems/complex-number-multiplication/\" target=\"_blank\" rel=\"noopener\">537. Complex Number Multiplication</a></h1>\n<p><a href=\"String-Medium/image-20200426152212362.png\" title=\"image-20200426152212362\" class=\"gallery-item\"><img src=\"image-20200426152212362.png\" alt=\"image-20200426152212362\"></a></p>\n<h2 id=\"解法一：std-stoi-std-to-string\">解法一：std::stoi() &amp; std::to_string()</h2>\n<p>一开始以为要用字符串先模拟乘法再模拟加法，但是看大家都直接上库函数，那我也只好恭敬不如从命了</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    string complexNumberMultiply(string a, string b) {\n\tint i = 0, j = 0;\n\tfor (i; a[i] != '+'; i++);\n\tfor (j; b[j] != '+'; j++);\n\tint re_a = std::stoi(a.substr(0, i)),\n\t\tim_a = std::stoi(a.substr(i + 1, a.length() - 1)),\n\t\tre_b = std::stoi(b.substr(0, j)),\n\t\tim_b = std::stoi(b.substr(j + 1, b.length() - 1));\n\tstd::string ans = std::to_string(re_a * re_b - im_a * im_b) + &quot;+&quot; \n\t\t\t\t\t+ std::to_string(re_a * im_b + re_b * im_a)+ &quot;i&quot;;\n    return ans;\n    }\n};\n</code></pre>\n<h1 id=\"43-Multiply-Strings\"><a href=\"https://leetcode-cn.com/problems/multiply-strings/\" target=\"_blank\" rel=\"noopener\">43. Multiply Strings</a></h1>\n<p><a href=\"String-Medium/image-20200427235742024.png\" title=\"image-20200427235742024\" class=\"gallery-item\"><img src=\"image-20200427235742024.png\" alt=\"image-20200427235742024\"></a></p>\n<h2 id=\"解法一：耿直模拟竖式\">解法一：耿直模拟竖式</h2>\n<p>模拟竖式乘法，先模拟一位数乘N位数，再累加</p>\n<p>但是我写的比较烂…正解请看优化版</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n\tstring multiply(string num1, string num2) {\n\t\tstd::string res = &quot;0&quot;;\n\t\tif (num1 == &quot;0&quot; || num2 == &quot;0&quot;) return &quot;0&quot;;\n\t\tfor (int i = num2.length() - 1; i &gt; -1; i--) {\n\t\t\tstd::string val = multi(num1, num2[i]);\n\t\t\tfor (int k = 0; k &lt; num2.length() - i - 1; k++)\n\t\t\t\tval += '0';\n\t\t\tres = add(res, val);\n\t\t}\n\t\treturn res;\n\t}\n\n\tstd::string multi(const std::string&amp; a, char b) {\n\t\tif (b == '0') return &quot;0&quot;;\n\t\tint y = b - '0', carry = 0;\n\t\tstd::string res = &quot;&quot;;\n\t\tfor (int i = a.length() - 1; i &gt; -1; i--) {\n\t\t\tint x = a[i] - '0';\n\t\t\tint val = x * y + carry;\n\t\t\tif (val &gt; 9) {\n\t\t\t\tcarry = val / 10;\n\t\t\t\tval = val % 10;\n\t\t\t}\n\t\t\telse carry = 0;\n\t\t\tres = std::to_string(val) + res;\n\t\t}\n\t\tif (carry &gt; 0) res = std::to_string(carry) + res;\n\t\treturn res;\n\t}\n\n\tstd::string add(const std::string&amp; a, const std::string&amp; b) {\n\t\tint carry = 0, i = a.length() - 1, j = b.length() - 1;\n\t\tstd::string res = &quot;&quot;;\n\t\twhile (i &gt;= 0 || j &gt;= 0) {\n\t\t\tint x = i &gt;= 0 ? a[i--] - '0' : 0;\n\t\t\tint y = j &gt;= 0 ? b[j--] - '0' : 0;\n\t\t\tint sum = x + y + carry;\n\t\t\tif (sum &gt; 9) {\n\t\t\t\tcarry = 1;\n\t\t\t\tsum -= 10;\n\t\t\t}\n\t\t\telse carry = 0;\n\t\t\tres = std::to_string(sum) + res;\n\t\t}\n\t\tif (carry &gt; 0) res = '1' + res;\n\t\treturn res;\n\t}\n};\n</code></pre>\n<h2 id=\"解法二：优化版竖式\">解法二：优化版竖式</h2>\n<h1 id=\"131-Palindrome-Partitioning\"><a href=\"https://leetcode-cn.com/problems/palindrome-partitioning/\" target=\"_blank\" rel=\"noopener\">131. Palindrome Partitioning</a></h1>\n<p><a href=\"String-Medium/image-20200504015642936.png\" title=\"image-20200504015642936\" class=\"gallery-item\"><img src=\"image-20200504015642936.png\" alt=\"image-20200504015642936\"></a></p>\n<h2 id=\"解法一：回溯法\">解法一：回溯法</h2>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    vector&lt;vector&lt;string&gt;&gt; res;\n    vector&lt;string&gt; tmp;\n    vector&lt;vector&lt;string&gt;&gt; partition(string s) {\n        getPartition(s);\n        return res;\n    }\n\n    void getPartition(string s){\n        if(s.empty()) {\n            res.push_back(tmp);\n            return;\n        }\n        for(int i = 0; i &lt; s.length(); i++){\n            string sub = s.substr(0, i + 1);\n            if(isPalindrome(sub)){\n                tmp.push_back(sub);\n                getPartition(s.substr(i + 1, s.length()));\n                tmp.pop_back();\n            }\n        }\n    }\n\n    bool isPalindrome(const string&amp; s){\n        if(s.empty()) return false;\n        int lo = 0, hi = s.length() - 1;\n        while(lo &lt;= hi)\n            if(s[lo++] != s[hi--]) \n                return false;\n        return true;\n    }\n};\n</code></pre>\n<h2 id=\"解法二：优化版\">解法二：优化版</h2>\n</div><script src=\"https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js\"></script><script>if (typeof lightGallery !== 'undefined') {\n        var options = {\n            selector: '.gallery-item'\n        };\n        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);\n        }</script>","more":"<h1 id=\"6-ZigZag-Conversion\"><a href=\"https://leetcode-cn.com/problems/zigzag-conversion/\" target=\"_blank\" rel=\"noopener\">6. ZigZag Conversion</a></h1>\n<p><a href=\"String-Medium/image-20200425185253744.png\" title=\"image-20200425185253744\" class=\"gallery-item\"><img src=\"image-20200425185253744.png\" alt=\"image-20200425185253744\"></a></p>\n<h2 id=\"解法一\">解法一</h2>\n<p>逻辑本质上相当于交替输出123212321这样的字符串，所以没什么可说的。。就是要注意一下numRows 为1时记得直接return，否则idx会越界</p>\n<p>不过官方题解和我写的基本上一样呢 /惊/</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    std::vector&lt;std::string&gt; rows;\n    string convert(string s, int numRows) {\n        if(numRows == 1) return s;\n        rows = std::vector&lt;std::string&gt;(numRows);\n        bool turn = false;\n        for (int i = 0, idx = 0;i&lt;s.length();i++) {\n            rows[idx] += s[i];\n            if (idx == 0 || idx == numRows - 1) turn = !turn;\n            idx += turn ? 1 : -1;\n        }\n\n        std::string ans;\n        for (std::string row : rows) \n            ans += row;\n        return ans;\n    }\n};\n</code></pre>\n<h1 id=\"522-Longest-Uncommon-Subsequence-II\"><a href=\"https://leetcode-cn.com/problems/longest-uncommon-subsequence-ii/\" target=\"_blank\" rel=\"noopener\">522. Longest Uncommon Subsequence II</a></h1>\n<p><a href=\"String-Medium/image-20200426125725779.png\" title=\"image-20200426125725779\" class=\"gallery-item\"><img src=\"image-20200426125725779.png\" alt=\"image-20200426125725779\"></a></p>\n<h2 id=\"解法一：暴力搜索\">解法一：暴力搜索</h2>\n<p>递归搜索每个字符串的所有子序列，放入unordered_map中，如果出现次数为1，进行比较，求出最大值</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n\tint findLUSlength(vector&lt;string&gt;&amp; strs) {\n\t\tunordered_map&lt;string, int&gt; map;\n\t\tfor (string s : strs)\n\t\t\tmapAllSubseq(s, 0, &quot;&quot;, map);\n\n\t\tint max = 0;\n\t\tfor (auto&amp; key : map) {\n\t\t\tif (key.second == 1)\n\t\t\t\tmax = key.first.length() &gt; max ? key.first.length() : max;\n\t\t}\n        return max == 0 ? -1 : max;\n\t}\n\n\tvoid mapAllSubseq(string s, int idx, string res, unordered_map&lt;string, int&gt;&amp; map) {\n\t\tif (idx == s.length()) {\n\t\t\tmap[res]++;\n\t\t\treturn;\n\t\t}\n\t\tmapAllSubseq(s, idx + 1, res, map);          // 放弃第idx位\n\t\tmapAllSubseq(s, idx + 1, res + s[idx], map); // 不放弃第idx位\n\t}\n};\n</code></pre>\n<h2 id=\"解法二：判断子序列\">解法二：判断子序列</h2>\n<ul>\n<li>\n<p>首先，最大长度肯定是某一串的长度</p>\n</li>\n<li>\n<p>注意第二层循环要从0开始，因为在某串之前的串不一定比此串短，也有可能长度相等，否则会把重复串的长度当成解</p>\n</li>\n</ul>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n\tbool isSubseq(string a, string b) {\n        if(a.length() &gt; b.length()) return false;\n\t\tfor (int i = 0, idx = 0; i &lt; b.length(); i++) {\n\t\t\tif (b[i] == a[idx])     idx++;\n\t\t\tif (idx  == a.length()) return true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tint findLUSlength(vector&lt;string&gt;&amp; strs) {\n        int max = 0;\n\t\tfor (int i = 0, j; i &lt; strs.size(); i++) {\n\t\t\tbool flag = true;\n\t\t\tfor (j = 0; j &lt; strs.size(); j++) {\n\t\t\t\tif (i == j)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (isSubseq(strs[i], strs[j])) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (flag &amp;&amp; strs[i].length() &gt; max)\n                max = strs[i].length(); \n\t\t}\n\t\treturn max == 0 ? -1 : max;\n\t}\n};\n</code></pre>\n<h2 id=\"解法三：先排序再判断子序列\">解法三：先排序再判断子序列</h2>\n<p>先排序，那么按照解法二得到的第一个结果就是解，不需要继续遍历求max</p>\n<p>由于排序的消耗比继续判断子序列的消耗要小，因此排序的结果略快一些</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n\tstatic int compare(string a, string b) {\n\t\treturn a.length() &gt; b.length();\n\t}\n\n\tbool isSubseq(string a, string b) {\n\t\tif (a.length() &gt; b.length()) return false;\n\t\tfor (int i = 0, idx = 0; i &lt; b.length(); i++) {\n\t\t\tif (b[i] == a[idx])     idx++;\n\t\t\tif (idx == a.length()) return true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tint findLUSlength(vector&lt;string&gt;&amp; strs) {\n\t\tstd::sort(strs.begin(), strs.end(), compare);\n\t\tfor (int i = 0, j; i &lt; strs.size(); i++) {\n\t\t\tbool flag = true;\n\t\t\tfor (j = 0; j &lt; strs.size(); j++) {\n\t\t\t\tif (i == j)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (isSubseq(strs[i], strs[j])) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (flag)\n\t\t\t\treturn strs[i].length();\n\t\t}\n\t\treturn -1;\n\t}\n};\n</code></pre>\n<h1 id=\"537-Complex-Number-Multiplication\"><a href=\"https://leetcode-cn.com/problems/complex-number-multiplication/\" target=\"_blank\" rel=\"noopener\">537. Complex Number Multiplication</a></h1>\n<p><a href=\"String-Medium/image-20200426152212362.png\" title=\"image-20200426152212362\" class=\"gallery-item\"><img src=\"image-20200426152212362.png\" alt=\"image-20200426152212362\"></a></p>\n<h2 id=\"解法一：std-stoi-std-to-string\">解法一：std::stoi() &amp; std::to_string()</h2>\n<p>一开始以为要用字符串先模拟乘法再模拟加法，但是看大家都直接上库函数，那我也只好恭敬不如从命了</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    string complexNumberMultiply(string a, string b) {\n\tint i = 0, j = 0;\n\tfor (i; a[i] != '+'; i++);\n\tfor (j; b[j] != '+'; j++);\n\tint re_a = std::stoi(a.substr(0, i)),\n\t\tim_a = std::stoi(a.substr(i + 1, a.length() - 1)),\n\t\tre_b = std::stoi(b.substr(0, j)),\n\t\tim_b = std::stoi(b.substr(j + 1, b.length() - 1));\n\tstd::string ans = std::to_string(re_a * re_b - im_a * im_b) + &quot;+&quot; \n\t\t\t\t\t+ std::to_string(re_a * im_b + re_b * im_a)+ &quot;i&quot;;\n    return ans;\n    }\n};\n</code></pre>\n<h1 id=\"43-Multiply-Strings\"><a href=\"https://leetcode-cn.com/problems/multiply-strings/\" target=\"_blank\" rel=\"noopener\">43. Multiply Strings</a></h1>\n<p><a href=\"String-Medium/image-20200427235742024.png\" title=\"image-20200427235742024\" class=\"gallery-item\"><img src=\"image-20200427235742024.png\" alt=\"image-20200427235742024\"></a></p>\n<h2 id=\"解法一：耿直模拟竖式\">解法一：耿直模拟竖式</h2>\n<p>模拟竖式乘法，先模拟一位数乘N位数，再累加</p>\n<p>但是我写的比较烂…正解请看优化版</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n\tstring multiply(string num1, string num2) {\n\t\tstd::string res = &quot;0&quot;;\n\t\tif (num1 == &quot;0&quot; || num2 == &quot;0&quot;) return &quot;0&quot;;\n\t\tfor (int i = num2.length() - 1; i &gt; -1; i--) {\n\t\t\tstd::string val = multi(num1, num2[i]);\n\t\t\tfor (int k = 0; k &lt; num2.length() - i - 1; k++)\n\t\t\t\tval += '0';\n\t\t\tres = add(res, val);\n\t\t}\n\t\treturn res;\n\t}\n\n\tstd::string multi(const std::string&amp; a, char b) {\n\t\tif (b == '0') return &quot;0&quot;;\n\t\tint y = b - '0', carry = 0;\n\t\tstd::string res = &quot;&quot;;\n\t\tfor (int i = a.length() - 1; i &gt; -1; i--) {\n\t\t\tint x = a[i] - '0';\n\t\t\tint val = x * y + carry;\n\t\t\tif (val &gt; 9) {\n\t\t\t\tcarry = val / 10;\n\t\t\t\tval = val % 10;\n\t\t\t}\n\t\t\telse carry = 0;\n\t\t\tres = std::to_string(val) + res;\n\t\t}\n\t\tif (carry &gt; 0) res = std::to_string(carry) + res;\n\t\treturn res;\n\t}\n\n\tstd::string add(const std::string&amp; a, const std::string&amp; b) {\n\t\tint carry = 0, i = a.length() - 1, j = b.length() - 1;\n\t\tstd::string res = &quot;&quot;;\n\t\twhile (i &gt;= 0 || j &gt;= 0) {\n\t\t\tint x = i &gt;= 0 ? a[i--] - '0' : 0;\n\t\t\tint y = j &gt;= 0 ? b[j--] - '0' : 0;\n\t\t\tint sum = x + y + carry;\n\t\t\tif (sum &gt; 9) {\n\t\t\t\tcarry = 1;\n\t\t\t\tsum -= 10;\n\t\t\t}\n\t\t\telse carry = 0;\n\t\t\tres = std::to_string(sum) + res;\n\t\t}\n\t\tif (carry &gt; 0) res = '1' + res;\n\t\treturn res;\n\t}\n};\n</code></pre>\n<h2 id=\"解法二：优化版竖式\">解法二：优化版竖式</h2>\n<h1 id=\"131-Palindrome-Partitioning\"><a href=\"https://leetcode-cn.com/problems/palindrome-partitioning/\" target=\"_blank\" rel=\"noopener\">131. Palindrome Partitioning</a></h1>\n<p><a href=\"String-Medium/image-20200504015642936.png\" title=\"image-20200504015642936\" class=\"gallery-item\"><img src=\"image-20200504015642936.png\" alt=\"image-20200504015642936\"></a></p>\n<h2 id=\"解法一：回溯法\">解法一：回溯法</h2>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    vector&lt;vector&lt;string&gt;&gt; res;\n    vector&lt;string&gt; tmp;\n    vector&lt;vector&lt;string&gt;&gt; partition(string s) {\n        getPartition(s);\n        return res;\n    }\n\n    void getPartition(string s){\n        if(s.empty()) {\n            res.push_back(tmp);\n            return;\n        }\n        for(int i = 0; i &lt; s.length(); i++){\n            string sub = s.substr(0, i + 1);\n            if(isPalindrome(sub)){\n                tmp.push_back(sub);\n                getPartition(s.substr(i + 1, s.length()));\n                tmp.pop_back();\n            }\n        }\n    }\n\n    bool isPalindrome(const string&amp; s){\n        if(s.empty()) return false;\n        int lo = 0, hi = s.length() - 1;\n        while(lo &lt;= hi)\n            if(s[lo++] != s[hi--]) \n                return false;\n        return true;\n    }\n};\n</code></pre>\n<h2 id=\"解法二：优化版\">解法二：优化版</h2>\n<script src=\"https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js\"></script><script>if (typeof lightGallery !== 'undefined') {\n        var options = {\n            selector: '.gallery-item'\n        };\n        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);\n        }</script>","categories":[{"name":"Algorithm","path":"api/categories/Algorithm.json"}],"tags":[{"name":"Leetcode","path":"api/tags/Leetcode.json"}]}