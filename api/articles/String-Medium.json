{"title":"String-Medium","slug":"String-Medium","date":"2020-04-25T10:51:27.000Z","updated":"2020-05-20T07:00:05.905Z","comments":true,"path":"api/articles/String-Medium.json","excerpt":"Abstract：leetcode 字符串中等难度合集","covers":["image-20200425185253744.png","image-20200426125725779.png","image-20200426152212362.png","image-20200427235742024.png","image-20200504015642936.png","image-20200506134117681.png","image-20200506144355883.png","image-20200509024036177.png","image-20200510174413303.png","image-20200512145627513.png","image-20200515192458782.png","image-20200519134014730.png","image-20200520131929011.png"],"content":"<link rel=\"stylesheet\" type=\"text/css\" href=\"https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css\"><div class=\".article-gallery\" <p><strong>Abstract</strong>：leetcode 字符串中等难度合集<p></p>\n<a id=\"more\"></a>\n<h1 id=\"6-ZigZag-Conversion\"><a href=\"https://leetcode-cn.com/problems/zigzag-conversion/\" target=\"_blank\" rel=\"noopener\">6. ZigZag Conversion</a></h1>\n<p><a href=\"String-Medium/image-20200425185253744.png\" title=\"image-20200425185253744\" class=\"gallery-item\"><img src=\"image-20200425185253744.png\" alt=\"image-20200425185253744\"></a></p>\n<h2 id=\"解法一\">解法一</h2>\n<p>逻辑本质上相当于交替输出123212321这样的字符串，所以没什么可说的。。就是要注意一下numRows 为1时记得直接return，否则idx会越界</p>\n<p>不过官方题解和我写的基本上一样呢 /惊/</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    std::vector&lt;std::string&gt; rows;\n    string convert(string s, int numRows) {\n        if(numRows == 1) return s;\n        rows = std::vector&lt;std::string&gt;(numRows);\n        bool turn = false;\n        for (int i = 0, idx = 0;i&lt;s.length();i++) {\n            rows[idx] += s[i];\n            if (idx == 0 || idx == numRows - 1) turn = !turn;\n            idx += turn ? 1 : -1;\n        }\n\n        std::string ans;\n        for (std::string row : rows) \n            ans += row;\n        return ans;\n    }\n};\n</code></pre>\n<h1 id=\"522-Longest-Uncommon-Subsequence-II\"><a href=\"https://leetcode-cn.com/problems/longest-uncommon-subsequence-ii/\" target=\"_blank\" rel=\"noopener\">522. Longest Uncommon Subsequence II</a></h1>\n<p><a href=\"String-Medium/image-20200426125725779.png\" title=\"image-20200426125725779\" class=\"gallery-item\"><img src=\"image-20200426125725779.png\" alt=\"image-20200426125725779\"></a></p>\n<h2 id=\"解法一：暴力搜索\">解法一：暴力搜索</h2>\n<p>递归搜索每个字符串的所有子序列，放入unordered_map中，如果出现次数为1，进行比较，求出最大值</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n\tint findLUSlength(vector&lt;string&gt;&amp; strs) {\n\t\tunordered_map&lt;string, int&gt; map;\n\t\tfor (string s : strs)\n\t\t\tmapAllSubseq(s, 0, &quot;&quot;, map);\n\n\t\tint max = 0;\n\t\tfor (auto&amp; key : map) {\n\t\t\tif (key.second == 1)\n\t\t\t\tmax = key.first.length() &gt; max ? key.first.length() : max;\n\t\t}\n        return max == 0 ? -1 : max;\n\t}\n\n\tvoid mapAllSubseq(string s, int idx, string res, unordered_map&lt;string, int&gt;&amp; map) {\n\t\tif (idx == s.length()) {\n\t\t\tmap[res]++;\n\t\t\treturn;\n\t\t}\n\t\tmapAllSubseq(s, idx + 1, res, map);          // 放弃第idx位\n\t\tmapAllSubseq(s, idx + 1, res + s[idx], map); // 不放弃第idx位\n\t}\n};\n</code></pre>\n<h2 id=\"解法二：判断子序列\">解法二：判断子序列</h2>\n<ul>\n<li>\n<p>首先，最大长度肯定是某一串的长度</p>\n</li>\n<li>\n<p>注意第二层循环要从0开始，因为在某串之前的串不一定比此串短，也有可能长度相等，否则会把重复串的长度当成解</p>\n</li>\n</ul>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n\tbool isSubseq(string a, string b) {\n        if(a.length() &gt; b.length()) return false;\n\t\tfor (int i = 0, idx = 0; i &lt; b.length(); i++) {\n\t\t\tif (b[i] == a[idx])     idx++;\n\t\t\tif (idx  == a.length()) return true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tint findLUSlength(vector&lt;string&gt;&amp; strs) {\n        int max = 0;\n\t\tfor (int i = 0, j; i &lt; strs.size(); i++) {\n\t\t\tbool flag = true;\n\t\t\tfor (j = 0; j &lt; strs.size(); j++) {\n\t\t\t\tif (i == j)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (isSubseq(strs[i], strs[j])) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (flag &amp;&amp; strs[i].length() &gt; max)\n                max = strs[i].length(); \n\t\t}\n\t\treturn max == 0 ? -1 : max;\n\t}\n};\n</code></pre>\n<h2 id=\"解法三：先排序再判断子序列\">解法三：先排序再判断子序列</h2>\n<p>先排序，那么按照解法二得到的第一个结果就是解，不需要继续遍历求max</p>\n<p>由于排序的消耗比继续判断子序列的消耗要小，因此排序的结果略快一些</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n\tstatic int compare(string a, string b) {\n\t\treturn a.length() &gt; b.length();\n\t}\n\n\tbool isSubseq(string a, string b) {\n\t\tif (a.length() &gt; b.length()) return false;\n\t\tfor (int i = 0, idx = 0; i &lt; b.length(); i++) {\n\t\t\tif (b[i] == a[idx])     idx++;\n\t\t\tif (idx == a.length()) return true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tint findLUSlength(vector&lt;string&gt;&amp; strs) {\n\t\tstd::sort(strs.begin(), strs.end(), compare);\n\t\tfor (int i = 0, j; i &lt; strs.size(); i++) {\n\t\t\tbool flag = true;\n\t\t\tfor (j = 0; j &lt; strs.size(); j++) {\n\t\t\t\tif (i == j)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (isSubseq(strs[i], strs[j])) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (flag)\n\t\t\t\treturn strs[i].length();\n\t\t}\n\t\treturn -1;\n\t}\n};\n</code></pre>\n<h1 id=\"537-Complex-Number-Multiplication\"><a href=\"https://leetcode-cn.com/problems/complex-number-multiplication/\" target=\"_blank\" rel=\"noopener\">537. Complex Number Multiplication</a></h1>\n<p><a href=\"String-Medium/image-20200426152212362.png\" title=\"image-20200426152212362\" class=\"gallery-item\"><img src=\"image-20200426152212362.png\" alt=\"image-20200426152212362\"></a></p>\n<h2 id=\"解法一：std-stoi-std-to-string\">解法一：std::stoi() &amp; std::to_string()</h2>\n<p>一开始以为要用字符串先模拟乘法再模拟加法，但是看大家都直接上库函数，那我也只好恭敬不如从命了</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    string complexNumberMultiply(string a, string b) {\n\tint i = 0, j = 0;\n\tfor (i; a[i] != '+'; i++);\n\tfor (j; b[j] != '+'; j++);\n\tint re_a = std::stoi(a.substr(0, i)),\n\t\tim_a = std::stoi(a.substr(i + 1, a.length() - 1)),\n\t\tre_b = std::stoi(b.substr(0, j)),\n\t\tim_b = std::stoi(b.substr(j + 1, b.length() - 1));\n\tstd::string ans = std::to_string(re_a * re_b - im_a * im_b) + &quot;+&quot; \n\t\t\t\t\t+ std::to_string(re_a * im_b + re_b * im_a)+ &quot;i&quot;;\n    return ans;\n    }\n};\n</code></pre>\n<h1 id=\"43-Multiply-Strings\"><a href=\"https://leetcode-cn.com/problems/multiply-strings/\" target=\"_blank\" rel=\"noopener\">43. Multiply Strings</a></h1>\n<p><a href=\"String-Medium/image-20200427235742024.png\" title=\"image-20200427235742024\" class=\"gallery-item\"><img src=\"image-20200427235742024.png\" alt=\"image-20200427235742024\"></a></p>\n<h2 id=\"解法一：耿直模拟竖式\">解法一：耿直模拟竖式</h2>\n<p>模拟竖式乘法，先模拟一位数乘N位数，再累加</p>\n<p>但是我写的比较烂…正解请看优化版</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n\tstring multiply(string num1, string num2) {\n\t\tstd::string res = &quot;0&quot;;\n\t\tif (num1 == &quot;0&quot; || num2 == &quot;0&quot;) return &quot;0&quot;;\n\t\tfor (int i = num2.length() - 1; i &gt; -1; i--) {\n\t\t\tstd::string val = multi(num1, num2[i]);\n\t\t\tfor (int k = 0; k &lt; num2.length() - i - 1; k++)\n\t\t\t\tval += '0';\n\t\t\tres = add(res, val);\n\t\t}\n\t\treturn res;\n\t}\n\n\tstd::string multi(const std::string&amp; a, char b) {\n\t\tif (b == '0') return &quot;0&quot;;\n\t\tint y = b - '0', carry = 0;\n\t\tstd::string res = &quot;&quot;;\n\t\tfor (int i = a.length() - 1; i &gt; -1; i--) {\n\t\t\tint x = a[i] - '0';\n\t\t\tint val = x * y + carry;\n\t\t\tif (val &gt; 9) {\n\t\t\t\tcarry = val / 10;\n\t\t\t\tval = val % 10;\n\t\t\t}\n\t\t\telse carry = 0;\n\t\t\tres = std::to_string(val) + res;\n\t\t}\n\t\tif (carry &gt; 0) res = std::to_string(carry) + res;\n\t\treturn res;\n\t}\n\n\tstd::string add(const std::string&amp; a, const std::string&amp; b) {\n\t\tint carry = 0, i = a.length() - 1, j = b.length() - 1;\n\t\tstd::string res = &quot;&quot;;\n\t\twhile (i &gt;= 0 || j &gt;= 0) {\n\t\t\tint x = i &gt;= 0 ? a[i--] - '0' : 0;\n\t\t\tint y = j &gt;= 0 ? b[j--] - '0' : 0;\n\t\t\tint sum = x + y + carry;\n\t\t\tif (sum &gt; 9) {\n\t\t\t\tcarry = 1;\n\t\t\t\tsum -= 10;\n\t\t\t}\n\t\t\telse carry = 0;\n\t\t\tres = std::to_string(sum) + res;\n\t\t}\n\t\tif (carry &gt; 0) res = '1' + res;\n\t\treturn res;\n\t}\n};\n</code></pre>\n<h2 id=\"解法二：优化版竖式\">解法二：优化版竖式</h2>\n<h1 id=\"131-Palindrome-Partitioning\"><a href=\"https://leetcode-cn.com/problems/palindrome-partitioning/\" target=\"_blank\" rel=\"noopener\">131. Palindrome Partitioning</a></h1>\n<p><a href=\"String-Medium/image-20200504015642936.png\" title=\"image-20200504015642936\" class=\"gallery-item\"><img src=\"image-20200504015642936.png\" alt=\"image-20200504015642936\"></a></p>\n<h2 id=\"解法一：回溯法\">解法一：回溯法</h2>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    vector&lt;vector&lt;string&gt;&gt; res;\n    vector&lt;string&gt; tmp;\n    vector&lt;vector&lt;string&gt;&gt; partition(string s) {\n        getPartition(s);\n        return res;\n    }\n\n    void getPartition(string s){\n        if(s.empty()) {\n            res.push_back(tmp);\n            return;\n        }\n        for(int i = 0; i &lt; s.length(); i++){\n            string sub = s.substr(0, i + 1);\n            if(isPalindrome(sub)){\n                tmp.push_back(sub);\n                getPartition(s.substr(i + 1, s.length()));\n                tmp.pop_back();\n            }\n        }\n    }\n\n    bool isPalindrome(const string&amp; s){\n        if(s.empty()) return false;\n        int lo = 0, hi = s.length() - 1;\n        while(lo &lt;= hi)\n            if(s[lo++] != s[hi--]) \n                return false;\n        return true;\n    }\n};\n</code></pre>\n<h2 id=\"解法二：优化版\">解法二：优化版</h2>\n<h1 id=\"179-Largest-Number\"><a href=\"https://leetcode-cn.com/problems/largest-number/\" target=\"_blank\" rel=\"noopener\">179. Largest Number</a></h1>\n<p><a href=\"String-Medium/image-20200506134117681.png\" title=\"image-20200506134117681\" class=\"gallery-item\"><img src=\"image-20200506134117681.png\" alt=\"image-20200506134117681\"></a></p>\n<h2 id=\"解法一：字典逆序\">解法一：字典逆序</h2>\n<p>本质就是排字典序，可以自己写一个，也可以直接用string重载的比较运算符</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    static bool compare(const string a, const string b){\n        int len = std::min(a.length(), b.length());\n        for (int i = 0; i &lt; len; i++)\n            if(a[i] != b[i]) return a[i] &gt; b[i];\n        if (a.length() &gt; b.length()) \n            return compare(a.substr(len, a.length()),b); \n        else if (a.length() &lt; b.length()) \n            return compare(a, b.substr(len, b.length()));\n        return 0;\n    }\n    \n    string largestNumber(vector&lt;int&gt;&amp; nums) {\n        vector&lt;string&gt; numbers = vector&lt;string&gt;(nums.size());\n        for(int i = 0; i &lt; nums.size(); i++) \n            numbers[i] = to_string(nums[i]);\n        std::sort(numbers.begin(), numbers.end(), compare);\n        string res = &quot;&quot;;\n        for(string s : numbers)\n            res += s;\n        bool zero = true;\n        for(char c : res) if(c != '0') zero = false;\n        if(zero) return &quot;0&quot;;\n        return res;\n    }\n\n};\n</code></pre>\n<h2 id=\"解法二：string自带的比较运算\">解法二：string自带的比较运算</h2>\n<pre><code class=\"language-cpp\">static bool compare(const string a, const string b){\n    return a + b &gt; b + a;\n}\n</code></pre>\n<h1 id=\"187-Repeated-DNA-Sequences\"><a href=\"https://leetcode-cn.com/problems/repeated-dna-sequences/\" target=\"_blank\" rel=\"noopener\">187. Repeated DNA Sequences</a></h1>\n<p><a href=\"String-Medium/image-20200506144355883.png\" title=\"image-20200506144355883\" class=\"gallery-item\"><img src=\"image-20200506144355883.png\" alt=\"image-20200506144355883\"></a></p>\n<h2 id=\"解法一：unordered-set-unordered-map\">解法一：unordered_set &amp; unordered_map</h2>\n<p>不必多说，注意长度小于10时直接return</p>\n<p><strong>unordered_set：</strong></p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    vector&lt;string&gt; findRepeatedDnaSequences(string s) {\n        if(s.length() &lt; 10) return {};\n        unordered_set&lt;string&gt; set, ans;\n        vector&lt;string&gt; res;\n        for (int start = 0; start &lt; s.length() - 9; start++) {\n            string curr = s.substr(start, 10);\n            if(set.find(curr) == set.end()) \n                set.insert(curr);\n            else\n                ans.insert(curr);\n        }\n\n        for (auto k : ans)\n            res.push_back(k);\n        return res;\n    }\n};\n</code></pre>\n<p><strong>unordered_map：</strong></p>\n<pre><code class=\"language-cpp\">// ....\nmap[curr]++;\n// ....\nfor (auto k : map)\n    if(k.second &gt; 0) res.push_back(k.first);\nreturn res;\n</code></pre>\n<h2 id=\"解法二：\">解法二：</h2>\n<h1 id=\"49-Group-Anagrams\"><a href=\"https://leetcode-cn.com/problems/group-anagrams/\" target=\"_blank\" rel=\"noopener\">49. Group Anagrams</a></h1>\n<p><a href=\"String-Medium/image-20200509024036177.png\" title=\"image-20200509024036177\" class=\"gallery-item\"><img src=\"image-20200509024036177.png\" alt=\"image-20200509024036177\"></a></p>\n<h2 id=\"解法一：排序-unordered-map\">解法一：排序 + unordered_map</h2>\n<p>用排序来判断异位词，用哈希存各异位词的分组</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) {\n        vector&lt;vector&lt;string&gt;&gt; res;\n        unordered_map&lt;string, vector&lt;string&gt;&gt; map;\n        for(int i = 0; i &lt; strs.size(); i++) {\n            string s = strs[i];\n            std::sort(s.begin(), s.end());\n            map[s].push_back(strs[i]);\n        }\n\n        for(auto k : map)\n            res.push_back(k.second);\n        return res;\n    }\n};\n</code></pre>\n<h1 id=\"151-Reverse-Words-in-a-String\"><a href=\"https://leetcode-cn.com/problems/reverse-words-in-a-string/\" target=\"_blank\" rel=\"noopener\">151. Reverse Words in a String</a></h1>\n<p><a href=\"String-Medium/image-20200510174413303.png\" title=\"image-20200510174413303\" class=\"gallery-item\"><img src=\"image-20200510174413303.png\" alt=\"image-20200510174413303\"></a></p>\n<h2 id=\"解法一：模拟\">解法一：模拟</h2>\n<p>水平有限，写得很乱。。</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    string reverseWords(string s) {\n        int i = 0, j = s.length() - 1;\n        while(i &lt;= j &amp;&amp; s[i] == ' ') i++;\n        while(j &gt; 0  &amp;&amp; s[j] == ' ') j--;\n        if(i &gt; j) return &quot;&quot;;\n        s = s.substr(i, j - i + 1);\n        return reverse(s);\n    }\n\n    string reverse(string s) {\n        string res = &quot;&quot;, tmp = &quot;&quot;;\n        for(int i = 0; i &lt; s.length(); i++) {\n            if (s[i] == ' ') {\n                if(tmp.empty()) continue;\n                res = res.empty() ? tmp : tmp + &quot; &quot; + res;\n                tmp.clear();\n            }\n            else tmp += s[i];\n            if(i == s.length() - 1)\n                res = res.empty() ? tmp : tmp + &quot; &quot; + res;\n        }\n        return res;\n    }\n};\n</code></pre>\n<h1 id=\"165-Compare-Version-Numbers\"><a href=\"https://leetcode-cn.com/problems/compare-version-numbers/\" target=\"_blank\" rel=\"noopener\">165. Compare Version Numbers</a></h1>\n<p><a href=\"String-Medium/image-20200512145627513.png\" title=\"image-20200512145627513\" class=\"gallery-item\"><img src=\"image-20200512145627513.png\" alt=\"image-20200512145627513\"></a></p>\n<h2 id=\"解法一：分割转整数\">解法一：分割转整数</h2>\n<p>一开始开以为是字典序比较，没想到是整数比较</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    int compareVersion(string version1, string version2) {\n        vector&lt;int&gt; v1 = split(version1), v2 = split(version2);\n        for(int i = 0; i &lt; v1.size() || i &lt; v2.size(); i++) {\n           int n1 = i &lt; v1.size() ? v1[i] : 0;\n           int n2 = i &lt; v2.size() ? v2[i] : 0;\n           if(n1 &gt; n2) return 1;\n           else if(n1 &lt; n2) return -1;\n        }  \n        return 0;\n    }\n\n    vector&lt;int&gt; split(std::string s) {\n        string tmp = &quot;&quot;;\n        vector&lt;int&gt; v;\n        for(int i = 0; i &lt; s.length(); i++) {\n            if(s[i] == '.') {\n                if(!tmp.empty()) {\n                    v.push_back(stoi(tmp));\n                    tmp.clear();\n                }\n            }\n            else tmp += s[i];\n            if(i == s.length() - 1 &amp;&amp; !tmp.empty())\n                v.push_back(stoi(tmp));  \n        }\n        return v;\n    }\n};\n</code></pre>\n<h1 id=\"394-Decode-String\"><a href=\"https://leetcode-cn.com/problems/decode-string/\" target=\"_blank\" rel=\"noopener\">394. Decode String</a></h1>\n<p><a href=\"String-Medium/image-20200515192458782.png\" title=\"image-20200515192458782\" class=\"gallery-item\"><img src=\"image-20200515192458782.png\" alt=\"image-20200515192458782\"></a></p>\n<h2 id=\"解法一：递归法\">解法一：递归法</h2>\n<ul>\n<li>正常情况下直接加入结果</li>\n<li>如果遇到数字，先解析数字</li>\n<li>然后匹配对应的 “]”，将括号中间的子串递归地解码，然后重复cnt次</li>\n</ul>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    // 将字符串重复k次\n    string genString(int k, string a) {\n        string res;\n        for(int i = 0; i &lt; k; i++)\n            res += a;\n        return res;\n    }\n    \n    // 计算对应的']'的索引\n    int matchIndex(string s, int k, int start) {\n        for(int i = start; i &lt; s.length(); i++) {\n            if(s[i] == ']') {\n                if(k == 1) return i;\n                else --k;\n            }\n            else if(s[i] == '[')\n                return matchIndex(s, k + 1, i + 1);\n        }\n        return -1;\n    }\n\n    string decodeString(string s) {\n        string res;\n        for(int i = 0; i &lt; s.length(); i++) {\n            if(isdigit(s[i])) {\n                // 解析数字\n                int cnt = s[i] - '0';\n                while(isdigit(s[i + 1])){\n                    i++;\n                    cnt = cnt * 10 + s[i] - '0';\n                }\n\n                int idx = matchIndex(s, 1, i + 2);           // 找到右括号所在的位置\n                string recur = s.substr(i + 2, idx - i - 2);\n                recur = decodeString(recur);                 // 递归求解\n                res += genString(cnt, recur);                // 生成\n                i = idx;                                     // i移动到右括号处 \n                continue;\n            }\n            else if(i &lt; s.length()) res += s[i];\n        }\n        return res;\n    }\n};\n</code></pre>\n<h1 id=\"647-Palindromic-Substrings\"><a href=\"https://leetcode-cn.com/problems/palindromic-substrings/\" target=\"_blank\" rel=\"noopener\">647. Palindromic Substrings</a></h1>\n<p><a href=\"String-Medium/image-20200519134014730.png\" title=\"image-20200519134014730\" class=\"gallery-item\"><img src=\"image-20200519134014730.png\" alt=\"image-20200519134014730\"></a></p>\n<h2 id=\"解法一：中心扩展法\">解法一：中心扩展法</h2>\n<p>同最长回文子串，单个字符也算，所以cnt初始为1</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    int countSubstrings(string s) {\n        int res = 0;\n        for(int i = 0; i &lt; s.length(); i++) {\n            res += countPalindrome(s, i, i);\n            if(i != s.length() - 1 &amp;&amp; s[i] == s[i + 1])\n                res += countPalindrome(s, i, i + 1);\n        }\n        return res;\n    }\n\n    int countPalindrome(string s, int i, int j) {\n        int cnt = 1;\n        while(i &gt; 0 &amp;&amp; j &lt; s.length() - 1) {\n            if(s[i - 1] != s[j + 1])\n                return cnt;\n            cnt++; i--; j++;\n        }\n        return cnt;\n    }\n};\n</code></pre>\n<h1 id=\"1371-Find-the-Longest-Substring-Containing-Vowels-in-Even-Counts\"><a href=\"https://leetcode-cn.com/problems/find-the-longest-substring-containing-vowels-in-even-counts/\" target=\"_blank\" rel=\"noopener\">1371. Find the Longest Substring Containing Vowels in Even Counts</a></h1>\n<p><a href=\"String-Medium/image-20200520131929011.png\" title=\"image-20200520131929011\" class=\"gallery-item\"><img src=\"image-20200520131929011.png\" alt=\"image-20200520131929011\"></a></p>\n<h2 id=\"解法一：状压DP\">解法一：状压DP</h2>\n<p>只想到了vector来点乘的方法，此为官方解</p>\n<ul>\n<li>用一个5位bit表示各字符的状态</li>\n<li>c为元音时异或对应的位</li>\n<li>当前缀存在一个相同状态时，更新最大长度，而不更新当前位置</li>\n<li>否则记录当前位置</li>\n</ul>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    int findTheLongestSubstring(string s) {\n        int res = 0, status = 0, n = s.length();\n        vector&lt;int&gt; dp(1 &lt;&lt; 5, -1);\n        dp[0] = 0;\n        vector&lt;int&gt; vowel = {'a','e','i','o','u'};\n        for(int i = 0; i &lt; s.length(); i++) {\n            for(int k = 0; k &lt; 5; k++)\n                if(s[i] == vowel[k]) status ^= 1 &lt;&lt; k;\n            \n            if(dp[status] != -1)\n                res = std::max(res, i - dp[status] + 1);\n            else\n                dp[status] = i + 1;\n        }\n        return res;\n    }\n};\n</code></pre>\n</div><script src=\"https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js\"></script><script>if (typeof lightGallery !== 'undefined') {\n        var options = {\n            selector: '.gallery-item'\n        };\n        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);\n        }</script>","more":"<h1 id=\"6-ZigZag-Conversion\"><a href=\"https://leetcode-cn.com/problems/zigzag-conversion/\" target=\"_blank\" rel=\"noopener\">6. ZigZag Conversion</a></h1>\n<p><a href=\"String-Medium/image-20200425185253744.png\" title=\"image-20200425185253744\" class=\"gallery-item\"><img src=\"image-20200425185253744.png\" alt=\"image-20200425185253744\"></a></p>\n<h2 id=\"解法一\">解法一</h2>\n<p>逻辑本质上相当于交替输出123212321这样的字符串，所以没什么可说的。。就是要注意一下numRows 为1时记得直接return，否则idx会越界</p>\n<p>不过官方题解和我写的基本上一样呢 /惊/</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    std::vector&lt;std::string&gt; rows;\n    string convert(string s, int numRows) {\n        if(numRows == 1) return s;\n        rows = std::vector&lt;std::string&gt;(numRows);\n        bool turn = false;\n        for (int i = 0, idx = 0;i&lt;s.length();i++) {\n            rows[idx] += s[i];\n            if (idx == 0 || idx == numRows - 1) turn = !turn;\n            idx += turn ? 1 : -1;\n        }\n\n        std::string ans;\n        for (std::string row : rows) \n            ans += row;\n        return ans;\n    }\n};\n</code></pre>\n<h1 id=\"522-Longest-Uncommon-Subsequence-II\"><a href=\"https://leetcode-cn.com/problems/longest-uncommon-subsequence-ii/\" target=\"_blank\" rel=\"noopener\">522. Longest Uncommon Subsequence II</a></h1>\n<p><a href=\"String-Medium/image-20200426125725779.png\" title=\"image-20200426125725779\" class=\"gallery-item\"><img src=\"image-20200426125725779.png\" alt=\"image-20200426125725779\"></a></p>\n<h2 id=\"解法一：暴力搜索\">解法一：暴力搜索</h2>\n<p>递归搜索每个字符串的所有子序列，放入unordered_map中，如果出现次数为1，进行比较，求出最大值</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n\tint findLUSlength(vector&lt;string&gt;&amp; strs) {\n\t\tunordered_map&lt;string, int&gt; map;\n\t\tfor (string s : strs)\n\t\t\tmapAllSubseq(s, 0, &quot;&quot;, map);\n\n\t\tint max = 0;\n\t\tfor (auto&amp; key : map) {\n\t\t\tif (key.second == 1)\n\t\t\t\tmax = key.first.length() &gt; max ? key.first.length() : max;\n\t\t}\n        return max == 0 ? -1 : max;\n\t}\n\n\tvoid mapAllSubseq(string s, int idx, string res, unordered_map&lt;string, int&gt;&amp; map) {\n\t\tif (idx == s.length()) {\n\t\t\tmap[res]++;\n\t\t\treturn;\n\t\t}\n\t\tmapAllSubseq(s, idx + 1, res, map);          // 放弃第idx位\n\t\tmapAllSubseq(s, idx + 1, res + s[idx], map); // 不放弃第idx位\n\t}\n};\n</code></pre>\n<h2 id=\"解法二：判断子序列\">解法二：判断子序列</h2>\n<ul>\n<li>\n<p>首先，最大长度肯定是某一串的长度</p>\n</li>\n<li>\n<p>注意第二层循环要从0开始，因为在某串之前的串不一定比此串短，也有可能长度相等，否则会把重复串的长度当成解</p>\n</li>\n</ul>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n\tbool isSubseq(string a, string b) {\n        if(a.length() &gt; b.length()) return false;\n\t\tfor (int i = 0, idx = 0; i &lt; b.length(); i++) {\n\t\t\tif (b[i] == a[idx])     idx++;\n\t\t\tif (idx  == a.length()) return true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tint findLUSlength(vector&lt;string&gt;&amp; strs) {\n        int max = 0;\n\t\tfor (int i = 0, j; i &lt; strs.size(); i++) {\n\t\t\tbool flag = true;\n\t\t\tfor (j = 0; j &lt; strs.size(); j++) {\n\t\t\t\tif (i == j)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (isSubseq(strs[i], strs[j])) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (flag &amp;&amp; strs[i].length() &gt; max)\n                max = strs[i].length(); \n\t\t}\n\t\treturn max == 0 ? -1 : max;\n\t}\n};\n</code></pre>\n<h2 id=\"解法三：先排序再判断子序列\">解法三：先排序再判断子序列</h2>\n<p>先排序，那么按照解法二得到的第一个结果就是解，不需要继续遍历求max</p>\n<p>由于排序的消耗比继续判断子序列的消耗要小，因此排序的结果略快一些</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n\tstatic int compare(string a, string b) {\n\t\treturn a.length() &gt; b.length();\n\t}\n\n\tbool isSubseq(string a, string b) {\n\t\tif (a.length() &gt; b.length()) return false;\n\t\tfor (int i = 0, idx = 0; i &lt; b.length(); i++) {\n\t\t\tif (b[i] == a[idx])     idx++;\n\t\t\tif (idx == a.length()) return true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tint findLUSlength(vector&lt;string&gt;&amp; strs) {\n\t\tstd::sort(strs.begin(), strs.end(), compare);\n\t\tfor (int i = 0, j; i &lt; strs.size(); i++) {\n\t\t\tbool flag = true;\n\t\t\tfor (j = 0; j &lt; strs.size(); j++) {\n\t\t\t\tif (i == j)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (isSubseq(strs[i], strs[j])) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (flag)\n\t\t\t\treturn strs[i].length();\n\t\t}\n\t\treturn -1;\n\t}\n};\n</code></pre>\n<h1 id=\"537-Complex-Number-Multiplication\"><a href=\"https://leetcode-cn.com/problems/complex-number-multiplication/\" target=\"_blank\" rel=\"noopener\">537. Complex Number Multiplication</a></h1>\n<p><a href=\"String-Medium/image-20200426152212362.png\" title=\"image-20200426152212362\" class=\"gallery-item\"><img src=\"image-20200426152212362.png\" alt=\"image-20200426152212362\"></a></p>\n<h2 id=\"解法一：std-stoi-std-to-string\">解法一：std::stoi() &amp; std::to_string()</h2>\n<p>一开始以为要用字符串先模拟乘法再模拟加法，但是看大家都直接上库函数，那我也只好恭敬不如从命了</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    string complexNumberMultiply(string a, string b) {\n\tint i = 0, j = 0;\n\tfor (i; a[i] != '+'; i++);\n\tfor (j; b[j] != '+'; j++);\n\tint re_a = std::stoi(a.substr(0, i)),\n\t\tim_a = std::stoi(a.substr(i + 1, a.length() - 1)),\n\t\tre_b = std::stoi(b.substr(0, j)),\n\t\tim_b = std::stoi(b.substr(j + 1, b.length() - 1));\n\tstd::string ans = std::to_string(re_a * re_b - im_a * im_b) + &quot;+&quot; \n\t\t\t\t\t+ std::to_string(re_a * im_b + re_b * im_a)+ &quot;i&quot;;\n    return ans;\n    }\n};\n</code></pre>\n<h1 id=\"43-Multiply-Strings\"><a href=\"https://leetcode-cn.com/problems/multiply-strings/\" target=\"_blank\" rel=\"noopener\">43. Multiply Strings</a></h1>\n<p><a href=\"String-Medium/image-20200427235742024.png\" title=\"image-20200427235742024\" class=\"gallery-item\"><img src=\"image-20200427235742024.png\" alt=\"image-20200427235742024\"></a></p>\n<h2 id=\"解法一：耿直模拟竖式\">解法一：耿直模拟竖式</h2>\n<p>模拟竖式乘法，先模拟一位数乘N位数，再累加</p>\n<p>但是我写的比较烂…正解请看优化版</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n\tstring multiply(string num1, string num2) {\n\t\tstd::string res = &quot;0&quot;;\n\t\tif (num1 == &quot;0&quot; || num2 == &quot;0&quot;) return &quot;0&quot;;\n\t\tfor (int i = num2.length() - 1; i &gt; -1; i--) {\n\t\t\tstd::string val = multi(num1, num2[i]);\n\t\t\tfor (int k = 0; k &lt; num2.length() - i - 1; k++)\n\t\t\t\tval += '0';\n\t\t\tres = add(res, val);\n\t\t}\n\t\treturn res;\n\t}\n\n\tstd::string multi(const std::string&amp; a, char b) {\n\t\tif (b == '0') return &quot;0&quot;;\n\t\tint y = b - '0', carry = 0;\n\t\tstd::string res = &quot;&quot;;\n\t\tfor (int i = a.length() - 1; i &gt; -1; i--) {\n\t\t\tint x = a[i] - '0';\n\t\t\tint val = x * y + carry;\n\t\t\tif (val &gt; 9) {\n\t\t\t\tcarry = val / 10;\n\t\t\t\tval = val % 10;\n\t\t\t}\n\t\t\telse carry = 0;\n\t\t\tres = std::to_string(val) + res;\n\t\t}\n\t\tif (carry &gt; 0) res = std::to_string(carry) + res;\n\t\treturn res;\n\t}\n\n\tstd::string add(const std::string&amp; a, const std::string&amp; b) {\n\t\tint carry = 0, i = a.length() - 1, j = b.length() - 1;\n\t\tstd::string res = &quot;&quot;;\n\t\twhile (i &gt;= 0 || j &gt;= 0) {\n\t\t\tint x = i &gt;= 0 ? a[i--] - '0' : 0;\n\t\t\tint y = j &gt;= 0 ? b[j--] - '0' : 0;\n\t\t\tint sum = x + y + carry;\n\t\t\tif (sum &gt; 9) {\n\t\t\t\tcarry = 1;\n\t\t\t\tsum -= 10;\n\t\t\t}\n\t\t\telse carry = 0;\n\t\t\tres = std::to_string(sum) + res;\n\t\t}\n\t\tif (carry &gt; 0) res = '1' + res;\n\t\treturn res;\n\t}\n};\n</code></pre>\n<h2 id=\"解法二：优化版竖式\">解法二：优化版竖式</h2>\n<h1 id=\"131-Palindrome-Partitioning\"><a href=\"https://leetcode-cn.com/problems/palindrome-partitioning/\" target=\"_blank\" rel=\"noopener\">131. Palindrome Partitioning</a></h1>\n<p><a href=\"String-Medium/image-20200504015642936.png\" title=\"image-20200504015642936\" class=\"gallery-item\"><img src=\"image-20200504015642936.png\" alt=\"image-20200504015642936\"></a></p>\n<h2 id=\"解法一：回溯法\">解法一：回溯法</h2>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    vector&lt;vector&lt;string&gt;&gt; res;\n    vector&lt;string&gt; tmp;\n    vector&lt;vector&lt;string&gt;&gt; partition(string s) {\n        getPartition(s);\n        return res;\n    }\n\n    void getPartition(string s){\n        if(s.empty()) {\n            res.push_back(tmp);\n            return;\n        }\n        for(int i = 0; i &lt; s.length(); i++){\n            string sub = s.substr(0, i + 1);\n            if(isPalindrome(sub)){\n                tmp.push_back(sub);\n                getPartition(s.substr(i + 1, s.length()));\n                tmp.pop_back();\n            }\n        }\n    }\n\n    bool isPalindrome(const string&amp; s){\n        if(s.empty()) return false;\n        int lo = 0, hi = s.length() - 1;\n        while(lo &lt;= hi)\n            if(s[lo++] != s[hi--]) \n                return false;\n        return true;\n    }\n};\n</code></pre>\n<h2 id=\"解法二：优化版\">解法二：优化版</h2>\n<h1 id=\"179-Largest-Number\"><a href=\"https://leetcode-cn.com/problems/largest-number/\" target=\"_blank\" rel=\"noopener\">179. Largest Number</a></h1>\n<p><a href=\"String-Medium/image-20200506134117681.png\" title=\"image-20200506134117681\" class=\"gallery-item\"><img src=\"image-20200506134117681.png\" alt=\"image-20200506134117681\"></a></p>\n<h2 id=\"解法一：字典逆序\">解法一：字典逆序</h2>\n<p>本质就是排字典序，可以自己写一个，也可以直接用string重载的比较运算符</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    static bool compare(const string a, const string b){\n        int len = std::min(a.length(), b.length());\n        for (int i = 0; i &lt; len; i++)\n            if(a[i] != b[i]) return a[i] &gt; b[i];\n        if (a.length() &gt; b.length()) \n            return compare(a.substr(len, a.length()),b); \n        else if (a.length() &lt; b.length()) \n            return compare(a, b.substr(len, b.length()));\n        return 0;\n    }\n    \n    string largestNumber(vector&lt;int&gt;&amp; nums) {\n        vector&lt;string&gt; numbers = vector&lt;string&gt;(nums.size());\n        for(int i = 0; i &lt; nums.size(); i++) \n            numbers[i] = to_string(nums[i]);\n        std::sort(numbers.begin(), numbers.end(), compare);\n        string res = &quot;&quot;;\n        for(string s : numbers)\n            res += s;\n        bool zero = true;\n        for(char c : res) if(c != '0') zero = false;\n        if(zero) return &quot;0&quot;;\n        return res;\n    }\n\n};\n</code></pre>\n<h2 id=\"解法二：string自带的比较运算\">解法二：string自带的比较运算</h2>\n<pre><code class=\"language-cpp\">static bool compare(const string a, const string b){\n    return a + b &gt; b + a;\n}\n</code></pre>\n<h1 id=\"187-Repeated-DNA-Sequences\"><a href=\"https://leetcode-cn.com/problems/repeated-dna-sequences/\" target=\"_blank\" rel=\"noopener\">187. Repeated DNA Sequences</a></h1>\n<p><a href=\"String-Medium/image-20200506144355883.png\" title=\"image-20200506144355883\" class=\"gallery-item\"><img src=\"image-20200506144355883.png\" alt=\"image-20200506144355883\"></a></p>\n<h2 id=\"解法一：unordered-set-unordered-map\">解法一：unordered_set &amp; unordered_map</h2>\n<p>不必多说，注意长度小于10时直接return</p>\n<p><strong>unordered_set：</strong></p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    vector&lt;string&gt; findRepeatedDnaSequences(string s) {\n        if(s.length() &lt; 10) return {};\n        unordered_set&lt;string&gt; set, ans;\n        vector&lt;string&gt; res;\n        for (int start = 0; start &lt; s.length() - 9; start++) {\n            string curr = s.substr(start, 10);\n            if(set.find(curr) == set.end()) \n                set.insert(curr);\n            else\n                ans.insert(curr);\n        }\n\n        for (auto k : ans)\n            res.push_back(k);\n        return res;\n    }\n};\n</code></pre>\n<p><strong>unordered_map：</strong></p>\n<pre><code class=\"language-cpp\">// ....\nmap[curr]++;\n// ....\nfor (auto k : map)\n    if(k.second &gt; 0) res.push_back(k.first);\nreturn res;\n</code></pre>\n<h2 id=\"解法二：\">解法二：</h2>\n<h1 id=\"49-Group-Anagrams\"><a href=\"https://leetcode-cn.com/problems/group-anagrams/\" target=\"_blank\" rel=\"noopener\">49. Group Anagrams</a></h1>\n<p><a href=\"String-Medium/image-20200509024036177.png\" title=\"image-20200509024036177\" class=\"gallery-item\"><img src=\"image-20200509024036177.png\" alt=\"image-20200509024036177\"></a></p>\n<h2 id=\"解法一：排序-unordered-map\">解法一：排序 + unordered_map</h2>\n<p>用排序来判断异位词，用哈希存各异位词的分组</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) {\n        vector&lt;vector&lt;string&gt;&gt; res;\n        unordered_map&lt;string, vector&lt;string&gt;&gt; map;\n        for(int i = 0; i &lt; strs.size(); i++) {\n            string s = strs[i];\n            std::sort(s.begin(), s.end());\n            map[s].push_back(strs[i]);\n        }\n\n        for(auto k : map)\n            res.push_back(k.second);\n        return res;\n    }\n};\n</code></pre>\n<h1 id=\"151-Reverse-Words-in-a-String\"><a href=\"https://leetcode-cn.com/problems/reverse-words-in-a-string/\" target=\"_blank\" rel=\"noopener\">151. Reverse Words in a String</a></h1>\n<p><a href=\"String-Medium/image-20200510174413303.png\" title=\"image-20200510174413303\" class=\"gallery-item\"><img src=\"image-20200510174413303.png\" alt=\"image-20200510174413303\"></a></p>\n<h2 id=\"解法一：模拟\">解法一：模拟</h2>\n<p>水平有限，写得很乱。。</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    string reverseWords(string s) {\n        int i = 0, j = s.length() - 1;\n        while(i &lt;= j &amp;&amp; s[i] == ' ') i++;\n        while(j &gt; 0  &amp;&amp; s[j] == ' ') j--;\n        if(i &gt; j) return &quot;&quot;;\n        s = s.substr(i, j - i + 1);\n        return reverse(s);\n    }\n\n    string reverse(string s) {\n        string res = &quot;&quot;, tmp = &quot;&quot;;\n        for(int i = 0; i &lt; s.length(); i++) {\n            if (s[i] == ' ') {\n                if(tmp.empty()) continue;\n                res = res.empty() ? tmp : tmp + &quot; &quot; + res;\n                tmp.clear();\n            }\n            else tmp += s[i];\n            if(i == s.length() - 1)\n                res = res.empty() ? tmp : tmp + &quot; &quot; + res;\n        }\n        return res;\n    }\n};\n</code></pre>\n<h1 id=\"165-Compare-Version-Numbers\"><a href=\"https://leetcode-cn.com/problems/compare-version-numbers/\" target=\"_blank\" rel=\"noopener\">165. Compare Version Numbers</a></h1>\n<p><a href=\"String-Medium/image-20200512145627513.png\" title=\"image-20200512145627513\" class=\"gallery-item\"><img src=\"image-20200512145627513.png\" alt=\"image-20200512145627513\"></a></p>\n<h2 id=\"解法一：分割转整数\">解法一：分割转整数</h2>\n<p>一开始开以为是字典序比较，没想到是整数比较</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    int compareVersion(string version1, string version2) {\n        vector&lt;int&gt; v1 = split(version1), v2 = split(version2);\n        for(int i = 0; i &lt; v1.size() || i &lt; v2.size(); i++) {\n           int n1 = i &lt; v1.size() ? v1[i] : 0;\n           int n2 = i &lt; v2.size() ? v2[i] : 0;\n           if(n1 &gt; n2) return 1;\n           else if(n1 &lt; n2) return -1;\n        }  \n        return 0;\n    }\n\n    vector&lt;int&gt; split(std::string s) {\n        string tmp = &quot;&quot;;\n        vector&lt;int&gt; v;\n        for(int i = 0; i &lt; s.length(); i++) {\n            if(s[i] == '.') {\n                if(!tmp.empty()) {\n                    v.push_back(stoi(tmp));\n                    tmp.clear();\n                }\n            }\n            else tmp += s[i];\n            if(i == s.length() - 1 &amp;&amp; !tmp.empty())\n                v.push_back(stoi(tmp));  \n        }\n        return v;\n    }\n};\n</code></pre>\n<h1 id=\"394-Decode-String\"><a href=\"https://leetcode-cn.com/problems/decode-string/\" target=\"_blank\" rel=\"noopener\">394. Decode String</a></h1>\n<p><a href=\"String-Medium/image-20200515192458782.png\" title=\"image-20200515192458782\" class=\"gallery-item\"><img src=\"image-20200515192458782.png\" alt=\"image-20200515192458782\"></a></p>\n<h2 id=\"解法一：递归法\">解法一：递归法</h2>\n<ul>\n<li>正常情况下直接加入结果</li>\n<li>如果遇到数字，先解析数字</li>\n<li>然后匹配对应的 “]”，将括号中间的子串递归地解码，然后重复cnt次</li>\n</ul>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    // 将字符串重复k次\n    string genString(int k, string a) {\n        string res;\n        for(int i = 0; i &lt; k; i++)\n            res += a;\n        return res;\n    }\n    \n    // 计算对应的']'的索引\n    int matchIndex(string s, int k, int start) {\n        for(int i = start; i &lt; s.length(); i++) {\n            if(s[i] == ']') {\n                if(k == 1) return i;\n                else --k;\n            }\n            else if(s[i] == '[')\n                return matchIndex(s, k + 1, i + 1);\n        }\n        return -1;\n    }\n\n    string decodeString(string s) {\n        string res;\n        for(int i = 0; i &lt; s.length(); i++) {\n            if(isdigit(s[i])) {\n                // 解析数字\n                int cnt = s[i] - '0';\n                while(isdigit(s[i + 1])){\n                    i++;\n                    cnt = cnt * 10 + s[i] - '0';\n                }\n\n                int idx = matchIndex(s, 1, i + 2);           // 找到右括号所在的位置\n                string recur = s.substr(i + 2, idx - i - 2);\n                recur = decodeString(recur);                 // 递归求解\n                res += genString(cnt, recur);                // 生成\n                i = idx;                                     // i移动到右括号处 \n                continue;\n            }\n            else if(i &lt; s.length()) res += s[i];\n        }\n        return res;\n    }\n};\n</code></pre>\n<h1 id=\"647-Palindromic-Substrings\"><a href=\"https://leetcode-cn.com/problems/palindromic-substrings/\" target=\"_blank\" rel=\"noopener\">647. Palindromic Substrings</a></h1>\n<p><a href=\"String-Medium/image-20200519134014730.png\" title=\"image-20200519134014730\" class=\"gallery-item\"><img src=\"image-20200519134014730.png\" alt=\"image-20200519134014730\"></a></p>\n<h2 id=\"解法一：中心扩展法\">解法一：中心扩展法</h2>\n<p>同最长回文子串，单个字符也算，所以cnt初始为1</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    int countSubstrings(string s) {\n        int res = 0;\n        for(int i = 0; i &lt; s.length(); i++) {\n            res += countPalindrome(s, i, i);\n            if(i != s.length() - 1 &amp;&amp; s[i] == s[i + 1])\n                res += countPalindrome(s, i, i + 1);\n        }\n        return res;\n    }\n\n    int countPalindrome(string s, int i, int j) {\n        int cnt = 1;\n        while(i &gt; 0 &amp;&amp; j &lt; s.length() - 1) {\n            if(s[i - 1] != s[j + 1])\n                return cnt;\n            cnt++; i--; j++;\n        }\n        return cnt;\n    }\n};\n</code></pre>\n<h1 id=\"1371-Find-the-Longest-Substring-Containing-Vowels-in-Even-Counts\"><a href=\"https://leetcode-cn.com/problems/find-the-longest-substring-containing-vowels-in-even-counts/\" target=\"_blank\" rel=\"noopener\">1371. Find the Longest Substring Containing Vowels in Even Counts</a></h1>\n<p><a href=\"String-Medium/image-20200520131929011.png\" title=\"image-20200520131929011\" class=\"gallery-item\"><img src=\"image-20200520131929011.png\" alt=\"image-20200520131929011\"></a></p>\n<h2 id=\"解法一：状压DP\">解法一：状压DP</h2>\n<p>只想到了vector来点乘的方法，此为官方解</p>\n<ul>\n<li>用一个5位bit表示各字符的状态</li>\n<li>c为元音时异或对应的位</li>\n<li>当前缀存在一个相同状态时，更新最大长度，而不更新当前位置</li>\n<li>否则记录当前位置</li>\n</ul>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    int findTheLongestSubstring(string s) {\n        int res = 0, status = 0, n = s.length();\n        vector&lt;int&gt; dp(1 &lt;&lt; 5, -1);\n        dp[0] = 0;\n        vector&lt;int&gt; vowel = {'a','e','i','o','u'};\n        for(int i = 0; i &lt; s.length(); i++) {\n            for(int k = 0; k &lt; 5; k++)\n                if(s[i] == vowel[k]) status ^= 1 &lt;&lt; k;\n            \n            if(dp[status] != -1)\n                res = std::max(res, i - dp[status] + 1);\n            else\n                dp[status] = i + 1;\n        }\n        return res;\n    }\n};\n</code></pre>\n<script src=\"https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js\"></script><script>if (typeof lightGallery !== 'undefined') {\n        var options = {\n            selector: '.gallery-item'\n        };\n        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);\n        }</script>","categories":[{"name":"Algorithm","path":"api/categories/Algorithm.json"}],"tags":[{"name":"Leetcode","path":"api/tags/Leetcode.json"}]}