{"title":"Greedy-Medium","slug":"Greedy-Medium","date":"2020-03-01T15:22:41.000Z","updated":"2020-05-23T07:28:22.634Z","comments":true,"path":"api/articles/Greedy-Medium.json","excerpt":"Abstract：更新部分Medium难度Greedy相关题解","covers":["image-20200301232408400.png","image-20200303192025189.png","image-20200303203333029.png","image-20200306003402169.png","image-20200523152704126.png"],"content":"<link rel=\"stylesheet\" type=\"text/css\" href=\"https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css\"><div class=\".article-gallery\" <p><strong>Abstract</strong>：更新部分<code>Medium</code>难度<code>Greedy</code>相关题解<p></p>\n<a id=\"more\"></a>\n<h1 id=\"55-Jump-Game\"><a href=\"https://leetcode-cn.com/problems/jump-game/\" target=\"_blank\" rel=\"noopener\">55. Jump Game</a></h1>\n<p><a href=\"Greedy-Medium/image-20200301232408400.png\" title=\"image-20200301232408400\" class=\"gallery-item\"><img src=\"image-20200301232408400.png\" alt=\"image-20200301232408400\"></a></p>\n<h2 id=\"解法一：递归（贪心）\">解法一：递归（贪心）</h2>\n<ul>\n<li>\n<p><strong>思路</strong>：对于最后一个节点，寻找一个能到达它的节点，递归判断该节点，即为结果</p>\n</li>\n<li>\n<p><strong>递归结束条件</strong>：当已经找到第一个节点了，说明找到了抵达终点的通路，返回<code>ture</code></p>\n<pre><code class=\"language-java\">if(end&lt;=0)return true;\n</code></pre>\n</li>\n</ul>\n<h3 id=\"完整解法\">完整解法</h3>\n<pre><code class=\"language-java\">class Solution {\n    public boolean canJump(int[] nums) {\n        return jump(nums,nums.length-1);\n    }\n\n    public boolean jump(int[] nums,int end){\n        if(end&lt;=0)return true;\n        for(int i=end-1;i&gt;=0;i--){                   //从后往前找\n            if(nums[i]&gt;=end-i){return jump(nums,i);} //递归这个可达点\n        }\n        return false;                                //没找到，说明不可达\n    }\n}\n</code></pre>\n<h3 id=\"非递归贪心\">非递归贪心<sup class=\"footnote-ref\"><a href=\"#fn1\" id=\"fnref1\">[1]</a></sup></h3>\n<pre><code class=\"language-java\">public class Solution {\n    public boolean canJump(int[] nums) {\n        int lastPos = nums.length - 1;\n        for (int i = nums.length - 1; i &gt;= 0; i--) {\n            if (i + nums[i] &gt;= lastPos) {\n                lastPos = i;\n            }\n        }\n        return lastPos == 0;\n    }\n}\n</code></pre>\n<h2 id=\"解法二：遍历更新最远点\">解法二：遍历更新最远点<sup class=\"footnote-ref\"><a href=\"#fn2\" id=\"fnref2\">[2]</a></sup></h2>\n<ul>\n<li>\n<p><strong>思路</strong>：对于一个起跳点 i，它能到达的最远处为</p>\n<pre><code class=\"language-java\">max=i+nums[i];\n</code></pre>\n<p>可以以此作为依据，如果起跳点到达了原本无法跳到的地方，即</p>\n<pre><code class=\"language-java\">i&gt;max;\n</code></pre>\n<p>说明不可能到达终点</p>\n</li>\n</ul>\n<h3 id=\"完整解法-v2\">完整解法</h3>\n<pre><code class=\"language-java\">class Solution {\n    public boolean canJump(int[] nums) {\n        int max=0;\n        for(int i=0;i&lt;nums.length;i++){\n            if(i&gt;max)return false;       //根本没法跳到这\n            max=Math.max(max,i+nums[i]); //更新最远点\n        }\n        return true;\n    }\n}\n</code></pre>\n<h1 id=\"134-Gas-Station\"><a href=\"https://leetcode-cn.com/problems/gas-station/\" target=\"_blank\" rel=\"noopener\">134. Gas Station</a></h1>\n<p><a href=\"Greedy-Medium/image-20200303192025189.png\" title=\"image-20200303192025189\" class=\"gallery-item\"><img src=\"image-20200303192025189.png\" alt=\"image-20200303192025189\"></a></p>\n<h2 id=\"解法一：贪心\">解法一：贪心</h2>\n<p>暴力法是不可能的，要说dp这题也不是通过迭代求解的，而且这题看来像是单一原则求解的题</p>\n<p>那么考虑这个单一原则就是问题的关键了</p>\n<ul>\n<li>\n<p><strong>思路一</strong>：找净油量最多的点</p>\n<p>WA，这个做法错在于没有考虑到此时这个节点前的状态</p>\n</li>\n<li>\n<p><strong>思路二</strong>：净油量的基础上综合考虑从0开始到这个节点的位置时的剩余油量</p>\n<p>我们可以认为到达某一站时的剩余油量相对来说越少越好，因为总油量是固定的，因此剩余油量越少，说明前面的阻力越大，而为了环行一圈，我们肯定是认为阻力越小越好的，由此可以认为判定原则是</p>\n<pre><code class=\"language-java\">int earn=gas[i]-cost[i];    //该点出发的净油量\nres+=earn;                  //该点的相对阻力\nmax=Math.max(earn-res,max); //寻找 净油量-相对阻力 最大的节点，即为解\n</code></pre>\n</li>\n</ul>\n<h3 id=\"完整解法-v3\">完整解法</h3>\n<pre><code class=\"language-java\">class Solution {\n    public int canCompleteCircuit(int[] gas, int[] cost) {\n        if(gas.length==0)return -1;\n        int dst=0,max=Integer.MIN_VALUE,res=0;\n        for(int i=0;i&lt;gas.length;i++){\n            int earn=gas[i]-cost[i];\n            res+=earn;\n            if(max&lt;(max=Math.max(earn-res,max)) ){\n                dst=i;\n            }\n        }\n        return res&gt;=0?dst:-1;\n    }\n}\n</code></pre>\n<h1 id=\"376-Wiggle-Subsequence\"><a href=\"https://leetcode-cn.com/problems/wiggle-subsequence/\" target=\"_blank\" rel=\"noopener\">376. Wiggle Subsequence</a></h1>\n<p><a href=\"Greedy-Medium/image-20200303203333029.png\" title=\"image-20200303203333029\" class=\"gallery-item\"><img src=\"image-20200303203333029.png\" alt=\"image-20200303203333029\"></a></p>\n<h2 id=\"解法一：DP\">解法一：DP</h2>\n<ul>\n<li>\n<p><strong>思路</strong>：如果此次为上升，那么如果满足摆动序列的情况下，上一次应该是下降，反之同理</p>\n<pre><code class=\"language-java\">if(nums[i]-nums[i-1]&gt;0)\n    up=down+1;\nif(nums[i]-nums[i-1]&lt;0)\n    down=up+1;\n</code></pre>\n</li>\n<li>\n<p><strong>连续同向摆动</strong>：如果连续up，那么up始终只能保持down+1，反之亦然</p>\n</li>\n</ul>\n<h3 id=\"完整解法-v4\">完整解法</h3>\n<pre><code class=\"language-java\">class Solution {\n    public int wiggleMaxLength(int[] nums) {\n        if(nums.length&lt;=1)return nums.length;\n        int up=1,down=1;\n        for(int i=1;i&lt;nums.length;i++){\n            if(nums[i]-nums[i-1]&gt;0)\n                up=down+1;\n            if(nums[i]-nums[i-1]&lt;0)\n                down=up+1;\n        }\n        return Math.max(up,down);\n    }\n}\n</code></pre>\n<h1 id=\"402-Remove-K-Digits\"><a href=\"https://leetcode-cn.com/problems/remove-k-digits/\" target=\"_blank\" rel=\"noopener\">402. Remove K Digits</a></h1>\n<p><a href=\"Greedy-Medium/image-20200306003402169.png\" title=\"image-20200306003402169\" class=\"gallery-item\"><img src=\"image-20200306003402169.png\" alt=\"image-20200306003402169\"></a></p>\n<h2 id=\"解法一：递增栈\">解法一：递增栈</h2>\n<ul>\n<li>\n<p><strong>思路</strong>一：第一个思路是从左开始，谁大移除谁，但发现WA</p>\n</li>\n<li>\n<p><strong>思路二[官方题解]</strong>：谁大移除谁的问题在于，如果是个单调递增的序列，显然必须得先移除末尾的元素，由此发现移除时必须得<strong>跳过递增序列</strong>，也就是只有下一个元素小于上一个元素时，才会去删除，涉及到回溯问题，这里运用栈来解决</p>\n</li>\n<li>\n<p><strong>规则</strong>：如果新元素比栈内上一个元素小，就移除栈顶元素，这样解法就明确，剩下的就是如何拼凑答案，这里用LinkedList模拟栈，以便从栈底开始遍历元素</p>\n<pre><code class=\"language-java\">while(stack.size()&gt;0 &amp;&amp; k&gt;0 &amp;&amp;num.charAt(i)&lt;stack.getLast()){ \n    k--;\n    stack.removeLast(); //删掉突然减小的地方\n}\n</code></pre>\n</li>\n</ul>\n<h3 id=\"完整解法-v5\">完整解法</h3>\n<pre><code class=\"language-java\">class Solution {\n    public String removeKdigits(String num, int k) {\n        LinkedList&lt;Character&gt; stack=new LinkedList&lt;Character&gt;();\n        for(int i=0;i&lt;num.length();i++){\n            while(stack.size()&gt;0 &amp;&amp; k&gt;0 &amp;&amp;num.charAt(i)&lt;stack.getLast()){ \n                k--;\n                stack.removeLast();\n            }\n            stack.addLast(num.charAt(i));\n        }\n        for(int i=0;i&lt;k;i++){stack.removeLast();} //移除末尾剩余元素\n        \n        StringBuilder sb=new StringBuilder();        //构建解\n        while(!stack.isEmpty()){\n            sb.append(stack.removeFirst());\n        }\n        \n        int i=0;                                       \n        while(i&lt;sb.length() &amp;&amp; sb.charAt(i)=='0')i++; //去掉前导0\n        num=sb.substring(i);\n        if(num.length()==0)return &quot;0&quot;; //如果已经空了返回&quot;0&quot;\n        return num;\n    }\n}\n</code></pre>\n<h1 id=\"435-Non-overlapping-Intervals\"><a href=\"https://leetcode-cn.com/problems/non-overlapping-intervals/\" target=\"_blank\" rel=\"noopener\">435. Non-overlapping Intervals</a></h1>\n<p><a href=\"Greedy-Medium/image-20200523152704126.png\" title=\"image-20200523152704126\" class=\"gallery-item\"><img src=\"image-20200523152704126.png\" alt=\"image-20200523152704126\"></a></p>\n<h2 id=\"解法一：贪心-v2\">解法一：贪心</h2>\n<p>一开始以为是删掉区间大的那个，总是差一点，看答案发现应该删右区间大的那个，才能更好地保证不重叠，合理</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    int eraseOverlapIntervals(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) {\n        std::sort(intervals.begin(), intervals.end());\n        int res = 0, curr = 0;\n        for(int i = 1; i &lt; intervals.size(); i++) {\n            if(intervals[i][0] &lt; intervals[curr][1]) {\n                if(intervals[i][1] &lt; intervals[curr][1])\n                    curr = i;\n                ++res;\n            }\n            else curr = i;\n        }\n        return res;\n    }\n};\n</code></pre>\n<hr class=\"footnotes-sep\">\n<section class=\"footnotes\">\n<ol class=\"footnotes-list\">\n<li id=\"fn1\" class=\"footnote-item\"><p><a href=\"https://leetcode-cn.com/problems/jump-game/solution/tiao-yue-you-xi-by-leetcode/\" target=\"_blank\" rel=\"noopener\">Leetcode官方题解：跳跃游戏</a> <a href=\"#fnref1\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n<li id=\"fn2\" class=\"footnote-item\"><p><a href=\"https://leetcode-cn.com/problems/jump-game/solution/55-by-ikaruga/\" target=\"_blank\" rel=\"noopener\">【跳跃游戏】别想那么多，就挨着跳吧</a> <a href=\"#fnref2\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n</ol>\n</section>\n</div><script src=\"https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js\"></script><script>if (typeof lightGallery !== 'undefined') {\n        var options = {\n            selector: '.gallery-item'\n        };\n        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);\n        }</script>","more":"<h1 id=\"55-Jump-Game\"><a href=\"https://leetcode-cn.com/problems/jump-game/\" target=\"_blank\" rel=\"noopener\">55. Jump Game</a></h1>\n<p><a href=\"Greedy-Medium/image-20200301232408400.png\" title=\"image-20200301232408400\" class=\"gallery-item\"><img src=\"image-20200301232408400.png\" alt=\"image-20200301232408400\"></a></p>\n<h2 id=\"解法一：递归（贪心）\">解法一：递归（贪心）</h2>\n<ul>\n<li>\n<p><strong>思路</strong>：对于最后一个节点，寻找一个能到达它的节点，递归判断该节点，即为结果</p>\n</li>\n<li>\n<p><strong>递归结束条件</strong>：当已经找到第一个节点了，说明找到了抵达终点的通路，返回<code>ture</code></p>\n<pre><code class=\"language-java\">if(end&lt;=0)return true;\n</code></pre>\n</li>\n</ul>\n<h3 id=\"完整解法\">完整解法</h3>\n<pre><code class=\"language-java\">class Solution {\n    public boolean canJump(int[] nums) {\n        return jump(nums,nums.length-1);\n    }\n\n    public boolean jump(int[] nums,int end){\n        if(end&lt;=0)return true;\n        for(int i=end-1;i&gt;=0;i--){                   //从后往前找\n            if(nums[i]&gt;=end-i){return jump(nums,i);} //递归这个可达点\n        }\n        return false;                                //没找到，说明不可达\n    }\n}\n</code></pre>\n<h3 id=\"非递归贪心\">非递归贪心<sup class=\"footnote-ref\"><a href=\"#fn1\" id=\"fnref1\">[1]</a></sup></h3>\n<pre><code class=\"language-java\">public class Solution {\n    public boolean canJump(int[] nums) {\n        int lastPos = nums.length - 1;\n        for (int i = nums.length - 1; i &gt;= 0; i--) {\n            if (i + nums[i] &gt;= lastPos) {\n                lastPos = i;\n            }\n        }\n        return lastPos == 0;\n    }\n}\n</code></pre>\n<h2 id=\"解法二：遍历更新最远点\">解法二：遍历更新最远点<sup class=\"footnote-ref\"><a href=\"#fn2\" id=\"fnref2\">[2]</a></sup></h2>\n<ul>\n<li>\n<p><strong>思路</strong>：对于一个起跳点 i，它能到达的最远处为</p>\n<pre><code class=\"language-java\">max=i+nums[i];\n</code></pre>\n<p>可以以此作为依据，如果起跳点到达了原本无法跳到的地方，即</p>\n<pre><code class=\"language-java\">i&gt;max;\n</code></pre>\n<p>说明不可能到达终点</p>\n</li>\n</ul>\n<h3 id=\"完整解法-v2\">完整解法</h3>\n<pre><code class=\"language-java\">class Solution {\n    public boolean canJump(int[] nums) {\n        int max=0;\n        for(int i=0;i&lt;nums.length;i++){\n            if(i&gt;max)return false;       //根本没法跳到这\n            max=Math.max(max,i+nums[i]); //更新最远点\n        }\n        return true;\n    }\n}\n</code></pre>\n<h1 id=\"134-Gas-Station\"><a href=\"https://leetcode-cn.com/problems/gas-station/\" target=\"_blank\" rel=\"noopener\">134. Gas Station</a></h1>\n<p><a href=\"Greedy-Medium/image-20200303192025189.png\" title=\"image-20200303192025189\" class=\"gallery-item\"><img src=\"image-20200303192025189.png\" alt=\"image-20200303192025189\"></a></p>\n<h2 id=\"解法一：贪心\">解法一：贪心</h2>\n<p>暴力法是不可能的，要说dp这题也不是通过迭代求解的，而且这题看来像是单一原则求解的题</p>\n<p>那么考虑这个单一原则就是问题的关键了</p>\n<ul>\n<li>\n<p><strong>思路一</strong>：找净油量最多的点</p>\n<p>WA，这个做法错在于没有考虑到此时这个节点前的状态</p>\n</li>\n<li>\n<p><strong>思路二</strong>：净油量的基础上综合考虑从0开始到这个节点的位置时的剩余油量</p>\n<p>我们可以认为到达某一站时的剩余油量相对来说越少越好，因为总油量是固定的，因此剩余油量越少，说明前面的阻力越大，而为了环行一圈，我们肯定是认为阻力越小越好的，由此可以认为判定原则是</p>\n<pre><code class=\"language-java\">int earn=gas[i]-cost[i];    //该点出发的净油量\nres+=earn;                  //该点的相对阻力\nmax=Math.max(earn-res,max); //寻找 净油量-相对阻力 最大的节点，即为解\n</code></pre>\n</li>\n</ul>\n<h3 id=\"完整解法-v3\">完整解法</h3>\n<pre><code class=\"language-java\">class Solution {\n    public int canCompleteCircuit(int[] gas, int[] cost) {\n        if(gas.length==0)return -1;\n        int dst=0,max=Integer.MIN_VALUE,res=0;\n        for(int i=0;i&lt;gas.length;i++){\n            int earn=gas[i]-cost[i];\n            res+=earn;\n            if(max&lt;(max=Math.max(earn-res,max)) ){\n                dst=i;\n            }\n        }\n        return res&gt;=0?dst:-1;\n    }\n}\n</code></pre>\n<h1 id=\"376-Wiggle-Subsequence\"><a href=\"https://leetcode-cn.com/problems/wiggle-subsequence/\" target=\"_blank\" rel=\"noopener\">376. Wiggle Subsequence</a></h1>\n<p><a href=\"Greedy-Medium/image-20200303203333029.png\" title=\"image-20200303203333029\" class=\"gallery-item\"><img src=\"image-20200303203333029.png\" alt=\"image-20200303203333029\"></a></p>\n<h2 id=\"解法一：DP\">解法一：DP</h2>\n<ul>\n<li>\n<p><strong>思路</strong>：如果此次为上升，那么如果满足摆动序列的情况下，上一次应该是下降，反之同理</p>\n<pre><code class=\"language-java\">if(nums[i]-nums[i-1]&gt;0)\n    up=down+1;\nif(nums[i]-nums[i-1]&lt;0)\n    down=up+1;\n</code></pre>\n</li>\n<li>\n<p><strong>连续同向摆动</strong>：如果连续up，那么up始终只能保持down+1，反之亦然</p>\n</li>\n</ul>\n<h3 id=\"完整解法-v4\">完整解法</h3>\n<pre><code class=\"language-java\">class Solution {\n    public int wiggleMaxLength(int[] nums) {\n        if(nums.length&lt;=1)return nums.length;\n        int up=1,down=1;\n        for(int i=1;i&lt;nums.length;i++){\n            if(nums[i]-nums[i-1]&gt;0)\n                up=down+1;\n            if(nums[i]-nums[i-1]&lt;0)\n                down=up+1;\n        }\n        return Math.max(up,down);\n    }\n}\n</code></pre>\n<h1 id=\"402-Remove-K-Digits\"><a href=\"https://leetcode-cn.com/problems/remove-k-digits/\" target=\"_blank\" rel=\"noopener\">402. Remove K Digits</a></h1>\n<p><a href=\"Greedy-Medium/image-20200306003402169.png\" title=\"image-20200306003402169\" class=\"gallery-item\"><img src=\"image-20200306003402169.png\" alt=\"image-20200306003402169\"></a></p>\n<h2 id=\"解法一：递增栈\">解法一：递增栈</h2>\n<ul>\n<li>\n<p><strong>思路</strong>一：第一个思路是从左开始，谁大移除谁，但发现WA</p>\n</li>\n<li>\n<p><strong>思路二[官方题解]</strong>：谁大移除谁的问题在于，如果是个单调递增的序列，显然必须得先移除末尾的元素，由此发现移除时必须得<strong>跳过递增序列</strong>，也就是只有下一个元素小于上一个元素时，才会去删除，涉及到回溯问题，这里运用栈来解决</p>\n</li>\n<li>\n<p><strong>规则</strong>：如果新元素比栈内上一个元素小，就移除栈顶元素，这样解法就明确，剩下的就是如何拼凑答案，这里用LinkedList模拟栈，以便从栈底开始遍历元素</p>\n<pre><code class=\"language-java\">while(stack.size()&gt;0 &amp;&amp; k&gt;0 &amp;&amp;num.charAt(i)&lt;stack.getLast()){ \n    k--;\n    stack.removeLast(); //删掉突然减小的地方\n}\n</code></pre>\n</li>\n</ul>\n<h3 id=\"完整解法-v5\">完整解法</h3>\n<pre><code class=\"language-java\">class Solution {\n    public String removeKdigits(String num, int k) {\n        LinkedList&lt;Character&gt; stack=new LinkedList&lt;Character&gt;();\n        for(int i=0;i&lt;num.length();i++){\n            while(stack.size()&gt;0 &amp;&amp; k&gt;0 &amp;&amp;num.charAt(i)&lt;stack.getLast()){ \n                k--;\n                stack.removeLast();\n            }\n            stack.addLast(num.charAt(i));\n        }\n        for(int i=0;i&lt;k;i++){stack.removeLast();} //移除末尾剩余元素\n        \n        StringBuilder sb=new StringBuilder();        //构建解\n        while(!stack.isEmpty()){\n            sb.append(stack.removeFirst());\n        }\n        \n        int i=0;                                       \n        while(i&lt;sb.length() &amp;&amp; sb.charAt(i)=='0')i++; //去掉前导0\n        num=sb.substring(i);\n        if(num.length()==0)return &quot;0&quot;; //如果已经空了返回&quot;0&quot;\n        return num;\n    }\n}\n</code></pre>\n<h1 id=\"435-Non-overlapping-Intervals\"><a href=\"https://leetcode-cn.com/problems/non-overlapping-intervals/\" target=\"_blank\" rel=\"noopener\">435. Non-overlapping Intervals</a></h1>\n<p><a href=\"Greedy-Medium/image-20200523152704126.png\" title=\"image-20200523152704126\" class=\"gallery-item\"><img src=\"image-20200523152704126.png\" alt=\"image-20200523152704126\"></a></p>\n<h2 id=\"解法一：贪心-v2\">解法一：贪心</h2>\n<p>一开始以为是删掉区间大的那个，总是差一点，看答案发现应该删右区间大的那个，才能更好地保证不重叠，合理</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    int eraseOverlapIntervals(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) {\n        std::sort(intervals.begin(), intervals.end());\n        int res = 0, curr = 0;\n        for(int i = 1; i &lt; intervals.size(); i++) {\n            if(intervals[i][0] &lt; intervals[curr][1]) {\n                if(intervals[i][1] &lt; intervals[curr][1])\n                    curr = i;\n                ++res;\n            }\n            else curr = i;\n        }\n        return res;\n    }\n};\n</code></pre>\n<hr class=\"footnotes-sep\">\n<section class=\"footnotes\">\n<ol class=\"footnotes-list\">\n<li id=\"fn1\" class=\"footnote-item\"><p><a href=\"https://leetcode-cn.com/problems/jump-game/solution/tiao-yue-you-xi-by-leetcode/\" target=\"_blank\" rel=\"noopener\">Leetcode官方题解：跳跃游戏</a> <a href=\"#fnref1\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n<li id=\"fn2\" class=\"footnote-item\"><p><a href=\"https://leetcode-cn.com/problems/jump-game/solution/55-by-ikaruga/\" target=\"_blank\" rel=\"noopener\">【跳跃游戏】别想那么多，就挨着跳吧</a> <a href=\"#fnref2\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n</ol>\n</section>\n<script src=\"https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js\"></script><script>if (typeof lightGallery !== 'undefined') {\n        var options = {\n            selector: '.gallery-item'\n        };\n        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);\n        }</script>","categories":[{"name":"Algorithm","path":"api/categories/Algorithm.json"}],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"}]}