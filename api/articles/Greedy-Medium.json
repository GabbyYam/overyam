{"title":"Greedy-Medium","slug":"Greedy-Medium","date":"2020-03-01T15:22:41.000Z","updated":"2020-03-01T16:34:40.848Z","comments":true,"path":"api/articles/Greedy-Medium.json","excerpt":"Abstract：更新部分Medium难度Greedy相关题解","covers":["image-20200301232408400.png"],"content":"<link rel=\"stylesheet\" type=\"text/css\" href=\"https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css\"><div class=\".article-gallery\" <p><strong>Abstract</strong>：更新部分<code>Medium</code>难度<code>Greedy</code>相关题解<p></p>\n<a id=\"more\"></a>\n<h1 id=\"55-Jump-Game\"><a href=\"https://leetcode-cn.com/problems/jump-game/\" target=\"_blank\" rel=\"noopener\">55. Jump Game</a></h1>\n<p><a href=\"Greedy-Medium/image-20200301232408400.png\" title=\"image-20200301232408400\" class=\"gallery-item\"><img src=\"image-20200301232408400.png\" alt=\"image-20200301232408400\"></a></p>\n<h2 id=\"解法一：递归（贪心）\">解法一：递归（贪心）</h2>\n<ul>\n<li>\n<p><strong>思路</strong>：对于最后一个节点，寻找一个能到达它的节点，递归判断该节点，即为结果</p>\n</li>\n<li>\n<p><strong>递归结束条件</strong>：当已经找到第一个节点了，说明找到了抵达终点的通路，返回<code>ture</code></p>\n<pre><code class=\"language-java\">if(end&lt;=0)return true;\n</code></pre>\n</li>\n</ul>\n<h3 id=\"完整解法\">完整解法</h3>\n<pre><code class=\"language-java\">class Solution {\n    public boolean canJump(int[] nums) {\n        return jump(nums,nums.length-1);\n    }\n\n    public boolean jump(int[] nums,int end){\n        if(end&lt;=0)return true;\n        for(int i=end-1;i&gt;=0;i--){                   //从后往前找\n            if(nums[i]&gt;=end-i){return jump(nums,i);} //递归这个可达点\n        }\n        return false;                                //没找到，说明不可达\n    }\n}\n</code></pre>\n<h3 id=\"非递归贪心\">非递归贪心<sup class=\"footnote-ref\"><a href=\"#fn1\" id=\"fnref1\">[1]</a></sup></h3>\n<pre><code class=\"language-java\">public class Solution {\n    public boolean canJump(int[] nums) {\n        int lastPos = nums.length - 1;\n        for (int i = nums.length - 1; i &gt;= 0; i--) {\n            if (i + nums[i] &gt;= lastPos) {\n                lastPos = i;\n            }\n        }\n        return lastPos == 0;\n    }\n}\n</code></pre>\n<h2 id=\"解法二：遍历更新最远点\">解法二：遍历更新最远点<sup class=\"footnote-ref\"><a href=\"#fn2\" id=\"fnref2\">[2]</a></sup></h2>\n<ul>\n<li>\n<p><strong>思路</strong>：对于一个起跳点 i，它能到达的最远处为</p>\n<pre><code class=\"language-java\">max=i+nums[i];\n</code></pre>\n<p>可以以此作为依据，如果起跳点到达了原本无法跳到的地方，即</p>\n<pre><code class=\"language-java\">i&gt;max;\n</code></pre>\n<p>说明不可能到达终点</p>\n</li>\n</ul>\n<h3 id=\"完整解法-v2\">完整解法</h3>\n<pre><code class=\"language-java\">class Solution {\n    public boolean canJump(int[] nums) {\n        int max=0;\n        for(int i=0;i&lt;nums.length;i++){\n            if(i&gt;max)return false;       //根本没法跳到这\n            max=Math.max(max,i+nums[i]); //更新最远点\n        }\n        return true;\n    }\n}\n</code></pre>\n<hr class=\"footnotes-sep\">\n<section class=\"footnotes\">\n<ol class=\"footnotes-list\">\n<li id=\"fn1\" class=\"footnote-item\"><p><a href=\"https://leetcode-cn.com/problems/jump-game/solution/tiao-yue-you-xi-by-leetcode/\" target=\"_blank\" rel=\"noopener\">Leetcode官方题解：跳跃游戏</a> <a href=\"#fnref1\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n<li id=\"fn2\" class=\"footnote-item\"><p><a href=\"https://leetcode-cn.com/problems/jump-game/solution/55-by-ikaruga/\" target=\"_blank\" rel=\"noopener\">【跳跃游戏】别想那么多，就挨着跳吧</a> <a href=\"#fnref2\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n</ol>\n</section>\n</div><script src=\"https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js\"></script><script>if (typeof lightGallery !== 'undefined') {\n        var options = {\n            selector: '.gallery-item'\n        };\n        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);\n        }</script>","more":"<h1 id=\"55-Jump-Game\"><a href=\"https://leetcode-cn.com/problems/jump-game/\" target=\"_blank\" rel=\"noopener\">55. Jump Game</a></h1>\n<p><a href=\"Greedy-Medium/image-20200301232408400.png\" title=\"image-20200301232408400\" class=\"gallery-item\"><img src=\"image-20200301232408400.png\" alt=\"image-20200301232408400\"></a></p>\n<h2 id=\"解法一：递归（贪心）\">解法一：递归（贪心）</h2>\n<ul>\n<li>\n<p><strong>思路</strong>：对于最后一个节点，寻找一个能到达它的节点，递归判断该节点，即为结果</p>\n</li>\n<li>\n<p><strong>递归结束条件</strong>：当已经找到第一个节点了，说明找到了抵达终点的通路，返回<code>ture</code></p>\n<pre><code class=\"language-java\">if(end&lt;=0)return true;\n</code></pre>\n</li>\n</ul>\n<h3 id=\"完整解法\">完整解法</h3>\n<pre><code class=\"language-java\">class Solution {\n    public boolean canJump(int[] nums) {\n        return jump(nums,nums.length-1);\n    }\n\n    public boolean jump(int[] nums,int end){\n        if(end&lt;=0)return true;\n        for(int i=end-1;i&gt;=0;i--){                   //从后往前找\n            if(nums[i]&gt;=end-i){return jump(nums,i);} //递归这个可达点\n        }\n        return false;                                //没找到，说明不可达\n    }\n}\n</code></pre>\n<h3 id=\"非递归贪心\">非递归贪心<sup class=\"footnote-ref\"><a href=\"#fn1\" id=\"fnref1\">[1]</a></sup></h3>\n<pre><code class=\"language-java\">public class Solution {\n    public boolean canJump(int[] nums) {\n        int lastPos = nums.length - 1;\n        for (int i = nums.length - 1; i &gt;= 0; i--) {\n            if (i + nums[i] &gt;= lastPos) {\n                lastPos = i;\n            }\n        }\n        return lastPos == 0;\n    }\n}\n</code></pre>\n<h2 id=\"解法二：遍历更新最远点\">解法二：遍历更新最远点<sup class=\"footnote-ref\"><a href=\"#fn2\" id=\"fnref2\">[2]</a></sup></h2>\n<ul>\n<li>\n<p><strong>思路</strong>：对于一个起跳点 i，它能到达的最远处为</p>\n<pre><code class=\"language-java\">max=i+nums[i];\n</code></pre>\n<p>可以以此作为依据，如果起跳点到达了原本无法跳到的地方，即</p>\n<pre><code class=\"language-java\">i&gt;max;\n</code></pre>\n<p>说明不可能到达终点</p>\n</li>\n</ul>\n<h3 id=\"完整解法-v2\">完整解法</h3>\n<pre><code class=\"language-java\">class Solution {\n    public boolean canJump(int[] nums) {\n        int max=0;\n        for(int i=0;i&lt;nums.length;i++){\n            if(i&gt;max)return false;       //根本没法跳到这\n            max=Math.max(max,i+nums[i]); //更新最远点\n        }\n        return true;\n    }\n}\n</code></pre>\n<hr class=\"footnotes-sep\">\n<section class=\"footnotes\">\n<ol class=\"footnotes-list\">\n<li id=\"fn1\" class=\"footnote-item\"><p><a href=\"https://leetcode-cn.com/problems/jump-game/solution/tiao-yue-you-xi-by-leetcode/\" target=\"_blank\" rel=\"noopener\">Leetcode官方题解：跳跃游戏</a> <a href=\"#fnref1\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n<li id=\"fn2\" class=\"footnote-item\"><p><a href=\"https://leetcode-cn.com/problems/jump-game/solution/55-by-ikaruga/\" target=\"_blank\" rel=\"noopener\">【跳跃游戏】别想那么多，就挨着跳吧</a> <a href=\"#fnref2\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n</ol>\n</section>\n<script src=\"https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js\"></script><script>if (typeof lightGallery !== 'undefined') {\n        var options = {\n            selector: '.gallery-item'\n        };\n        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);\n        }</script>","categories":[{"name":"Algorithm","path":"api/categories/Algorithm.json"}],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"}]}