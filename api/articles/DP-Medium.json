{"title":"DP-Medium","slug":"DP-Medium","date":"2020-02-28T13:15:28.000Z","updated":"2020-03-01T15:23:12.865Z","comments":true,"path":"api/articles/DP-Medium.json","excerpt":"Abstract：更新部分Medium难度DP相关题解","covers":["image-20200228211822543.png","image-20200228222649924.png","image-20200229205630824.png","image-20200229234943330.png","image-20200301221358648.png"],"content":"<link rel=\"stylesheet\" type=\"text/css\" href=\"https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css\"><div class=\".article-gallery\" <p><strong>Abstract</strong>：更新部分<code>Medium</code>难度<code>DP</code>相关题解<p></p>\n<a id=\"more\"></a>\n<h1 id=\"63-Unique-Paths-II\"><a href=\"https://leetcode-cn.com/problems/unique-paths-ii/\" target=\"_blank\" rel=\"noopener\">63. Unique Paths II</a></h1>\n<p><a href=\"DP-Medium/image-20200228211822543.png\" title=\"image-20200228211822543\" class=\"gallery-item\"><img src=\"image-20200228211822543.png\" alt=\"image-20200228211822543\"></a></p>\n<h2 id=\"解法一：DP\">解法一：DP</h2>\n<p>这道题和Unique Path 1几乎相同，唯一的区别是，当某一格是障碍物时，uniquePath=0，即转移方程为</p>\n<pre><code class=\"language-java\">dp[i][j]=(obstacleGrid[i-1][j-1]==1)?0:  //如果有障碍物直接为0\n    (i==1&amp;j==1)?1:                       //起始为1\n    dp[i-1][j]+dp[i][j-1];               //取左和上方格子之和\n</code></pre>\n<p>完整解法如下</p>\n<pre><code class=\"language-java\">class Solution {\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\n        if(obstacleGrid==null || obstacleGrid.length==0)return 0; //特殊情况\n        int m=obstacleGrid.length;\n        int n=obstacleGrid[0].length;\n        int[][] dp=new int[m+1][n+1]; //数组开大一圈作为辅助，这样可以避免边界判断\n        for(int i=1;i&lt;m+1;i++){\n            for(int j=1;j&lt;n+1;j++){\n                dp[i][j]=(obstacleGrid[i-1][j-1]==1)?0:\n                (i==1&amp;j==1)?1:\n                dp[i-1][j]+dp[i][j-1];\n            }\n        }\n        return dp[m][n]; //dp[m][n]即为最终结果\n    }\n}\n</code></pre>\n<p>​</p>\n<h1 id=\"64-Minimum-Path-Sum\"><a href=\"https://leetcode-cn.com/problems/minimum-path-sum/\" target=\"_blank\" rel=\"noopener\">64. Minimum Path Sum</a></h1>\n<p><a href=\"DP-Medium/image-20200228222649924.png\" title=\"image-20200228222649924\" class=\"gallery-item\"><img src=\"image-20200228222649924.png\" alt=\"image-20200228222649924\"></a></p>\n<h2 id=\"解法一：DP（不需要额外空间）\">解法一：DP（不需要额外空间）</h2>\n<p>和上题还是类似的思路，但是注意上边界和左边界上的值比较坑，需要特别地初始化</p>\n<p>需要注意的是，如果使用辅助空间，那么<strong>辅助格子</strong>和<strong>grid</strong>上的<strong>状态转移方程不能统一！！</strong></p>\n<p>因此我这里先对边界值特殊处理，以避免后续麻烦的<strong>多重判断</strong></p>\n<pre><code class=\"language-java\">class Solution {\n    public int minPathSum(int[][] grid) {\n        //if(grid.length==0)return 0;\n        int m=grid.length,n=grid[0].length;\n        for(int i=1;i&lt;m;i++)grid[i][0]+=grid[i-1][0]; //只有一条路可走\n        for(int i=1;i&lt;n;i++)grid[0][i]+=grid[0][i-1]; //同上\n        for(int i=1;i&lt;m;i++){\n            for(int j=1;j&lt;n;j++){\n                grid[i][j]+=Math.min(grid[i-1][j],grid[i][j-1]); //更新最小路径\n            }\n        }\n        return grid[m-1][n-1];\n    }\n}\n</code></pre>\n<p>​</p>\n<h1 id=\"⭐️5-Longest-Palindromic-Substring\">⭐️<a href=\"https://leetcode-cn.com/problems/longest-palindromic-substring/\" target=\"_blank\" rel=\"noopener\">5. Longest Palindromic Substring</a></h1>\n<p><a href=\"DP-Medium/image-20200229205630824.png\" title=\"image-20200229205630824\" class=\"gallery-item\"><img src=\"image-20200229205630824.png\" alt=\"image-20200229205630824\"></a></p>\n<h2 id=\"解法一：中心扩展（其实就是DP嘛）\">解法一：中心扩展（其实就是DP嘛）</h2>\n<ul>\n<li>\n<p><strong>思路</strong>：对于形如“aba”或“baab”的字符串我们可以通过左右+1的操作来复用之前的计算结果，即</p>\n<pre><code class=\"language-java\">dp(i,j)=(dp(i-1,j+1) &amp;&amp; s.charAt(i)==s.charAt(j));\n</code></pre>\n</li>\n<li>\n<p><strong>要点</strong>：注意分开讨论奇偶长度回文，目的是为了统一寻找回文的标准，如果“abba”当成奇数长串去处理的话就出大麻烦了，另外要注意的是，得到最大回文长度后，如何通过中心元素位置，计算出start和end</p>\n<pre><code class=\"language-java\">//假设max为最大回文长度\nlen=max-1;\nstart=i-(len-1)/2;\nend=i+len/2;\n</code></pre>\n</li>\n<li>\n<p>完整解法如下</p>\n</li>\n</ul>\n<pre><code class=\"language-java\">class Solution {\n    public String longestPalindrome(String s) {\n        if(s.length()&lt;=1)return s;\n        int start=0,end=0;\n        for(int i=0;i&lt;s.length();i++){\n            int max=Math.max(centerExpand(s,i,i),centerExpand(s,i,i+1)); //两种中心\n            if(max&gt;end-start){\n                start=i-(max-1)/2;\n                end=i+max/2;\n            }\n        }\n        return s.substring(start,end+1);\n    }\n\n    public int centerExpand(String s,int lo,int hi){ //用来找到某一中心的最长回文串\n        while(lo&gt;=0 &amp;&amp; hi&lt;s.length() &amp;&amp; s.charAt(lo)==s.charAt(hi)){lo--;hi++;}\n        return hi-lo-1;\n    }\n}\n</code></pre>\n<h2 id=\"解法二：Manacher-算法\">解法二：Manacher 算法</h2>\n<p>非常精巧的算法，时间复杂度O(n)，等好好消化理解了再贴上来</p>\n<p>​</p>\n<h1 id=\"⭐️91-Decode-Ways\">⭐️<a href=\"https://leetcode-cn.com/problems/decode-ways/\" target=\"_blank\" rel=\"noopener\">91. Decode Ways</a></h1>\n<p><a href=\"DP-Medium/image-20200229234943330.png\" title=\"image-20200229234943330\" class=\"gallery-item\"><img src=\"image-20200229234943330.png\" alt=\"image-20200229234943330\"></a></p>\n<h2 id=\"解法一：DP-v2\">解法一：DP</h2>\n<p>比较要求细心的一道题，必须关注以下几种<strong>特殊情况</strong>：</p>\n<ul>\n<li>\n<p>当出现诸如&quot;30&quot;,&quot;40&quot;等时，解码失败，直接<code>return 0</code></p>\n</li>\n<li>\n<p>&quot;10&quot;和&quot;20&quot;只能记一种，因为“0”无法解码</p>\n</li>\n<li>\n<p>其余1-26之间的数，和前一次结果叠加，相当于 “xxxab” + “xxxxb” 的结果</p>\n</li>\n</ul>\n<pre><code class=\"language-java\">class Solution {\n    public int numDecodings(String s) {\n        if( s.charAt(0)=='0') return 0;\n        int pre=1,curr=1;\n        for(int i=1;i&lt;s.length();i++){\n            int tmp = curr;\n            if (s.charAt(i) == '0')\n                if (s.charAt(i-1) == '1' || s.charAt(i-1) == '2') curr = pre;\n            else return 0;\n            else if (s.charAt(i-1) == '1' || s.charAt(i-1) == '2' &amp;&amp; s.charAt(i) &gt;= '1' &amp;&amp; s.charAt(i) &lt;= '6')\n                curr = curr + pre;\n            pre = tmp;\n        }\n        return curr;\n    }\n}\n</code></pre>\n<h1 id=\"139-Word-Break\"><a href=\"https://leetcode-cn.com/problems/word-break/\" target=\"_blank\" rel=\"noopener\">139. Word Break</a></h1>\n<p><a href=\"DP-Medium/image-20200301221358648.png\" title=\"image-20200301221358648\" class=\"gallery-item\"><img src=\"image-20200301221358648.png\" alt=\"image-20200301221358648\"></a></p>\n<ul>\n<li><strong>要点</strong>：用<code>HashSet</code>来判断是否在字典中存在</li>\n</ul>\n<h2 id=\"解法一：记忆化递归\">解法一：记忆化递归</h2>\n<ul>\n<li><strong>思路</strong>：可以分割为两个子串，左边必定是其中一个单词（如果找不到，说明不存在），接着递归求解右子串</li>\n</ul>\n<pre><code class=\"language-java\">class Solution {\n    public boolean wordBreak(String s, List&lt;String&gt; wordDict) {\n        return wordBreakWithMemo(s,new HashSet&lt;String&gt;(wordDict),0,new Boolean[s.length()]);\n    }\n\n    public boolean wordBreakWithMemo(String s,Set&lt;String&gt; set,int start,Boolean[] memo){\n        if(start==s.length())return true;\n        if(memo[start]!=null)return memo[start];\n        for(int i=start;i&lt;=s.length();i++){\n            if(set.contains(s.substring(start,i)) &amp;&amp; wordBreakWithMemo(s,set,i,memo))\n                return memo[start]=true;\n        }\n        return memo[start]=false;\n    }\n}\n</code></pre>\n<h2 id=\"解法二：DP\">解法二：DP</h2>\n<p>“<strong>可以记忆化递归的大多都可以DP解决</strong>”（没错，就是我说的）</p>\n<pre><code class=\"language-java\">//如果截止j位置满足条件，那么只要set.contains(s.substring(j,i)),则说明截止i也满足条件\n//即转移方程如下\nif( dp[j] &amp;&amp; set.contains(s.substring(j,i))){dp[i]=true;}\n</code></pre>\n<p>因此可以改写为以下形式</p>\n<pre><code class=\"language-java\">class Solution {\n    public boolean wordBreak(String s, List&lt;String&gt; wordDict) {\n        Set&lt;String&gt; set=new HashSet&lt;String&gt;(wordDict);\n        boolean[] dp=new boolean[s.length()+1];\n        dp[0]=true;\t\t\t\t\t\t\t\t\t\n        for(int i=1;i&lt;=s.length();i++){\n            for(int j=0;j&lt;i;j++){\n                if( dp[j] &amp;&amp; set.contains(s.substring(j,i)))\n                    dp[i]=true;\n            }\n        }\n        return dp[s.length()];\n    }\n}\n</code></pre>\n</div><script src=\"https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js\"></script><script>if (typeof lightGallery !== 'undefined') {\n        var options = {\n            selector: '.gallery-item'\n        };\n        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);\n        }</script>","more":"<h1 id=\"63-Unique-Paths-II\"><a href=\"https://leetcode-cn.com/problems/unique-paths-ii/\" target=\"_blank\" rel=\"noopener\">63. Unique Paths II</a></h1>\n<p><a href=\"DP-Medium/image-20200228211822543.png\" title=\"image-20200228211822543\" class=\"gallery-item\"><img src=\"image-20200228211822543.png\" alt=\"image-20200228211822543\"></a></p>\n<h2 id=\"解法一：DP\">解法一：DP</h2>\n<p>这道题和Unique Path 1几乎相同，唯一的区别是，当某一格是障碍物时，uniquePath=0，即转移方程为</p>\n<pre><code class=\"language-java\">dp[i][j]=(obstacleGrid[i-1][j-1]==1)?0:  //如果有障碍物直接为0\n    (i==1&amp;j==1)?1:                       //起始为1\n    dp[i-1][j]+dp[i][j-1];               //取左和上方格子之和\n</code></pre>\n<p>完整解法如下</p>\n<pre><code class=\"language-java\">class Solution {\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\n        if(obstacleGrid==null || obstacleGrid.length==0)return 0; //特殊情况\n        int m=obstacleGrid.length;\n        int n=obstacleGrid[0].length;\n        int[][] dp=new int[m+1][n+1]; //数组开大一圈作为辅助，这样可以避免边界判断\n        for(int i=1;i&lt;m+1;i++){\n            for(int j=1;j&lt;n+1;j++){\n                dp[i][j]=(obstacleGrid[i-1][j-1]==1)?0:\n                (i==1&amp;j==1)?1:\n                dp[i-1][j]+dp[i][j-1];\n            }\n        }\n        return dp[m][n]; //dp[m][n]即为最终结果\n    }\n}\n</code></pre>\n<p>​</p>\n<h1 id=\"64-Minimum-Path-Sum\"><a href=\"https://leetcode-cn.com/problems/minimum-path-sum/\" target=\"_blank\" rel=\"noopener\">64. Minimum Path Sum</a></h1>\n<p><a href=\"DP-Medium/image-20200228222649924.png\" title=\"image-20200228222649924\" class=\"gallery-item\"><img src=\"image-20200228222649924.png\" alt=\"image-20200228222649924\"></a></p>\n<h2 id=\"解法一：DP（不需要额外空间）\">解法一：DP（不需要额外空间）</h2>\n<p>和上题还是类似的思路，但是注意上边界和左边界上的值比较坑，需要特别地初始化</p>\n<p>需要注意的是，如果使用辅助空间，那么<strong>辅助格子</strong>和<strong>grid</strong>上的<strong>状态转移方程不能统一！！</strong></p>\n<p>因此我这里先对边界值特殊处理，以避免后续麻烦的<strong>多重判断</strong></p>\n<pre><code class=\"language-java\">class Solution {\n    public int minPathSum(int[][] grid) {\n        //if(grid.length==0)return 0;\n        int m=grid.length,n=grid[0].length;\n        for(int i=1;i&lt;m;i++)grid[i][0]+=grid[i-1][0]; //只有一条路可走\n        for(int i=1;i&lt;n;i++)grid[0][i]+=grid[0][i-1]; //同上\n        for(int i=1;i&lt;m;i++){\n            for(int j=1;j&lt;n;j++){\n                grid[i][j]+=Math.min(grid[i-1][j],grid[i][j-1]); //更新最小路径\n            }\n        }\n        return grid[m-1][n-1];\n    }\n}\n</code></pre>\n<p>​</p>\n<h1 id=\"⭐️5-Longest-Palindromic-Substring\">⭐️<a href=\"https://leetcode-cn.com/problems/longest-palindromic-substring/\" target=\"_blank\" rel=\"noopener\">5. Longest Palindromic Substring</a></h1>\n<p><a href=\"DP-Medium/image-20200229205630824.png\" title=\"image-20200229205630824\" class=\"gallery-item\"><img src=\"image-20200229205630824.png\" alt=\"image-20200229205630824\"></a></p>\n<h2 id=\"解法一：中心扩展（其实就是DP嘛）\">解法一：中心扩展（其实就是DP嘛）</h2>\n<ul>\n<li>\n<p><strong>思路</strong>：对于形如“aba”或“baab”的字符串我们可以通过左右+1的操作来复用之前的计算结果，即</p>\n<pre><code class=\"language-java\">dp(i,j)=(dp(i-1,j+1) &amp;&amp; s.charAt(i)==s.charAt(j));\n</code></pre>\n</li>\n<li>\n<p><strong>要点</strong>：注意分开讨论奇偶长度回文，目的是为了统一寻找回文的标准，如果“abba”当成奇数长串去处理的话就出大麻烦了，另外要注意的是，得到最大回文长度后，如何通过中心元素位置，计算出start和end</p>\n<pre><code class=\"language-java\">//假设max为最大回文长度\nlen=max-1;\nstart=i-(len-1)/2;\nend=i+len/2;\n</code></pre>\n</li>\n<li>\n<p>完整解法如下</p>\n</li>\n</ul>\n<pre><code class=\"language-java\">class Solution {\n    public String longestPalindrome(String s) {\n        if(s.length()&lt;=1)return s;\n        int start=0,end=0;\n        for(int i=0;i&lt;s.length();i++){\n            int max=Math.max(centerExpand(s,i,i),centerExpand(s,i,i+1)); //两种中心\n            if(max&gt;end-start){\n                start=i-(max-1)/2;\n                end=i+max/2;\n            }\n        }\n        return s.substring(start,end+1);\n    }\n\n    public int centerExpand(String s,int lo,int hi){ //用来找到某一中心的最长回文串\n        while(lo&gt;=0 &amp;&amp; hi&lt;s.length() &amp;&amp; s.charAt(lo)==s.charAt(hi)){lo--;hi++;}\n        return hi-lo-1;\n    }\n}\n</code></pre>\n<h2 id=\"解法二：Manacher-算法\">解法二：Manacher 算法</h2>\n<p>非常精巧的算法，时间复杂度O(n)，等好好消化理解了再贴上来</p>\n<p>​</p>\n<h1 id=\"⭐️91-Decode-Ways\">⭐️<a href=\"https://leetcode-cn.com/problems/decode-ways/\" target=\"_blank\" rel=\"noopener\">91. Decode Ways</a></h1>\n<p><a href=\"DP-Medium/image-20200229234943330.png\" title=\"image-20200229234943330\" class=\"gallery-item\"><img src=\"image-20200229234943330.png\" alt=\"image-20200229234943330\"></a></p>\n<h2 id=\"解法一：DP-v2\">解法一：DP</h2>\n<p>比较要求细心的一道题，必须关注以下几种<strong>特殊情况</strong>：</p>\n<ul>\n<li>\n<p>当出现诸如&quot;30&quot;,&quot;40&quot;等时，解码失败，直接<code>return 0</code></p>\n</li>\n<li>\n<p>&quot;10&quot;和&quot;20&quot;只能记一种，因为“0”无法解码</p>\n</li>\n<li>\n<p>其余1-26之间的数，和前一次结果叠加，相当于 “xxxab” + “xxxxb” 的结果</p>\n</li>\n</ul>\n<pre><code class=\"language-java\">class Solution {\n    public int numDecodings(String s) {\n        if( s.charAt(0)=='0') return 0;\n        int pre=1,curr=1;\n        for(int i=1;i&lt;s.length();i++){\n            int tmp = curr;\n            if (s.charAt(i) == '0')\n                if (s.charAt(i-1) == '1' || s.charAt(i-1) == '2') curr = pre;\n            else return 0;\n            else if (s.charAt(i-1) == '1' || s.charAt(i-1) == '2' &amp;&amp; s.charAt(i) &gt;= '1' &amp;&amp; s.charAt(i) &lt;= '6')\n                curr = curr + pre;\n            pre = tmp;\n        }\n        return curr;\n    }\n}\n</code></pre>\n<h1 id=\"139-Word-Break\"><a href=\"https://leetcode-cn.com/problems/word-break/\" target=\"_blank\" rel=\"noopener\">139. Word Break</a></h1>\n<p><a href=\"DP-Medium/image-20200301221358648.png\" title=\"image-20200301221358648\" class=\"gallery-item\"><img src=\"image-20200301221358648.png\" alt=\"image-20200301221358648\"></a></p>\n<ul>\n<li><strong>要点</strong>：用<code>HashSet</code>来判断是否在字典中存在</li>\n</ul>\n<h2 id=\"解法一：记忆化递归\">解法一：记忆化递归</h2>\n<ul>\n<li><strong>思路</strong>：可以分割为两个子串，左边必定是其中一个单词（如果找不到，说明不存在），接着递归求解右子串</li>\n</ul>\n<pre><code class=\"language-java\">class Solution {\n    public boolean wordBreak(String s, List&lt;String&gt; wordDict) {\n        return wordBreakWithMemo(s,new HashSet&lt;String&gt;(wordDict),0,new Boolean[s.length()]);\n    }\n\n    public boolean wordBreakWithMemo(String s,Set&lt;String&gt; set,int start,Boolean[] memo){\n        if(start==s.length())return true;\n        if(memo[start]!=null)return memo[start];\n        for(int i=start;i&lt;=s.length();i++){\n            if(set.contains(s.substring(start,i)) &amp;&amp; wordBreakWithMemo(s,set,i,memo))\n                return memo[start]=true;\n        }\n        return memo[start]=false;\n    }\n}\n</code></pre>\n<h2 id=\"解法二：DP\">解法二：DP</h2>\n<p>“<strong>可以记忆化递归的大多都可以DP解决</strong>”（没错，就是我说的）</p>\n<pre><code class=\"language-java\">//如果截止j位置满足条件，那么只要set.contains(s.substring(j,i)),则说明截止i也满足条件\n//即转移方程如下\nif( dp[j] &amp;&amp; set.contains(s.substring(j,i))){dp[i]=true;}\n</code></pre>\n<p>因此可以改写为以下形式</p>\n<pre><code class=\"language-java\">class Solution {\n    public boolean wordBreak(String s, List&lt;String&gt; wordDict) {\n        Set&lt;String&gt; set=new HashSet&lt;String&gt;(wordDict);\n        boolean[] dp=new boolean[s.length()+1];\n        dp[0]=true;\t\t\t\t\t\t\t\t\t\n        for(int i=1;i&lt;=s.length();i++){\n            for(int j=0;j&lt;i;j++){\n                if( dp[j] &amp;&amp; set.contains(s.substring(j,i)))\n                    dp[i]=true;\n            }\n        }\n        return dp[s.length()];\n    }\n}\n</code></pre>\n<script src=\"https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js\"></script><script>if (typeof lightGallery !== 'undefined') {\n        var options = {\n            selector: '.gallery-item'\n        };\n        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);\n        }</script>","categories":[{"name":"Algorithm","path":"api/categories/Algorithm.json"}],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"}]}