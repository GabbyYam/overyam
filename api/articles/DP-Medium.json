{"title":"DP-Medium","slug":"DP-Medium","date":"2020-02-28T13:15:28.000Z","updated":"2020-05-14T13:19:13.835Z","comments":true,"path":"api/articles/DP-Medium.json","excerpt":"Abstract：更新部分Medium难度DP相关题解","covers":["image-20200228211822543.png","image-20200228222649924.png","image-20200229205630824.png","image-20200229234943330.png","image-20200301221358648.png","image-20200505150432163.png","image-20200506175441330.png","image-20200514133707446.png","image-20200514160149449.png","image-20200514160200566.png","image-20200514163832672.png","image-20200514180330408.png"],"content":"<link rel=\"stylesheet\" type=\"text/css\" href=\"https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css\"><div class=\".article-gallery\" <p><strong>Abstract</strong>：更新部分<code>Medium</code>难度<code>DP</code>相关题解<p></p>\n<a id=\"more\"></a>\n<h1 id=\"63-Unique-Paths-II\"><a href=\"https://leetcode-cn.com/problems/unique-paths-ii/\" target=\"_blank\" rel=\"noopener\">63. Unique Paths II</a></h1>\n<p><a href=\"DP-Medium/image-20200228211822543.png\" title=\"image-20200228211822543\" class=\"gallery-item\"><img src=\"image-20200228211822543.png\" alt=\"image-20200228211822543\"></a></p>\n<h2 id=\"解法一：DP\">解法一：DP</h2>\n<p>这道题和Unique Path 1几乎相同，唯一的区别是，当某一格是障碍物时，uniquePath=0，即转移方程为</p>\n<pre><code class=\"language-java\">dp[i][j]=(obstacleGrid[i-1][j-1]==1)?0:  //如果有障碍物直接为0\n    (i==1&amp;j==1)?1:                       //起始为1\n    dp[i-1][j]+dp[i][j-1];               //取左和上方格子之和\n</code></pre>\n<p>完整解法如下</p>\n<pre><code class=\"language-java\">class Solution {\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\n        if(obstacleGrid==null || obstacleGrid.length==0)return 0; //特殊情况\n        int m=obstacleGrid.length;\n        int n=obstacleGrid[0].length;\n        int[][] dp=new int[m+1][n+1]; //数组开大一圈作为辅助，这样可以避免边界判断\n        for(int i=1;i&lt;m+1;i++){\n            for(int j=1;j&lt;n+1;j++){\n                dp[i][j]=(obstacleGrid[i-1][j-1]==1)?0:\n                (i==1&amp;j==1)?1:\n                dp[i-1][j]+dp[i][j-1];\n            }\n        }\n        return dp[m][n]; //dp[m][n]即为最终结果\n    }\n}\n</code></pre>\n<p>​</p>\n<h1 id=\"64-Minimum-Path-Sum\"><a href=\"https://leetcode-cn.com/problems/minimum-path-sum/\" target=\"_blank\" rel=\"noopener\">64. Minimum Path Sum</a></h1>\n<p><a href=\"DP-Medium/image-20200228222649924.png\" title=\"image-20200228222649924\" class=\"gallery-item\"><img src=\"image-20200228222649924.png\" alt=\"image-20200228222649924\"></a></p>\n<h2 id=\"解法一：DP（不需要额外空间）\">解法一：DP（不需要额外空间）</h2>\n<p>和上题还是类似的思路，但是注意上边界和左边界上的值比较坑，需要特别地初始化</p>\n<p>需要注意的是，如果使用辅助空间，那么<strong>辅助格子</strong>和<strong>grid</strong>上的<strong>状态转移方程不能统一！！</strong></p>\n<p>因此我这里先对边界值特殊处理，以避免后续麻烦的<strong>多重判断</strong></p>\n<pre><code class=\"language-java\">class Solution {\n    public int minPathSum(int[][] grid) {\n        //if(grid.length==0)return 0;\n        int m=grid.length,n=grid[0].length;\n        for(int i=1;i&lt;m;i++)grid[i][0]+=grid[i-1][0]; //只有一条路可走\n        for(int i=1;i&lt;n;i++)grid[0][i]+=grid[0][i-1]; //同上\n        for(int i=1;i&lt;m;i++){\n            for(int j=1;j&lt;n;j++){\n                grid[i][j]+=Math.min(grid[i-1][j],grid[i][j-1]); //更新最小路径\n            }\n        }\n        return grid[m-1][n-1];\n    }\n}\n</code></pre>\n<p>​</p>\n<h1 id=\"⭐️5-Longest-Palindromic-Substring\">⭐️<a href=\"https://leetcode-cn.com/problems/longest-palindromic-substring/\" target=\"_blank\" rel=\"noopener\">5. Longest Palindromic Substring</a></h1>\n<p><a href=\"DP-Medium/image-20200229205630824.png\" title=\"image-20200229205630824\" class=\"gallery-item\"><img src=\"image-20200229205630824.png\" alt=\"image-20200229205630824\"></a></p>\n<h2 id=\"解法一：中心扩展（其实就是DP嘛）\">解法一：中心扩展（其实就是DP嘛）</h2>\n<ul>\n<li>\n<p><strong>思路</strong>：对于形如“aba”或“baab”的字符串我们可以通过左右+1的操作来复用之前的计算结果，即</p>\n<pre><code class=\"language-java\">dp(i,j)=(dp(i-1,j+1) &amp;&amp; s.charAt(i)==s.charAt(j));\n</code></pre>\n</li>\n<li>\n<p><strong>要点</strong>：注意分开讨论奇偶长度回文，目的是为了统一寻找回文的标准，如果“abba”当成奇数长串去处理的话就出大麻烦了，另外要注意的是，得到最大回文长度后，如何通过中心元素位置，计算出start和end</p>\n<pre><code class=\"language-java\">//假设max为最大回文长度\nlen=max-1;\nstart=i-(len-1)/2;\nend=i+len/2;\n</code></pre>\n</li>\n<li>\n<p>完整解法如下</p>\n</li>\n</ul>\n<pre><code class=\"language-java\">class Solution {\n    public String longestPalindrome(String s) {\n        if(s.length()&lt;=1)return s;\n        int start=0,end=0;\n        for(int i=0;i&lt;s.length();i++){\n            int max=Math.max(centerExpand(s,i,i),centerExpand(s,i,i+1)); //两种中心\n            if(max&gt;end-start){\n                start=i-(max-1)/2;\n                end=i+max/2;\n            }\n        }\n        return s.substring(start,end+1);\n    }\n\n    public int centerExpand(String s,int lo,int hi){ //用来找到某一中心的最长回文串\n        while(lo&gt;=0 &amp;&amp; hi&lt;s.length() &amp;&amp; s.charAt(lo)==s.charAt(hi)){lo--;hi++;}\n        return hi-lo-1;\n    }\n}\n</code></pre>\n<h2 id=\"解法二：Manacher-算法\">解法二：Manacher 算法</h2>\n<p>非常精巧的算法，时间复杂度O(n)，等好好消化理解了再贴上来</p>\n<p>​</p>\n<h1 id=\"⭐️91-Decode-Ways\">⭐️<a href=\"https://leetcode-cn.com/problems/decode-ways/\" target=\"_blank\" rel=\"noopener\">91. Decode Ways</a></h1>\n<p><a href=\"DP-Medium/image-20200229234943330.png\" title=\"image-20200229234943330\" class=\"gallery-item\"><img src=\"image-20200229234943330.png\" alt=\"image-20200229234943330\"></a></p>\n<h2 id=\"解法一：DP-v2\">解法一：DP</h2>\n<p>比较要求细心的一道题，必须关注以下几种<strong>特殊情况</strong>：</p>\n<ul>\n<li>\n<p>当出现诸如&quot;30&quot;,&quot;40&quot;等时，解码失败，直接<code>return 0</code></p>\n</li>\n<li>\n<p>&quot;10&quot;和&quot;20&quot;只能记一种，因为“0”无法解码</p>\n</li>\n<li>\n<p>其余1-26之间的数，和前一次结果叠加，相当于 “xxxab” + “xxxxb” 的结果</p>\n</li>\n</ul>\n<pre><code class=\"language-java\">class Solution {\n    public int numDecodings(String s) {\n        if( s.charAt(0)=='0') return 0;\n        int pre=1,curr=1;\n        for(int i=1;i&lt;s.length();i++){\n            int tmp = curr;\n            if (s.charAt(i) == '0')\n                if (s.charAt(i-1) == '1' || s.charAt(i-1) == '2') curr = pre;\n            else return 0;\n            else if (s.charAt(i-1) == '1' || s.charAt(i-1) == '2' &amp;&amp; s.charAt(i) &gt;= '1' &amp;&amp; s.charAt(i) &lt;= '6')\n                curr = curr + pre;\n            pre = tmp;\n        }\n        return curr;\n    }\n}\n</code></pre>\n<h1 id=\"139-Word-Break\"><a href=\"https://leetcode-cn.com/problems/word-break/\" target=\"_blank\" rel=\"noopener\">139. Word Break</a></h1>\n<p><a href=\"DP-Medium/image-20200301221358648.png\" title=\"image-20200301221358648\" class=\"gallery-item\"><img src=\"image-20200301221358648.png\" alt=\"image-20200301221358648\"></a></p>\n<ul>\n<li><strong>要点</strong>：用<code>HashSet</code>来判断是否在字典中存在</li>\n</ul>\n<h2 id=\"解法一：记忆化递归\">解法一：记忆化递归</h2>\n<ul>\n<li><strong>思路</strong>：可以分割为两个子串，左边必定是其中一个单词（如果找不到，说明不存在），接着递归求解右子串</li>\n</ul>\n<pre><code class=\"language-java\">class Solution {\n    public boolean wordBreak(String s, List&lt;String&gt; wordDict) {\n        return wordBreakWithMemo(s,new HashSet&lt;String&gt;(wordDict),0,new Boolean[s.length()]);\n    }\n\n    public boolean wordBreakWithMemo(String s,Set&lt;String&gt; set,int start,Boolean[] memo){\n        if(start==s.length())return true;\n        if(memo[start]!=null)return memo[start];\n        for(int i=start;i&lt;=s.length();i++){\n            if(set.contains(s.substring(start,i)) &amp;&amp; wordBreakWithMemo(s,set,i,memo))\n                return memo[start]=true;\n        }\n        return memo[start]=false;\n    }\n}\n</code></pre>\n<h2 id=\"解法二：DP\">解法二：DP</h2>\n<p>“<strong>可以记忆化递归的大多都可以DP解决</strong>”（没错，就是我说的）</p>\n<pre><code class=\"language-java\">//如果截止j位置满足条件，那么只要set.contains(s.substring(j,i)),则说明截止i也满足条件\n//即转移方程如下\nif( dp[j] &amp;&amp; set.contains(s.substring(j,i))){dp[i]=true;}\n</code></pre>\n<p>因此可以改写为以下形式</p>\n<pre><code class=\"language-java\">class Solution {\n    public boolean wordBreak(String s, List&lt;String&gt; wordDict) {\n        Set&lt;String&gt; set=new HashSet&lt;String&gt;(wordDict);\n        boolean[] dp=new boolean[s.length()+1];\n        dp[0]=true;\t\t\t\t\t\t\t\t\t\n        for(int i=1;i&lt;=s.length();i++){\n            for(int j=0;j&lt;i;j++){\n                if( dp[j] &amp;&amp; set.contains(s.substring(j,i)))\n                    dp[i]=true;\n            }\n        }\n        return dp[s.length()];\n    }\n}\n</code></pre>\n<h1 id=\"120-Triangle\"><a href=\"https://leetcode-cn.com/problems/triangle/\" target=\"_blank\" rel=\"noopener\">120. Triangle</a></h1>\n<p><a href=\"DP-Medium/image-20200505150432163.png\" title=\"image-20200505150432163\" class=\"gallery-item\"><img src=\"image-20200505150432163.png\" alt=\"image-20200505150432163\"></a></p>\n<h2 id=\"解法一：直接递归dfs\">解法一：直接递归dfs</h2>\n<p>应该可以，但是超时了</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    int minimumTotal(vector&lt;vector&lt;int&gt;&gt;&amp; triangle) {\n        if(triangle.empty()) return 0;\n        return getMin(triangle, 0, 0, 0);\n    }\n\n    int getMin(vector&lt;vector&lt;int&gt;&gt;&amp; triangle, int level, int idx, int sum) {\n        if(level &gt; triangle.size() - 1) return sum;\n        if(idx &gt; triangle[level].size() - 1) return INT32_MAX;\n        return std::min(getMin(triangle, level + 1, idx + 1, sum), getMin(triangle, level + 1, idx, sum)) + triangle[level][idx];\n    }\n};\n</code></pre>\n<h2 id=\"解法二：记忆化递归\">解法二：记忆化递归</h2>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    vector&lt;vector&lt;int&gt;&gt; memo;\n    int minimumTotal(vector&lt;vector&lt;int&gt;&gt;&amp; triangle) {\n        if(triangle.empty()) return 0;\n        memo = vector&lt;vector&lt;int&gt;&gt;(triangle.size(), vector&lt;int&gt;(triangle.size(), -1));\n        return getMin(triangle, 0, 0, 0);\n    }\n\n    int getMin(vector&lt;vector&lt;int&gt;&gt;&amp; triangle, int level, int idx, int sum) {\n        if(level &gt; triangle.size() - 1) return sum;\n        if(idx &gt; triangle[level].size() - 1) return INT32_MAX;\n        if(memo[level][idx] != -1) return memo[level][idx];\n        int min = std::min(getMin(triangle, level + 1, idx + 1, sum), getMin(triangle, level + 1, idx, sum)) + triangle[level][idx];\n        return memo[level][idx] = min;\n    }\n};\n</code></pre>\n<h2 id=\"解法三：自顶向下DP\">解法三：自顶向下DP</h2>\n<p><strong>转移方程：</strong></p>\n<pre><code class=\"language-cpp\">if(j == 0) \n\tmemo[i][j] = memo[i-1][j] + triangle[i][j];\nelse if(j == triangle[i].size() - 1) \n\tmemo[i][j] = memo[i-1][j-1] + triangle[i][j];\nelse \n\tmemo[i][j] = triangle[i][j] + std::min(memo[i-1][j], memo[i-1][j-1]);\n</code></pre>\n<p><strong>完整代码：</strong></p>\n<p>结果是最底层中最小的那个</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    int minimumTotal(vector&lt;vector&lt;int&gt;&gt;&amp; triangle) {\n        if(triangle.empty()) return 0;\n        vector&lt;vector&lt;int&gt;&gt; memo = vector&lt;vector&lt;int&gt;&gt;(triangle.size(), vector&lt;int&gt;(triangle.size(), -1));\n        memo[0][0] = triangle[0][0];\n        for(int i = 1; i &lt; triangle.size(); i++){\n            for(int j = 0; j &lt; triangle[i].size(); j++){\n                if(j == 0) \n                    memo[i][j] = memo[i-1][j] + triangle[i][j];\n                else if(j == triangle[i].size() - 1) \n                    memo[i][j] = memo[i-1][j-1] + triangle[i][j];\n                else \n                    memo[i][j] = triangle[i][j] + std::min(memo[i-1][j], memo[i-1][j-1]);\n            }\n        }\n        int res = INT32_MAX, len = memo[memo.size() - 1].size();\n        for(int i = 0; i &lt; len; i++) res = std::min(res, memo[memo.size() - 1][i]);\n        return res;\n    }\n};\n</code></pre>\n<h2 id=\"解法四：自底向上DP\">解法四：自底向上DP</h2>\n<p>下次再写</p>\n<h1 id=\"221-Maximal-Square\"><a href=\"https://leetcode-cn.com/problems/maximal-square/\" target=\"_blank\" rel=\"noopener\">221. Maximal Square</a></h1>\n<p><a href=\"DP-Medium/image-20200506175441330.png\" title=\"image-20200506175441330\" class=\"gallery-item\"><img src=\"image-20200506175441330.png\" alt=\"image-20200506175441330\"></a></p>\n<h2 id=\"解法一：bfs\">解法一：bfs</h2>\n<p>本质就是暴力搜索，因为每遇到一个1都要开始搜索，而且每层的斜对角都会被重复判断</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    struct Pos {\n        int x, y;\n    };\n    int maximalSquare(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) {\n        int size = 0;\n        for(int i = 0; i &lt; matrix.size(); i++) {\n            for(int j = 0; j &lt; matrix[0].size(); j++) {\n                if(matrix[i][j] == '1')\n                    size = std::max(size, bfs(matrix, i, j));\n            }\n        }\n        return size * size;\n    }\n\n    int bfs(vector&lt;vector&lt;char&gt;&gt;&amp; matrix, int i, int j) {\n        queue&lt;Pos&gt; q;\n        q.push({i, j});\n        int size = 0;\n        while(!q.empty()) {\n            int len = q.size();\n            for(int idx = 0; idx &lt; len; idx++) {\n                Pos curr = q.front(); q.pop();\n                i = curr.x, j = curr.y;\n                if(i &gt; matrix.size() - 1 || j &gt; matrix[0].size() - 1) \n                    return size;\n                if(matrix[i][j] == '0') \n                    return size;\n                q.push({i + 1, j});\n                q.push({i, j + 1});\n                q.push({i + 1, j + 1});\n            }\n            size++;\n        }\n        return size;\n    }\n};\n</code></pre>\n<h2 id=\"解法二：DP-v2\">解法二：DP</h2>\n<p><strong>转移方程：</strong></p>\n<pre><code class=\"language-cpp\">dp[i][j] = min{ dp[i-1][j], dp[i][j-1], dp[i-1][j-1] } + 1;\n</code></pre>\n<p><strong>完整解法：</strong></p>\n<pre><code class=\"language-cpp\">class Solution {\n    public:\n    int maximalSquare(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) {\n        if(matrix.empty() || matrix[0].empty()) return 0;\n        vector&lt;vector&lt;int&gt;&gt; dp = vector&lt;vector&lt;int&gt;&gt;(matrix.size(), vector&lt;int&gt;(matrix[0].size()));\n        int size = 0;\n        for(int i = 0; i &lt; matrix.size(); i++) {\n            for(int j = 0; j &lt; matrix[0].size(); j++) {\n                if(matrix[i][j] == '1') {\n                    if(i == 0 || j == 0)\n                        dp[i][j] = 1;\n                    else\n                        dp[i][j] = std::min(dp[i-1][j], std::min(dp[i][j-1], dp[i-1][j-1])) + 1;\n                }\n                size = std::max(size, dp[i][j]);\n            }\n        }\n        return size * size;\n    }\n};\n</code></pre>\n<h1 id=\"523-Continuous-Subarray-Sum\"><a href=\"https://leetcode-cn.com/problems/continuous-subarray-sum/\" target=\"_blank\" rel=\"noopener\">523. Continuous Subarray Sum</a></h1>\n<p><a href=\"DP-Medium/image-20200514133707446.png\" title=\"image-20200514133707446\" class=\"gallery-item\"><img src=\"image-20200514133707446.png\" alt=\"image-20200514133707446\"></a></p>\n<p><strong>这题好像根本不是DP，被骗了orz</strong></p>\n<h2 id=\"解法一：暴力法\">解法一：暴力法</h2>\n<p>两重循环枚举所有情况，注意处理0的情况</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    bool checkSubarraySum(vector&lt;int&gt;&amp; nums, int k) {\n        if(nums.empty()) return false;\n        for(int i = 0; i &lt; nums.size(); i++) {\n            int sum = nums[i];\n            for(int j = i + 1; j &lt; nums.size(); j++) {\n                sum += nums[j];\n                if(k == 0) {\n                    if(sum == 0) return true;\n                } \n                else {\n                    if(sum % k == 0) return true;\n                }\n            }\n        }\n        return false;\n    }\n};\n</code></pre>\n<h2 id=\"解法二：前缀和\">解法二：前缀和</h2>\n<ul>\n<li>记录前缀和以及对应的index</li>\n<li>检查是否存在某个前缀和与当前前缀和相减 mod k 为0（或k为0时，差也为0）</li>\n<li>再检查索引差是否大于一</li>\n</ul>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    bool checkSubarraySum(vector&lt;int&gt;&amp; nums, int k) {\n        if(nums.empty()) return false;\n        unordered_map&lt;int, int&gt; map;\n        map[0] = -1;\n        int sum = 0;\n        for(int i = 0; i &lt; nums.size(); i++) {\n            sum += nums[i];\n            if(k != 0) sum %= k;\n            if(map.find(sum) != map.end()) {\n                if(i - map[sum] &gt; 1) return true;\n            }\n            else {\n                map[sum] = i;\n            }\n        }\n\n        return false;\n    }\n};\n</code></pre>\n<h1 id=\"1024-Video-Stitching\"><a href=\"https://leetcode-cn.com/problems/video-stitching/\" target=\"_blank\" rel=\"noopener\">1024. Video Stitching</a></h1>\n<p><a href=\"DP-Medium/image-20200514160149449.png\" title=\"image-20200514160149449\" class=\"gallery-item\"><img src=\"image-20200514160149449.png\" alt=\"image-20200514160149449\"></a></p>\n<p><a href=\"DP-Medium/image-20200514160200566.png\" title=\"image-20200514160200566\" class=\"gallery-item\"><img src=\"image-20200514160200566.png\" alt=\"image-20200514160200566\"></a></p>\n<h2 id=\"解法一：排序-贪心\">解法一：排序 + 贪心</h2>\n<ul>\n<li>\n<p>先排序，每次更新能覆盖的最长片段，如果下一个的起始点超过了当前覆盖的范围，说明无解</p>\n</li>\n<li>\n<p>在下次起始点不超过本次范围的情况下，寻找一个覆盖范围最广的片段</p>\n</li>\n<li>\n<p>如果满足 &gt;= T 那么返回结果</p>\n</li>\n<li>\n<p>排序$O(Nlog(N))$ + 线性遍历$O(N)$ = $O(Nlog(N))$</p>\n</li>\n</ul>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    int videoStitching(vector&lt;vector&lt;int&gt;&gt;&amp; clips, int T) {\n        std::sort(clips.begin(), clips.end());\n        int curr = 0, res = 0;\n        for(int i = 0; i &lt; clips.size(); i++) {\n            if(clips[i][0] &gt; curr) return -1;\n            int tmp = clips[i][1];\n            while(i + 1 &lt; clips.size() &amp;&amp; clips[i + 1][0] &lt;= curr)\n                tmp = std::max(tmp, clips[++i][1]);\n            res++;\n            curr = tmp;\n            if(curr &gt;= T) return res;\n        }\n        return -1;\n    }\n};\n</code></pre>\n<h1 id=\"1027-Longest-Arithmetic-Sequence\"><a href=\"https://leetcode-cn.com/problems/longest-arithmetic-sequence/\" target=\"_blank\" rel=\"noopener\">1027. Longest Arithmetic Sequence</a></h1>\n<p><a href=\"DP-Medium/image-20200514163832672.png\" title=\"image-20200514163832672\" class=\"gallery-item\"><img src=\"image-20200514163832672.png\" alt=\"image-20200514163832672\"></a></p>\n<h2 id=\"解法一：暴力法-v2\">解法一：暴力法</h2>\n<p>先枚举所有可能的差，再检查对应差的最大长度，用最大长度更新我们的解</p>\n<p>14000+ms，震撼我妈</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    int max = 0;\n    int longestArithSeqLength(vector&lt;int&gt;&amp; A) {\n        if(A.size() &lt; 2) return A.size();\n        for(int i = 0; i &lt; A.size(); i++) {\n            for(int j = i + 1; j &lt; A.size(); j++) {\n                dfs(A, j, A[j] - A[i], 2);\n            }\n        }\n        return max;\n    }\n\n    void dfs(vector&lt;int&gt;&amp; nums, int start, int val, int len) {\n        max = std::max(len, max);\n        for(int i = start + 1; i &lt; nums.size(); i++) {\n            if(nums[i] - nums[start] == val) {\n                dfs(nums, i, val, len + 1);\n            }\n        }\n    }\n};\n</code></pre>\n<h2 id=\"解法二：记忆化-DP\">解法二：记忆化 &amp; DP</h2>\n<ul>\n<li>\n<p>记录下到 i 位置为止的所有差值对应等差数列的长度</p>\n</li>\n<li>\n<p>如果A[i] - A[j] ( j &lt; i ) ，转移方程为</p>\n<pre><code class=\"language-cpp\">// dp[j]中存在 A[i] - A[j]\ndp[i][A[i] - A[j]] = dp[j][A[i] - A[j]] + 1\n// 否则\ndp[i][A[i] - A[j]] = 2\n</code></pre>\n</li>\n<li>\n<p>不断更新最大值</p>\n</li>\n</ul>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    int longestArithSeqLength(vector&lt;int&gt;&amp; A) {\n        // if(A.size() == 1000) return 5;\n        // if(A.size() == 2000) return 6;\n        if(A.size() &lt; 2) return A.size();\n        vector&lt;unordered_map&lt;int, int&gt;&gt; dp(A.size());\n        int res = 2;\n        for(int i = 1; i &lt; A.size(); i++) {\n            for(int j = 0; j &lt; i; j++) {\n                int val = A[i] - A[j];\n                if(dp[j].find(val) == dp[j].end())\n                    dp[i][val] = 2;\n                else    \n                    dp[i][val] = dp[j][val] + 1;\n                res = std::max(res, dp[i][val]);\n            }\n        }\n        return res;\n    }\n};\n</code></pre>\n<h1 id=\"576-Out-of-Boundary-Paths\"><a href=\"https://leetcode-cn.com/problems/out-of-boundary-paths/\" target=\"_blank\" rel=\"noopener\">576. Out of Boundary Paths</a></h1>\n<p><a href=\"DP-Medium/image-20200514180330408.png\" title=\"image-20200514180330408\" class=\"gallery-item\"><img src=\"image-20200514180330408.png\" alt=\"image-20200514180330408\"></a></p>\n<h2 id=\"解法一：DP-v3\">解法一：DP</h2>\n<p>看到$10^9$应该知道暴力法是没希望的，大概率是DP计数</p>\n<p>代码参考<a href=\"https://www.bilibili.com/video/BV18W411d7Cf\" target=\"_blank\" rel=\"noopener\">花花酱</a>, 用循环 + 方向数组判断四个方向越界情况值得学习</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    int findPaths(int m, int n, int N, int i, int j) {\n        int mask = 1e9 + 7;\n        vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; dp(N + 1, vector&lt;vector&lt;int&gt;&gt;(m, vector&lt;int&gt;(n, 0)));\n        vector&lt;int&gt; dirs = {-1, 0, 1, 0, -1};\n        for (int s = 1; s &lt;= N; s++) {\n            for (int y = 0; y &lt; m; y++) {\n                for (int x = 0; x &lt; n; x++) {\n                    for (int i = 0; i &lt; 4; i++) {\n                        int nx = x + dirs[i];\n                        int ny = y + dirs[i + 1];\n                        if(nx &lt; 0 || ny &lt; 0 || nx &gt;= n || ny &gt;= m) {\n                            dp[s][y][x]++;\n                        }\n                        else\n                            dp[s][y][x] = (dp[s][y][x] + dp[s - 1][ny][nx]) % mask;\n                    }\n                }\n            }\n        }\n\n        return dp[N][i][j];\n    }\n};\n</code></pre>\n</div><script src=\"https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js\"></script><script>if (typeof lightGallery !== 'undefined') {\n        var options = {\n            selector: '.gallery-item'\n        };\n        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);\n        }</script>","more":"<h1 id=\"63-Unique-Paths-II\"><a href=\"https://leetcode-cn.com/problems/unique-paths-ii/\" target=\"_blank\" rel=\"noopener\">63. Unique Paths II</a></h1>\n<p><a href=\"DP-Medium/image-20200228211822543.png\" title=\"image-20200228211822543\" class=\"gallery-item\"><img src=\"image-20200228211822543.png\" alt=\"image-20200228211822543\"></a></p>\n<h2 id=\"解法一：DP\">解法一：DP</h2>\n<p>这道题和Unique Path 1几乎相同，唯一的区别是，当某一格是障碍物时，uniquePath=0，即转移方程为</p>\n<pre><code class=\"language-java\">dp[i][j]=(obstacleGrid[i-1][j-1]==1)?0:  //如果有障碍物直接为0\n    (i==1&amp;j==1)?1:                       //起始为1\n    dp[i-1][j]+dp[i][j-1];               //取左和上方格子之和\n</code></pre>\n<p>完整解法如下</p>\n<pre><code class=\"language-java\">class Solution {\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\n        if(obstacleGrid==null || obstacleGrid.length==0)return 0; //特殊情况\n        int m=obstacleGrid.length;\n        int n=obstacleGrid[0].length;\n        int[][] dp=new int[m+1][n+1]; //数组开大一圈作为辅助，这样可以避免边界判断\n        for(int i=1;i&lt;m+1;i++){\n            for(int j=1;j&lt;n+1;j++){\n                dp[i][j]=(obstacleGrid[i-1][j-1]==1)?0:\n                (i==1&amp;j==1)?1:\n                dp[i-1][j]+dp[i][j-1];\n            }\n        }\n        return dp[m][n]; //dp[m][n]即为最终结果\n    }\n}\n</code></pre>\n<p>​</p>\n<h1 id=\"64-Minimum-Path-Sum\"><a href=\"https://leetcode-cn.com/problems/minimum-path-sum/\" target=\"_blank\" rel=\"noopener\">64. Minimum Path Sum</a></h1>\n<p><a href=\"DP-Medium/image-20200228222649924.png\" title=\"image-20200228222649924\" class=\"gallery-item\"><img src=\"image-20200228222649924.png\" alt=\"image-20200228222649924\"></a></p>\n<h2 id=\"解法一：DP（不需要额外空间）\">解法一：DP（不需要额外空间）</h2>\n<p>和上题还是类似的思路，但是注意上边界和左边界上的值比较坑，需要特别地初始化</p>\n<p>需要注意的是，如果使用辅助空间，那么<strong>辅助格子</strong>和<strong>grid</strong>上的<strong>状态转移方程不能统一！！</strong></p>\n<p>因此我这里先对边界值特殊处理，以避免后续麻烦的<strong>多重判断</strong></p>\n<pre><code class=\"language-java\">class Solution {\n    public int minPathSum(int[][] grid) {\n        //if(grid.length==0)return 0;\n        int m=grid.length,n=grid[0].length;\n        for(int i=1;i&lt;m;i++)grid[i][0]+=grid[i-1][0]; //只有一条路可走\n        for(int i=1;i&lt;n;i++)grid[0][i]+=grid[0][i-1]; //同上\n        for(int i=1;i&lt;m;i++){\n            for(int j=1;j&lt;n;j++){\n                grid[i][j]+=Math.min(grid[i-1][j],grid[i][j-1]); //更新最小路径\n            }\n        }\n        return grid[m-1][n-1];\n    }\n}\n</code></pre>\n<p>​</p>\n<h1 id=\"⭐️5-Longest-Palindromic-Substring\">⭐️<a href=\"https://leetcode-cn.com/problems/longest-palindromic-substring/\" target=\"_blank\" rel=\"noopener\">5. Longest Palindromic Substring</a></h1>\n<p><a href=\"DP-Medium/image-20200229205630824.png\" title=\"image-20200229205630824\" class=\"gallery-item\"><img src=\"image-20200229205630824.png\" alt=\"image-20200229205630824\"></a></p>\n<h2 id=\"解法一：中心扩展（其实就是DP嘛）\">解法一：中心扩展（其实就是DP嘛）</h2>\n<ul>\n<li>\n<p><strong>思路</strong>：对于形如“aba”或“baab”的字符串我们可以通过左右+1的操作来复用之前的计算结果，即</p>\n<pre><code class=\"language-java\">dp(i,j)=(dp(i-1,j+1) &amp;&amp; s.charAt(i)==s.charAt(j));\n</code></pre>\n</li>\n<li>\n<p><strong>要点</strong>：注意分开讨论奇偶长度回文，目的是为了统一寻找回文的标准，如果“abba”当成奇数长串去处理的话就出大麻烦了，另外要注意的是，得到最大回文长度后，如何通过中心元素位置，计算出start和end</p>\n<pre><code class=\"language-java\">//假设max为最大回文长度\nlen=max-1;\nstart=i-(len-1)/2;\nend=i+len/2;\n</code></pre>\n</li>\n<li>\n<p>完整解法如下</p>\n</li>\n</ul>\n<pre><code class=\"language-java\">class Solution {\n    public String longestPalindrome(String s) {\n        if(s.length()&lt;=1)return s;\n        int start=0,end=0;\n        for(int i=0;i&lt;s.length();i++){\n            int max=Math.max(centerExpand(s,i,i),centerExpand(s,i,i+1)); //两种中心\n            if(max&gt;end-start){\n                start=i-(max-1)/2;\n                end=i+max/2;\n            }\n        }\n        return s.substring(start,end+1);\n    }\n\n    public int centerExpand(String s,int lo,int hi){ //用来找到某一中心的最长回文串\n        while(lo&gt;=0 &amp;&amp; hi&lt;s.length() &amp;&amp; s.charAt(lo)==s.charAt(hi)){lo--;hi++;}\n        return hi-lo-1;\n    }\n}\n</code></pre>\n<h2 id=\"解法二：Manacher-算法\">解法二：Manacher 算法</h2>\n<p>非常精巧的算法，时间复杂度O(n)，等好好消化理解了再贴上来</p>\n<p>​</p>\n<h1 id=\"⭐️91-Decode-Ways\">⭐️<a href=\"https://leetcode-cn.com/problems/decode-ways/\" target=\"_blank\" rel=\"noopener\">91. Decode Ways</a></h1>\n<p><a href=\"DP-Medium/image-20200229234943330.png\" title=\"image-20200229234943330\" class=\"gallery-item\"><img src=\"image-20200229234943330.png\" alt=\"image-20200229234943330\"></a></p>\n<h2 id=\"解法一：DP-v2\">解法一：DP</h2>\n<p>比较要求细心的一道题，必须关注以下几种<strong>特殊情况</strong>：</p>\n<ul>\n<li>\n<p>当出现诸如&quot;30&quot;,&quot;40&quot;等时，解码失败，直接<code>return 0</code></p>\n</li>\n<li>\n<p>&quot;10&quot;和&quot;20&quot;只能记一种，因为“0”无法解码</p>\n</li>\n<li>\n<p>其余1-26之间的数，和前一次结果叠加，相当于 “xxxab” + “xxxxb” 的结果</p>\n</li>\n</ul>\n<pre><code class=\"language-java\">class Solution {\n    public int numDecodings(String s) {\n        if( s.charAt(0)=='0') return 0;\n        int pre=1,curr=1;\n        for(int i=1;i&lt;s.length();i++){\n            int tmp = curr;\n            if (s.charAt(i) == '0')\n                if (s.charAt(i-1) == '1' || s.charAt(i-1) == '2') curr = pre;\n            else return 0;\n            else if (s.charAt(i-1) == '1' || s.charAt(i-1) == '2' &amp;&amp; s.charAt(i) &gt;= '1' &amp;&amp; s.charAt(i) &lt;= '6')\n                curr = curr + pre;\n            pre = tmp;\n        }\n        return curr;\n    }\n}\n</code></pre>\n<h1 id=\"139-Word-Break\"><a href=\"https://leetcode-cn.com/problems/word-break/\" target=\"_blank\" rel=\"noopener\">139. Word Break</a></h1>\n<p><a href=\"DP-Medium/image-20200301221358648.png\" title=\"image-20200301221358648\" class=\"gallery-item\"><img src=\"image-20200301221358648.png\" alt=\"image-20200301221358648\"></a></p>\n<ul>\n<li><strong>要点</strong>：用<code>HashSet</code>来判断是否在字典中存在</li>\n</ul>\n<h2 id=\"解法一：记忆化递归\">解法一：记忆化递归</h2>\n<ul>\n<li><strong>思路</strong>：可以分割为两个子串，左边必定是其中一个单词（如果找不到，说明不存在），接着递归求解右子串</li>\n</ul>\n<pre><code class=\"language-java\">class Solution {\n    public boolean wordBreak(String s, List&lt;String&gt; wordDict) {\n        return wordBreakWithMemo(s,new HashSet&lt;String&gt;(wordDict),0,new Boolean[s.length()]);\n    }\n\n    public boolean wordBreakWithMemo(String s,Set&lt;String&gt; set,int start,Boolean[] memo){\n        if(start==s.length())return true;\n        if(memo[start]!=null)return memo[start];\n        for(int i=start;i&lt;=s.length();i++){\n            if(set.contains(s.substring(start,i)) &amp;&amp; wordBreakWithMemo(s,set,i,memo))\n                return memo[start]=true;\n        }\n        return memo[start]=false;\n    }\n}\n</code></pre>\n<h2 id=\"解法二：DP\">解法二：DP</h2>\n<p>“<strong>可以记忆化递归的大多都可以DP解决</strong>”（没错，就是我说的）</p>\n<pre><code class=\"language-java\">//如果截止j位置满足条件，那么只要set.contains(s.substring(j,i)),则说明截止i也满足条件\n//即转移方程如下\nif( dp[j] &amp;&amp; set.contains(s.substring(j,i))){dp[i]=true;}\n</code></pre>\n<p>因此可以改写为以下形式</p>\n<pre><code class=\"language-java\">class Solution {\n    public boolean wordBreak(String s, List&lt;String&gt; wordDict) {\n        Set&lt;String&gt; set=new HashSet&lt;String&gt;(wordDict);\n        boolean[] dp=new boolean[s.length()+1];\n        dp[0]=true;\t\t\t\t\t\t\t\t\t\n        for(int i=1;i&lt;=s.length();i++){\n            for(int j=0;j&lt;i;j++){\n                if( dp[j] &amp;&amp; set.contains(s.substring(j,i)))\n                    dp[i]=true;\n            }\n        }\n        return dp[s.length()];\n    }\n}\n</code></pre>\n<h1 id=\"120-Triangle\"><a href=\"https://leetcode-cn.com/problems/triangle/\" target=\"_blank\" rel=\"noopener\">120. Triangle</a></h1>\n<p><a href=\"DP-Medium/image-20200505150432163.png\" title=\"image-20200505150432163\" class=\"gallery-item\"><img src=\"image-20200505150432163.png\" alt=\"image-20200505150432163\"></a></p>\n<h2 id=\"解法一：直接递归dfs\">解法一：直接递归dfs</h2>\n<p>应该可以，但是超时了</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    int minimumTotal(vector&lt;vector&lt;int&gt;&gt;&amp; triangle) {\n        if(triangle.empty()) return 0;\n        return getMin(triangle, 0, 0, 0);\n    }\n\n    int getMin(vector&lt;vector&lt;int&gt;&gt;&amp; triangle, int level, int idx, int sum) {\n        if(level &gt; triangle.size() - 1) return sum;\n        if(idx &gt; triangle[level].size() - 1) return INT32_MAX;\n        return std::min(getMin(triangle, level + 1, idx + 1, sum), getMin(triangle, level + 1, idx, sum)) + triangle[level][idx];\n    }\n};\n</code></pre>\n<h2 id=\"解法二：记忆化递归\">解法二：记忆化递归</h2>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    vector&lt;vector&lt;int&gt;&gt; memo;\n    int minimumTotal(vector&lt;vector&lt;int&gt;&gt;&amp; triangle) {\n        if(triangle.empty()) return 0;\n        memo = vector&lt;vector&lt;int&gt;&gt;(triangle.size(), vector&lt;int&gt;(triangle.size(), -1));\n        return getMin(triangle, 0, 0, 0);\n    }\n\n    int getMin(vector&lt;vector&lt;int&gt;&gt;&amp; triangle, int level, int idx, int sum) {\n        if(level &gt; triangle.size() - 1) return sum;\n        if(idx &gt; triangle[level].size() - 1) return INT32_MAX;\n        if(memo[level][idx] != -1) return memo[level][idx];\n        int min = std::min(getMin(triangle, level + 1, idx + 1, sum), getMin(triangle, level + 1, idx, sum)) + triangle[level][idx];\n        return memo[level][idx] = min;\n    }\n};\n</code></pre>\n<h2 id=\"解法三：自顶向下DP\">解法三：自顶向下DP</h2>\n<p><strong>转移方程：</strong></p>\n<pre><code class=\"language-cpp\">if(j == 0) \n\tmemo[i][j] = memo[i-1][j] + triangle[i][j];\nelse if(j == triangle[i].size() - 1) \n\tmemo[i][j] = memo[i-1][j-1] + triangle[i][j];\nelse \n\tmemo[i][j] = triangle[i][j] + std::min(memo[i-1][j], memo[i-1][j-1]);\n</code></pre>\n<p><strong>完整代码：</strong></p>\n<p>结果是最底层中最小的那个</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    int minimumTotal(vector&lt;vector&lt;int&gt;&gt;&amp; triangle) {\n        if(triangle.empty()) return 0;\n        vector&lt;vector&lt;int&gt;&gt; memo = vector&lt;vector&lt;int&gt;&gt;(triangle.size(), vector&lt;int&gt;(triangle.size(), -1));\n        memo[0][0] = triangle[0][0];\n        for(int i = 1; i &lt; triangle.size(); i++){\n            for(int j = 0; j &lt; triangle[i].size(); j++){\n                if(j == 0) \n                    memo[i][j] = memo[i-1][j] + triangle[i][j];\n                else if(j == triangle[i].size() - 1) \n                    memo[i][j] = memo[i-1][j-1] + triangle[i][j];\n                else \n                    memo[i][j] = triangle[i][j] + std::min(memo[i-1][j], memo[i-1][j-1]);\n            }\n        }\n        int res = INT32_MAX, len = memo[memo.size() - 1].size();\n        for(int i = 0; i &lt; len; i++) res = std::min(res, memo[memo.size() - 1][i]);\n        return res;\n    }\n};\n</code></pre>\n<h2 id=\"解法四：自底向上DP\">解法四：自底向上DP</h2>\n<p>下次再写</p>\n<h1 id=\"221-Maximal-Square\"><a href=\"https://leetcode-cn.com/problems/maximal-square/\" target=\"_blank\" rel=\"noopener\">221. Maximal Square</a></h1>\n<p><a href=\"DP-Medium/image-20200506175441330.png\" title=\"image-20200506175441330\" class=\"gallery-item\"><img src=\"image-20200506175441330.png\" alt=\"image-20200506175441330\"></a></p>\n<h2 id=\"解法一：bfs\">解法一：bfs</h2>\n<p>本质就是暴力搜索，因为每遇到一个1都要开始搜索，而且每层的斜对角都会被重复判断</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    struct Pos {\n        int x, y;\n    };\n    int maximalSquare(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) {\n        int size = 0;\n        for(int i = 0; i &lt; matrix.size(); i++) {\n            for(int j = 0; j &lt; matrix[0].size(); j++) {\n                if(matrix[i][j] == '1')\n                    size = std::max(size, bfs(matrix, i, j));\n            }\n        }\n        return size * size;\n    }\n\n    int bfs(vector&lt;vector&lt;char&gt;&gt;&amp; matrix, int i, int j) {\n        queue&lt;Pos&gt; q;\n        q.push({i, j});\n        int size = 0;\n        while(!q.empty()) {\n            int len = q.size();\n            for(int idx = 0; idx &lt; len; idx++) {\n                Pos curr = q.front(); q.pop();\n                i = curr.x, j = curr.y;\n                if(i &gt; matrix.size() - 1 || j &gt; matrix[0].size() - 1) \n                    return size;\n                if(matrix[i][j] == '0') \n                    return size;\n                q.push({i + 1, j});\n                q.push({i, j + 1});\n                q.push({i + 1, j + 1});\n            }\n            size++;\n        }\n        return size;\n    }\n};\n</code></pre>\n<h2 id=\"解法二：DP-v2\">解法二：DP</h2>\n<p><strong>转移方程：</strong></p>\n<pre><code class=\"language-cpp\">dp[i][j] = min{ dp[i-1][j], dp[i][j-1], dp[i-1][j-1] } + 1;\n</code></pre>\n<p><strong>完整解法：</strong></p>\n<pre><code class=\"language-cpp\">class Solution {\n    public:\n    int maximalSquare(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) {\n        if(matrix.empty() || matrix[0].empty()) return 0;\n        vector&lt;vector&lt;int&gt;&gt; dp = vector&lt;vector&lt;int&gt;&gt;(matrix.size(), vector&lt;int&gt;(matrix[0].size()));\n        int size = 0;\n        for(int i = 0; i &lt; matrix.size(); i++) {\n            for(int j = 0; j &lt; matrix[0].size(); j++) {\n                if(matrix[i][j] == '1') {\n                    if(i == 0 || j == 0)\n                        dp[i][j] = 1;\n                    else\n                        dp[i][j] = std::min(dp[i-1][j], std::min(dp[i][j-1], dp[i-1][j-1])) + 1;\n                }\n                size = std::max(size, dp[i][j]);\n            }\n        }\n        return size * size;\n    }\n};\n</code></pre>\n<h1 id=\"523-Continuous-Subarray-Sum\"><a href=\"https://leetcode-cn.com/problems/continuous-subarray-sum/\" target=\"_blank\" rel=\"noopener\">523. Continuous Subarray Sum</a></h1>\n<p><a href=\"DP-Medium/image-20200514133707446.png\" title=\"image-20200514133707446\" class=\"gallery-item\"><img src=\"image-20200514133707446.png\" alt=\"image-20200514133707446\"></a></p>\n<p><strong>这题好像根本不是DP，被骗了orz</strong></p>\n<h2 id=\"解法一：暴力法\">解法一：暴力法</h2>\n<p>两重循环枚举所有情况，注意处理0的情况</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    bool checkSubarraySum(vector&lt;int&gt;&amp; nums, int k) {\n        if(nums.empty()) return false;\n        for(int i = 0; i &lt; nums.size(); i++) {\n            int sum = nums[i];\n            for(int j = i + 1; j &lt; nums.size(); j++) {\n                sum += nums[j];\n                if(k == 0) {\n                    if(sum == 0) return true;\n                } \n                else {\n                    if(sum % k == 0) return true;\n                }\n            }\n        }\n        return false;\n    }\n};\n</code></pre>\n<h2 id=\"解法二：前缀和\">解法二：前缀和</h2>\n<ul>\n<li>记录前缀和以及对应的index</li>\n<li>检查是否存在某个前缀和与当前前缀和相减 mod k 为0（或k为0时，差也为0）</li>\n<li>再检查索引差是否大于一</li>\n</ul>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    bool checkSubarraySum(vector&lt;int&gt;&amp; nums, int k) {\n        if(nums.empty()) return false;\n        unordered_map&lt;int, int&gt; map;\n        map[0] = -1;\n        int sum = 0;\n        for(int i = 0; i &lt; nums.size(); i++) {\n            sum += nums[i];\n            if(k != 0) sum %= k;\n            if(map.find(sum) != map.end()) {\n                if(i - map[sum] &gt; 1) return true;\n            }\n            else {\n                map[sum] = i;\n            }\n        }\n\n        return false;\n    }\n};\n</code></pre>\n<h1 id=\"1024-Video-Stitching\"><a href=\"https://leetcode-cn.com/problems/video-stitching/\" target=\"_blank\" rel=\"noopener\">1024. Video Stitching</a></h1>\n<p><a href=\"DP-Medium/image-20200514160149449.png\" title=\"image-20200514160149449\" class=\"gallery-item\"><img src=\"image-20200514160149449.png\" alt=\"image-20200514160149449\"></a></p>\n<p><a href=\"DP-Medium/image-20200514160200566.png\" title=\"image-20200514160200566\" class=\"gallery-item\"><img src=\"image-20200514160200566.png\" alt=\"image-20200514160200566\"></a></p>\n<h2 id=\"解法一：排序-贪心\">解法一：排序 + 贪心</h2>\n<ul>\n<li>\n<p>先排序，每次更新能覆盖的最长片段，如果下一个的起始点超过了当前覆盖的范围，说明无解</p>\n</li>\n<li>\n<p>在下次起始点不超过本次范围的情况下，寻找一个覆盖范围最广的片段</p>\n</li>\n<li>\n<p>如果满足 &gt;= T 那么返回结果</p>\n</li>\n<li>\n<p>排序$O(Nlog(N))$ + 线性遍历$O(N)$ = $O(Nlog(N))$</p>\n</li>\n</ul>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    int videoStitching(vector&lt;vector&lt;int&gt;&gt;&amp; clips, int T) {\n        std::sort(clips.begin(), clips.end());\n        int curr = 0, res = 0;\n        for(int i = 0; i &lt; clips.size(); i++) {\n            if(clips[i][0] &gt; curr) return -1;\n            int tmp = clips[i][1];\n            while(i + 1 &lt; clips.size() &amp;&amp; clips[i + 1][0] &lt;= curr)\n                tmp = std::max(tmp, clips[++i][1]);\n            res++;\n            curr = tmp;\n            if(curr &gt;= T) return res;\n        }\n        return -1;\n    }\n};\n</code></pre>\n<h1 id=\"1027-Longest-Arithmetic-Sequence\"><a href=\"https://leetcode-cn.com/problems/longest-arithmetic-sequence/\" target=\"_blank\" rel=\"noopener\">1027. Longest Arithmetic Sequence</a></h1>\n<p><a href=\"DP-Medium/image-20200514163832672.png\" title=\"image-20200514163832672\" class=\"gallery-item\"><img src=\"image-20200514163832672.png\" alt=\"image-20200514163832672\"></a></p>\n<h2 id=\"解法一：暴力法-v2\">解法一：暴力法</h2>\n<p>先枚举所有可能的差，再检查对应差的最大长度，用最大长度更新我们的解</p>\n<p>14000+ms，震撼我妈</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    int max = 0;\n    int longestArithSeqLength(vector&lt;int&gt;&amp; A) {\n        if(A.size() &lt; 2) return A.size();\n        for(int i = 0; i &lt; A.size(); i++) {\n            for(int j = i + 1; j &lt; A.size(); j++) {\n                dfs(A, j, A[j] - A[i], 2);\n            }\n        }\n        return max;\n    }\n\n    void dfs(vector&lt;int&gt;&amp; nums, int start, int val, int len) {\n        max = std::max(len, max);\n        for(int i = start + 1; i &lt; nums.size(); i++) {\n            if(nums[i] - nums[start] == val) {\n                dfs(nums, i, val, len + 1);\n            }\n        }\n    }\n};\n</code></pre>\n<h2 id=\"解法二：记忆化-DP\">解法二：记忆化 &amp; DP</h2>\n<ul>\n<li>\n<p>记录下到 i 位置为止的所有差值对应等差数列的长度</p>\n</li>\n<li>\n<p>如果A[i] - A[j] ( j &lt; i ) ，转移方程为</p>\n<pre><code class=\"language-cpp\">// dp[j]中存在 A[i] - A[j]\ndp[i][A[i] - A[j]] = dp[j][A[i] - A[j]] + 1\n// 否则\ndp[i][A[i] - A[j]] = 2\n</code></pre>\n</li>\n<li>\n<p>不断更新最大值</p>\n</li>\n</ul>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    int longestArithSeqLength(vector&lt;int&gt;&amp; A) {\n        // if(A.size() == 1000) return 5;\n        // if(A.size() == 2000) return 6;\n        if(A.size() &lt; 2) return A.size();\n        vector&lt;unordered_map&lt;int, int&gt;&gt; dp(A.size());\n        int res = 2;\n        for(int i = 1; i &lt; A.size(); i++) {\n            for(int j = 0; j &lt; i; j++) {\n                int val = A[i] - A[j];\n                if(dp[j].find(val) == dp[j].end())\n                    dp[i][val] = 2;\n                else    \n                    dp[i][val] = dp[j][val] + 1;\n                res = std::max(res, dp[i][val]);\n            }\n        }\n        return res;\n    }\n};\n</code></pre>\n<h1 id=\"576-Out-of-Boundary-Paths\"><a href=\"https://leetcode-cn.com/problems/out-of-boundary-paths/\" target=\"_blank\" rel=\"noopener\">576. Out of Boundary Paths</a></h1>\n<p><a href=\"DP-Medium/image-20200514180330408.png\" title=\"image-20200514180330408\" class=\"gallery-item\"><img src=\"image-20200514180330408.png\" alt=\"image-20200514180330408\"></a></p>\n<h2 id=\"解法一：DP-v3\">解法一：DP</h2>\n<p>看到$10^9$应该知道暴力法是没希望的，大概率是DP计数</p>\n<p>代码参考<a href=\"https://www.bilibili.com/video/BV18W411d7Cf\" target=\"_blank\" rel=\"noopener\">花花酱</a>, 用循环 + 方向数组判断四个方向越界情况值得学习</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    int findPaths(int m, int n, int N, int i, int j) {\n        int mask = 1e9 + 7;\n        vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; dp(N + 1, vector&lt;vector&lt;int&gt;&gt;(m, vector&lt;int&gt;(n, 0)));\n        vector&lt;int&gt; dirs = {-1, 0, 1, 0, -1};\n        for (int s = 1; s &lt;= N; s++) {\n            for (int y = 0; y &lt; m; y++) {\n                for (int x = 0; x &lt; n; x++) {\n                    for (int i = 0; i &lt; 4; i++) {\n                        int nx = x + dirs[i];\n                        int ny = y + dirs[i + 1];\n                        if(nx &lt; 0 || ny &lt; 0 || nx &gt;= n || ny &gt;= m) {\n                            dp[s][y][x]++;\n                        }\n                        else\n                            dp[s][y][x] = (dp[s][y][x] + dp[s - 1][ny][nx]) % mask;\n                    }\n                }\n            }\n        }\n\n        return dp[N][i][j];\n    }\n};\n</code></pre>\n<script src=\"https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js\"></script><script>if (typeof lightGallery !== 'undefined') {\n        var options = {\n            selector: '.gallery-item'\n        };\n        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);\n        }</script>","categories":[{"name":"Algorithm","path":"api/categories/Algorithm.json"}],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"}]}