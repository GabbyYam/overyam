{"title":"DP-Medium","slug":"DP-Medium","date":"2020-02-28T13:15:28.000Z","updated":"2020-02-28T14:32:59.856Z","comments":true,"path":"api/articles/DP-Medium.json","excerpt":"Abstract：更新部分Medium难度DP相关题解","covers":["image-20200228211822543.png","image-20200228222649924.png"],"content":"<link rel=\"stylesheet\" type=\"text/css\" href=\"https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css\"><div class=\".article-gallery\" <p><strong>Abstract</strong>：更新部分<code>Medium</code>难度<code>DP</code>相关题解<p></p>\n<a id=\"more\"></a>\n<h1 id=\"63-Unique-Paths-II\"><a href=\"https://leetcode-cn.com/problems/unique-paths-ii/\" target=\"_blank\" rel=\"noopener\">63. Unique Paths II</a></h1>\n<p><a href=\"DP-Medium/image-20200228211822543.png\" title=\"image-20200228211822543\" class=\"gallery-item\"><img src=\"image-20200228211822543.png\" alt=\"image-20200228211822543\"></a></p>\n<h2 id=\"解法一：DP\">解法一：DP</h2>\n<p>这道题和Unique Path 1几乎相同，唯一的区别是，当某一格是障碍物时，uniquePath=0，即转移方程为</p>\n<pre><code class=\"language-java\">dp[i][j]=(obstacleGrid[i-1][j-1]==1)?0:  //如果有障碍物直接为0\n    (i==1&amp;j==1)?1:                       //起始为1\n    dp[i-1][j]+dp[i][j-1];               //取左和上方格子之和\n</code></pre>\n<p>完整解法如下</p>\n<pre><code class=\"language-java\">class Solution {\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\n        if(obstacleGrid==null || obstacleGrid.length==0)return 0; //特殊情况\n        int m=obstacleGrid.length;\n        int n=obstacleGrid[0].length;\n        int[][] dp=new int[m+1][n+1]; //数组开大一圈作为辅助，这样可以避免边界判断\n        for(int i=1;i&lt;m+1;i++){\n            for(int j=1;j&lt;n+1;j++){\n                dp[i][j]=(obstacleGrid[i-1][j-1]==1)?0:\n                (i==1&amp;j==1)?1:\n                dp[i-1][j]+dp[i][j-1];\n            }\n        }\n        return dp[m][n]; //dp[m][n]即为最终结果\n    }\n}\n</code></pre>\n<h1 id=\"64-Minimum-Path-Sum\"><a href=\"https://leetcode-cn.com/problems/minimum-path-sum/\" target=\"_blank\" rel=\"noopener\">64. Minimum Path Sum</a></h1>\n<p><a href=\"DP-Medium/image-20200228222649924.png\" title=\"image-20200228222649924\" class=\"gallery-item\"><img src=\"image-20200228222649924.png\" alt=\"image-20200228222649924\"></a></p>\n<h1 id=\"解法一：DP（不需要额外空间）\">解法一：DP（不需要额外空间）</h1>\n<p>和上题还是类似的思路，但是注意上边界和左边界上的值比较坑，需要特别地初始化</p>\n<p>需要注意的是，如果使用辅助空间，那么<strong>辅助格子</strong>和<strong>grid</strong>上的<strong>状态转移方程不能统一！！</strong></p>\n<p>因此我这里先对边界值特殊处理，以避免后续麻烦的<strong>多重判断</strong></p>\n<pre><code class=\"language-java\">class Solution {\n    public int minPathSum(int[][] grid) {\n        //if(grid.length==0)return 0;\n        int m=grid.length,n=grid[0].length;\n        for(int i=1;i&lt;m;i++)grid[i][0]+=grid[i-1][0]; //只有一条路可走\n        for(int i=1;i&lt;n;i++)grid[0][i]+=grid[0][i-1]; //同上\n        for(int i=1;i&lt;m;i++){\n            for(int j=1;j&lt;n;j++){\n                grid[i][j]+=Math.min(grid[i-1][j],grid[i][j-1]); //更新最小路径\n            }\n        }\n        return grid[m-1][n-1];\n    }\n}\n</code></pre>\n</div><script src=\"https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js\"></script><script>if (typeof lightGallery !== 'undefined') {\n        var options = {\n            selector: '.gallery-item'\n        };\n        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);\n        }</script>","more":"<h1 id=\"63-Unique-Paths-II\"><a href=\"https://leetcode-cn.com/problems/unique-paths-ii/\" target=\"_blank\" rel=\"noopener\">63. Unique Paths II</a></h1>\n<p><a href=\"DP-Medium/image-20200228211822543.png\" title=\"image-20200228211822543\" class=\"gallery-item\"><img src=\"image-20200228211822543.png\" alt=\"image-20200228211822543\"></a></p>\n<h2 id=\"解法一：DP\">解法一：DP</h2>\n<p>这道题和Unique Path 1几乎相同，唯一的区别是，当某一格是障碍物时，uniquePath=0，即转移方程为</p>\n<pre><code class=\"language-java\">dp[i][j]=(obstacleGrid[i-1][j-1]==1)?0:  //如果有障碍物直接为0\n    (i==1&amp;j==1)?1:                       //起始为1\n    dp[i-1][j]+dp[i][j-1];               //取左和上方格子之和\n</code></pre>\n<p>完整解法如下</p>\n<pre><code class=\"language-java\">class Solution {\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\n        if(obstacleGrid==null || obstacleGrid.length==0)return 0; //特殊情况\n        int m=obstacleGrid.length;\n        int n=obstacleGrid[0].length;\n        int[][] dp=new int[m+1][n+1]; //数组开大一圈作为辅助，这样可以避免边界判断\n        for(int i=1;i&lt;m+1;i++){\n            for(int j=1;j&lt;n+1;j++){\n                dp[i][j]=(obstacleGrid[i-1][j-1]==1)?0:\n                (i==1&amp;j==1)?1:\n                dp[i-1][j]+dp[i][j-1];\n            }\n        }\n        return dp[m][n]; //dp[m][n]即为最终结果\n    }\n}\n</code></pre>\n<h1 id=\"64-Minimum-Path-Sum\"><a href=\"https://leetcode-cn.com/problems/minimum-path-sum/\" target=\"_blank\" rel=\"noopener\">64. Minimum Path Sum</a></h1>\n<p><a href=\"DP-Medium/image-20200228222649924.png\" title=\"image-20200228222649924\" class=\"gallery-item\"><img src=\"image-20200228222649924.png\" alt=\"image-20200228222649924\"></a></p>\n<h1 id=\"解法一：DP（不需要额外空间）\">解法一：DP（不需要额外空间）</h1>\n<p>和上题还是类似的思路，但是注意上边界和左边界上的值比较坑，需要特别地初始化</p>\n<p>需要注意的是，如果使用辅助空间，那么<strong>辅助格子</strong>和<strong>grid</strong>上的<strong>状态转移方程不能统一！！</strong></p>\n<p>因此我这里先对边界值特殊处理，以避免后续麻烦的<strong>多重判断</strong></p>\n<pre><code class=\"language-java\">class Solution {\n    public int minPathSum(int[][] grid) {\n        //if(grid.length==0)return 0;\n        int m=grid.length,n=grid[0].length;\n        for(int i=1;i&lt;m;i++)grid[i][0]+=grid[i-1][0]; //只有一条路可走\n        for(int i=1;i&lt;n;i++)grid[0][i]+=grid[0][i-1]; //同上\n        for(int i=1;i&lt;m;i++){\n            for(int j=1;j&lt;n;j++){\n                grid[i][j]+=Math.min(grid[i-1][j],grid[i][j-1]); //更新最小路径\n            }\n        }\n        return grid[m-1][n-1];\n    }\n}\n</code></pre>\n<script src=\"https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js\"></script><script>if (typeof lightGallery !== 'undefined') {\n        var options = {\n            selector: '.gallery-item'\n        };\n        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);\n        }</script>","categories":[{"name":"Algorithm","path":"api/categories/Algorithm.json"}],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"}]}