{"title":"PAT-Advanced Linear","slug":"PAT-Linear","date":"2020-04-14T08:45:11.000Z","updated":"2020-04-15T10:07:46.587Z","comments":true,"path":"api/articles/PAT-Linear.json","excerpt":"Abstract：能在线性时间内解决的一些典型问题","covers":["image-20200414165214845.png","image-20200414174647464.png"],"content":"<link rel=\"stylesheet\" type=\"text/css\" href=\"https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css\"><div class=\".article-gallery\" <p><strong>Abstract</strong>：能在线性时间内解决的一些典型问题<p></p>\n<a id=\"more\"></a>\n<h1 id=\"1054-The-Dominant-Color-20分\"><a href=\"https://pintia.cn/problem-sets/994805342720868352/problems/994805422639136768\" target=\"_blank\" rel=\"noopener\">1054 The Dominant Color (20分)</a></h1>\n<p><a href=\"PAT-Linear/image-20200414165214845.png\" title=\"image-20200414165214845\" class=\"gallery-item\"><img src=\"image-20200414165214845.png\" alt=\"image-20200414165214845\"></a></p>\n<h2 id=\"解法一：std-map\">解法一：std::map</h2>\n<p>显然可以通过排序的map来维护出现的个数来求出众数，但是注意当map中存在众数时要记得break，否则部分测试点会超时</p>\n<p>但是显然这不是最优解，很简单就不贴代码了（其实是没写/）</p>\n<h2 id=\"解法二：线性扫描\">解法二：线性扫描</h2>\n<p>这是这道题的正解，通过相互抵消的办法线性时间内得到众数</p>\n<p>维护一个初始为0的变量，如果存在众数，那么当众数++，非众数–时，最终的和一定为正，反之则不行</p>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\n#include&lt;algorithm&gt;\n\nint r, c, pixel, num = 0, curr;\n\nint main() {\n\tstd::ios::sync_with_stdio(false); std::cin.tie(0);\n\tstd::cin &gt;&gt; r &gt;&gt; c;\n\tfor (int i = 0; i &lt; r * c; i++) {\n\t\tstd::cin &gt;&gt; pixel;\n\t\tif (num == 0) curr = pixel;           // 如果当前和归零，说明一定不是众数\n\t\tif (pixel == curr) num++; else num--; // 否则继续观察，最后剩下的一定是众数\n\t}\n\tstd::cout &lt;&lt; curr;\n}\n</code></pre>\n<h1 id=\"1071-Speech-Patterns-25分\"><a href=\"https://pintia.cn/problem-sets/994805342720868352/problems/994805398257647616\" target=\"_blank\" rel=\"noopener\">1071 Speech Patterns (25分)</a></h1>\n<p><a href=\"PAT-Linear/image-20200414174647464.png\" title=\"image-20200414174647464\" class=\"gallery-item\"><img src=\"image-20200414174647464.png\" alt=\"image-20200414174647464\"></a></p>\n<h2 id=\"解法一：std-unordered-map\">解法一：std::unordered_map</h2>\n<p>思路同上题，用map + 一些简单的字符串处理会比较方便</p>\n<p>但是我暂时没想到不用map的做法</p>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\n#include&lt;string&gt;\n#include&lt;unordered_map&gt;\n\nstd::unordered_map &lt;std::string, int&gt; map;\nint num = 0, max = 0;\n\nint main() {\n\tstd::ios::sync_with_stdio(false); std::cin.tie(0);\n\tstd::string s, curr;\n\tstd::getline(std::cin, s);\n\tfor (int i = 0; i &lt; s.length(); i++) {\n\t\tchar c = s[i];\n\t\tif (isalnum(c)) curr.push_back(tolower(c));\n\t\tif (!isalnum(c) || i == s.length() - 1) {\n\t\t\tif (!curr.empty()) map[curr]++;\n\t\t\tcurr.clear();\n\t\t}\n\t}\n\t\n\tfor (auto it = map.begin(); it != map.end(); it++) {\n\t\tif (it-&gt;second &gt; max){\n\t\t\ts = it-&gt;first;\n\t\t\tmax = it-&gt;second;\n\t\t}\n\t}\n\tstd::cout &lt;&lt; s &lt;&lt; &quot; &quot; &lt;&lt; max;\n}\n</code></pre>\n</div><script src=\"https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js\"></script><script>if (typeof lightGallery !== 'undefined') {\n        var options = {\n            selector: '.gallery-item'\n        };\n        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);\n        }</script>","more":"<h1 id=\"1054-The-Dominant-Color-20分\"><a href=\"https://pintia.cn/problem-sets/994805342720868352/problems/994805422639136768\" target=\"_blank\" rel=\"noopener\">1054 The Dominant Color (20分)</a></h1>\n<p><a href=\"PAT-Linear/image-20200414165214845.png\" title=\"image-20200414165214845\" class=\"gallery-item\"><img src=\"image-20200414165214845.png\" alt=\"image-20200414165214845\"></a></p>\n<h2 id=\"解法一：std-map\">解法一：std::map</h2>\n<p>显然可以通过排序的map来维护出现的个数来求出众数，但是注意当map中存在众数时要记得break，否则部分测试点会超时</p>\n<p>但是显然这不是最优解，很简单就不贴代码了（其实是没写/）</p>\n<h2 id=\"解法二：线性扫描\">解法二：线性扫描</h2>\n<p>这是这道题的正解，通过相互抵消的办法线性时间内得到众数</p>\n<p>维护一个初始为0的变量，如果存在众数，那么当众数++，非众数–时，最终的和一定为正，反之则不行</p>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\n#include&lt;algorithm&gt;\n\nint r, c, pixel, num = 0, curr;\n\nint main() {\n\tstd::ios::sync_with_stdio(false); std::cin.tie(0);\n\tstd::cin &gt;&gt; r &gt;&gt; c;\n\tfor (int i = 0; i &lt; r * c; i++) {\n\t\tstd::cin &gt;&gt; pixel;\n\t\tif (num == 0) curr = pixel;           // 如果当前和归零，说明一定不是众数\n\t\tif (pixel == curr) num++; else num--; // 否则继续观察，最后剩下的一定是众数\n\t}\n\tstd::cout &lt;&lt; curr;\n}\n</code></pre>\n<h1 id=\"1071-Speech-Patterns-25分\"><a href=\"https://pintia.cn/problem-sets/994805342720868352/problems/994805398257647616\" target=\"_blank\" rel=\"noopener\">1071 Speech Patterns (25分)</a></h1>\n<p><a href=\"PAT-Linear/image-20200414174647464.png\" title=\"image-20200414174647464\" class=\"gallery-item\"><img src=\"image-20200414174647464.png\" alt=\"image-20200414174647464\"></a></p>\n<h2 id=\"解法一：std-unordered-map\">解法一：std::unordered_map</h2>\n<p>思路同上题，用map + 一些简单的字符串处理会比较方便</p>\n<p>但是我暂时没想到不用map的做法</p>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\n#include&lt;string&gt;\n#include&lt;unordered_map&gt;\n\nstd::unordered_map &lt;std::string, int&gt; map;\nint num = 0, max = 0;\n\nint main() {\n\tstd::ios::sync_with_stdio(false); std::cin.tie(0);\n\tstd::string s, curr;\n\tstd::getline(std::cin, s);\n\tfor (int i = 0; i &lt; s.length(); i++) {\n\t\tchar c = s[i];\n\t\tif (isalnum(c)) curr.push_back(tolower(c));\n\t\tif (!isalnum(c) || i == s.length() - 1) {\n\t\t\tif (!curr.empty()) map[curr]++;\n\t\t\tcurr.clear();\n\t\t}\n\t}\n\t\n\tfor (auto it = map.begin(); it != map.end(); it++) {\n\t\tif (it-&gt;second &gt; max){\n\t\t\ts = it-&gt;first;\n\t\t\tmax = it-&gt;second;\n\t\t}\n\t}\n\tstd::cout &lt;&lt; s &lt;&lt; &quot; &quot; &lt;&lt; max;\n}\n</code></pre>\n<script src=\"https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js\"></script><script>if (typeof lightGallery !== 'undefined') {\n        var options = {\n            selector: '.gallery-item'\n        };\n        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);\n        }</script>","categories":[{"name":"Algorithm","path":"api/categories/Algorithm.json"}],"tags":[{"name":"PAT-A","path":"api/tags/PAT-A.json"}]}