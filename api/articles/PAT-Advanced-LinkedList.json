{"title":"PAT-Advanced LinkedList","slug":"PAT-Advanced-LinkedList","date":"2020-04-06T09:06:54.000Z","updated":"2020-04-11T12:11:02.551Z","comments":true,"path":"api/articles/PAT-Advanced-LinkedList.json","excerpt":"Abstract：简单通过静态链表来处理比较方便，当然也比较费空间，另外输出格式是个坑","covers":["image-20200406170958083.png","image-20200406210154317.png","image-20200407165043580.png","image-20200407180332306.png","image-20200411200937050.png"],"content":"<link rel=\"stylesheet\" type=\"text/css\" href=\"https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css\"><div class=\".article-gallery\" <p><strong>Abstract</strong>：简单通过静态链表来处理比较方便，当然也比较费空间，另外输出格式是个坑<p></p>\n<a id=\"more\"></a>\n<h1 id=\"1032-Sharing-25分\"><a href=\"https://pintia.cn/problem-sets/994805342720868352/problems/994805460652113920\" target=\"_blank\" rel=\"noopener\">1032 Sharing (25分)</a></h1>\n<p><a href=\"PAT-Advanced-LinkedList/image-20200406170958083.png\" title=\"image-20200406170958083\" class=\"gallery-item\"><img src=\"image-20200406170958083.png\" alt=\"image-20200406170958083\"></a><a href=\"PAT-Advanced-LinkedList/image-20200406171008546.png\" title=\"image-20200406171008546\" class=\"gallery-item\"><img src=\"image-20200406171008546.png\" alt=\"image-20200406171008546\"></a></p>\n<h2 id=\"解法一：标记法\">解法一：标记法</h2>\n<p>同HashSet法，遍历a链表将所有经过的节点标记一次，再遍历b输出遇到的第一个标记过的节点</p>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\n\nstruct Node {\n    int next = -1;\n    bool is_visited = false;\n} node[100001];\n\nchar data;\nint num, s1, s2, address;\n\nvoid parse_input() {\n    std::cin &gt;&gt; s1 &gt;&gt; s2 &gt;&gt; num;\n    for (int i = 0; i &lt; num; i++) {\n        std::cin &gt;&gt; address &gt;&gt; data;\n        std::cin &gt;&gt; node[address].next;\n    }\n}\n\nint main() {\n    std::ios::sync_with_stdio(false); std::cin.tie(0);\n    parse_input();\n\n    for (s1; s1 != -1; s1 = node[s1].next)\n        node[s1].is_visited = true;\n\n    for (s2; s2 != -1; s2 = node[s2].next)\n        if (node[s2].is_visited) { printf(&quot;%05d&quot;,s2); return 0; }\n    std::cout &lt;&lt; -1;\n}\n\n</code></pre>\n<h2 id=\"解法二：双指针\">解法二：双指针</h2>\n<p>考虑将两条链合并，即左链结束时链接右链，右链结束时链接左链</p>\n<p>此时会出现一种现象：假设左链长n，右链长m，交点在左链的a位置，在右链的b位置，那么就有 m+a = n+b，也就是两个指针会在第二次遍历对方那条链时相遇</p>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\n\nstruct Node {\n\tchar val;\n\tint next = -1;\n} node[100002];\n\nchar val;\nint address, next, num, s1, s2;\n\nvoid parse_input() {\n\tscanf(&quot;%d%d%d&quot;, &amp;s1, &amp;s2, &amp;num);\n\tfor (int i = 0; i &lt; num; i++) {\n\t\tscanf(&quot;%d %c %d&quot;, &amp;address, &amp;val, &amp;next);\n\t\tnode[address] = { val,next };\n\t}\n}\n\nint get_intersection(int s1, int s2) {\n\tint curr_a = s1, curr_b = s2;\n\twhile (curr_a != -1 &amp;&amp; curr_b != -1) {\n\t\tif (curr_a == curr_b) return curr_a;         // 得到交点\n\t\tcurr_a = node[curr_a].next;\n\t\tcurr_b = node[curr_b].next;\n\t\tif (curr_a == -1 &amp;&amp; curr_b == -1) return -1; // 没找到，返回-1\n\t\tif (curr_a == -1) curr_a = s2;               // 接入b链\n\t\tif (curr_b == -1) curr_b = s1;               // 接入a链\n\t}\n\treturn -1;\n}\n\nint main() {\n\tparse_input();\n\tint ans = get_intersection(s1, s2);\n\tif (ans == -1) { printf(&quot;-1&quot;); return 0; }\n\tprintf(&quot;%05d&quot;, ans);\n}\n\n</code></pre>\n<h1 id=\"1052-Linked-List-Sorting-25分\"><a href=\"https://pintia.cn/problem-sets/994805342720868352/problems/994805425780670464\" target=\"_blank\" rel=\"noopener\">1052 Linked List Sorting (25分)</a></h1>\n<p><a href=\"PAT-Advanced-LinkedList/image-20200406210154317.png\" title=\"image-20200406210154317\" class=\"gallery-item\"><img src=\"image-20200406210154317.png\" alt=\"image-20200406210154317\"></a></p>\n<h2 id=\"解法一：二路归并（递归法）\">解法一：二路归并（递归法）</h2>\n<p>标准的链表归并排序</p>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\n\nstruct Node {\n\tint address = -1;\n\tint val = -1;\n\tint next = -1;\n} node[100002];\n\nint address, val, next, num, head;\n\nvoid parse_input() {\n\tscanf(&quot;%d%d&quot;, &amp;num, &amp;head);\n\tfor (int i = 0; i &lt; num; i++) {\n\t\tscanf(&quot;%d%d%d&quot;, &amp;address, &amp;val, &amp;next);\n\t\tnode[address] = { address,val,next };\n\t}\n}\n\nint get_len(int head) {\n\tint len = 0;\n\tfor (int i = head; i != -1; i = node[i].next) len++;\n\treturn len;\n}\n\nint merge_sort(int head) {\n\tif (head == -1 || node[head].next == -1) return head; // 递归结束条件\n\tint fast = node[head].next, slow = head;\n\twhile (fast != -1 &amp;&amp; node[fast].next != -1) {         // 定位到链表中点\n\t\tslow = node[slow].next;\n\t\tfast = node[node[fast].next].next;\n\t}\n\tint tmp = node[slow].next;\n\tnode[slow].next = -1;                                 // 截断前半段\n\tint left = merge_sort(head);                          // 递归左半边\n\tint right = merge_sort(tmp);                          // 递归右半边\n\tint h = 100001;\n\twhile (left != -1 &amp;&amp; right != -1) {                   // 转化为了 Merge two sorted list\n\t\tif (node[left].val &lt; node[right].val) {\n\t\t\tnode[h].next = left;\n\t\t\tleft = node[left].next;\n\t\t}\n\t\telse {\n\t\t\tnode[h].next = right;\n\t\t\tright = node[right].next;\n\t\t}\n\t\th = node[h].next;\n\t}\n\tnode[h].next = left != -1 ? left : right;\n\treturn node[100001].next;\n}\n\nint main() {\n\tparse_input();\n\thead = merge_sort(head);\n\tint len = get_len(head);\n\tif (len == 0) { printf(&quot;0 -1&quot;); return 0; }\n\tprintf(&quot;%d %05d\\n&quot;, len, head);\n\tfor (int i = head; i != -1; i = node[i].next) {\n\t\tprintf(&quot;%05d %d &quot;, node[i].address, node[i].val);\n\t\tif (node[i].next != -1) printf(&quot;%05d\\n&quot;, node[i].next);\n\t\telse printf(&quot;-1\\n&quot;);\n\t}\n}\n</code></pre>\n<h2 id=\"迭代法归并\">**迭代法归并</h2>\n<pre><code class=\"language-cpp\">int merge_sort(int head) {\n    int len = get_len(head);\n    \n    \n}\n</code></pre>\n<h2 id=\"解法二：快排\">解法二：快排</h2>\n<pre><code class=\"language-cpp\">int quick_sort(int head) {\n    \n}\n</code></pre>\n<h1 id=\"1097-Deduplication-on-a-Linked-List-25分\"><a href=\"https://pintia.cn/problem-sets/994805342720868352/problems/994805369774129152\" target=\"_blank\" rel=\"noopener\">1097 Deduplication on a Linked List (25分)</a></h1>\n<p><a href=\"PAT-Advanced-LinkedList/image-20200407165043580.png\" title=\"image-20200407165043580\" class=\"gallery-item\"><img src=\"image-20200407165043580.png\" alt=\"image-20200407165043580\"></a></p>\n<h2 id=\"解法一：模拟HashSet\">解法一：模拟HashSet</h2>\n<p>同理也可以用unordered_set，比这个多写几行但是节省空间</p>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\n\nstruct Node {\n\tint val = -1;\n\tint next = -1;\n} node[100003];\n\nint address, val, next, num, head;\nbool set[10000] = { false };\n\nvoid parse_input() {\n\tscanf(&quot;%d%d&quot;, &amp;head, &amp;num);\n\tfor (int i = 0; i &lt; num; i++) {\n\t\tscanf(&quot;%d%d%d&quot;, &amp;address, &amp;val, &amp;next);\n\t\tnode[address] = { val,next };\n\t}\n}\n\nvoid get_list(int m_head, int r_head) {\n\tif (head == -1) return;\n\tint h = m_head, r = r_head;\n\tfor (int i = head; i != -1; i = node[i].next) {\n\t\tif (!set[abs(node[i].val)]) {\n\t\t\tset[abs(node[i].val)] = true;\n\t\t\tnode[h].next = i;\n\t\t\th = i;\n\t\t}\n\t\telse {\n\t\t\tnode[r].next = i;\n\t\t\tr = i;\n\t\t}\n\t}\n\tnode[h].next = node[r].next = -1;\n}\n\nint main() {\n\tparse_input();\n\tint m_head = 100001, r_head = 100002;\n\tget_list(m_head, r_head);\n\tfor (int i = node[m_head].next; i != -1; i = node[i].next) {\n\t\tprintf(&quot;%05d %d &quot;, i, node[i].val);\n\t\tif (node[i].next != -1)printf(&quot;%05d\\n&quot;, node[i].next);\n\t\telse printf(&quot;-1\\n&quot;);\n\t}\n\n\tfor (int i = node[r_head].next; i != -1; i = node[i].next) {\n\t\tprintf(&quot;%05d %d &quot;, i, node[i].val);\n\t\tif (node[i].next != -1)printf(&quot;%05d\\n&quot;, node[i].next);\n\t\telse printf(&quot;-1\\n&quot;);\n\t}\n\n}\n\n</code></pre>\n<h1 id=\"1133-Splitting-A-Linked-List-25分\"><a href=\"https://pintia.cn/problem-sets/994805342720868352/problems/994805346776760320\" target=\"_blank\" rel=\"noopener\">1133 Splitting A Linked List (25分)</a></h1>\n<p><a href=\"PAT-Advanced-LinkedList/image-20200407180332306.png\" title=\"image-20200407180332306\" class=\"gallery-item\"><img src=\"image-20200407180332306.png\" alt=\"image-20200407180332306\"></a></p>\n<h2 id=\"完整解法\">完整解法</h2>\n<p>和上题思路完全一样，注意一下拼接三条子链的时候，如果二链为-1，要将一链接在三链上，否则将会丢失三链的数据</p>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\n\nstruct Node {\n\tint val = -1;\n\tint next = -1;\n} node[100004];\n\nint address, val, next, K, num, head;\nbool set[10000] = { false };\n\nvoid parse_input() {\n\tscanf(&quot;%d%d%d&quot;, &amp;head, &amp;num, &amp;K);\n\tfor (int i = 0; i &lt; num; i++) {\n\t\tscanf(&quot;%d%d%d&quot;, &amp;address, &amp;val, &amp;next);\n\t\tnode[address] = { val,next };\n\t}\n}\n\nvoid gen_list(int n_head, int k_head, int p_head) {\n\tint n = n_head, k = k_head, p = p_head;\n\tfor (int i = head; i != -1; i = node[i].next) {\n\t\tif (node[i].val &lt; 0) {\n\t\t\tnode[n].next = i;\n\t\t\tn = i;\n\t\t}\n\t\telse if (node[i].val &lt;= K) {\n\t\t\tnode[k].next = i;\n\t\t\tk = i;\n\t\t}\n\t\telse {\n\t\t\tnode[p].next = i;\n\t\t\tp = i;\n\t\t}\n\t}\n\tnode[n].next = node[k_head].next == -1 ? node[p_head].next : node[k_head].next;\n\tnode[k].next = node[p_head].next;\n\tnode[p].next = -1;\n}\n\nint main() {\n\tparse_input();\n\tint n_head = 100001, k_head = 100002, p_head = 100003;\n\tgen_list(n_head, k_head, p_head);\n\tfor (int i = node[n_head].next; i != -1; i = node[i].next) {\n\t\tprintf(&quot;%05d %d &quot;, i, node[i].val);\n\t\tif (node[i].next != -1)printf(&quot;%05d\\n&quot;, node[i].next);\n\t\telse printf(&quot;-1\\n&quot;);\n\t}\n}\n\n</code></pre>\n<h1 id=\"1074-Reversing-Linked-List-25分\"><a href=\"https://pintia.cn/problem-sets/994805342720868352/problems/994805394512134144\" target=\"_blank\" rel=\"noopener\">1074 Reversing Linked List (25分)</a></h1>\n<p><a href=\"PAT-Advanced-LinkedList/image-20200411200937050.png\" title=\"image-20200411200937050\" class=\"gallery-item\"><img src=\"image-20200411200937050.png\" alt=\"image-20200411200937050\"></a></p>\n<h2 id=\"解法一：快慢指针-（还没完全AC，不知道被什么卡了）\">解法一：快慢指针==（还没完全AC，不知道被什么卡了）==</h2>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\n#include&lt;vector&gt;\n\nint num, head, k, address, val, next;\nstruct Node {\n\tint val;\n\tint next = -1;\n} node[100000];\n\nvoid parseInput() {\n\tstd::ios::sync_with_stdio(false); std::cin.tie(0); // 取消同步以加快iostream\n\tstd::cin &gt;&gt; head &gt;&gt; num &gt;&gt; k;\n\tfor (int i = 0; i &lt; num; i++) {\n\t\tstd::cin &gt;&gt; address &gt;&gt; val &gt;&gt; next;\n\t\tnode[address] = { val,next };\n\t}\n}\n\nint reverseLinkedList(int k) {\n\tint prev, curr = head, tail = head, i = 0;\n\tfor (int i = 1; i &lt; k ; i++) tail = node[tail].next; // 定位到第k位\n\tprev = node[tail].next;                              // 准备将k以后作为前k尾部的next\n\tnode[tail].next = -1;                                // 截断前k位，方便反转\n\twhile (curr != -1) {                                 // 反转链表 \n\t\tint next = node[curr].next;\n\t\tnode[curr].next = prev;\n\t\tprev = curr;\n\t\tcurr = next;\n\t}\n\treturn prev;\n}\n\nint main() {\n\tparseInput();\n\thead = reverseLinkedList(k);\n\tfor (int i = head; i != -1; i = node[i].next) {\n\t\tprintf(&quot;%05d %d &quot;, i, node[i].val);\n\t\tif (node[i].next != -1) printf(&quot;%05d\\n&quot;, node[i].next);\n\t\telse printf(&quot;-1\\n&quot;);\n\t}\n}\n</code></pre>\n</div><script src=\"https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js\"></script><script>if (typeof lightGallery !== 'undefined') {\n        var options = {\n            selector: '.gallery-item'\n        };\n        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);\n        }</script>","more":"<h1 id=\"1032-Sharing-25分\"><a href=\"https://pintia.cn/problem-sets/994805342720868352/problems/994805460652113920\" target=\"_blank\" rel=\"noopener\">1032 Sharing (25分)</a></h1>\n<p><a href=\"PAT-Advanced-LinkedList/image-20200406170958083.png\" title=\"image-20200406170958083\" class=\"gallery-item\"><img src=\"image-20200406170958083.png\" alt=\"image-20200406170958083\"></a><a href=\"PAT-Advanced-LinkedList/image-20200406171008546.png\" title=\"image-20200406171008546\" class=\"gallery-item\"><img src=\"image-20200406171008546.png\" alt=\"image-20200406171008546\"></a></p>\n<h2 id=\"解法一：标记法\">解法一：标记法</h2>\n<p>同HashSet法，遍历a链表将所有经过的节点标记一次，再遍历b输出遇到的第一个标记过的节点</p>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\n\nstruct Node {\n    int next = -1;\n    bool is_visited = false;\n} node[100001];\n\nchar data;\nint num, s1, s2, address;\n\nvoid parse_input() {\n    std::cin &gt;&gt; s1 &gt;&gt; s2 &gt;&gt; num;\n    for (int i = 0; i &lt; num; i++) {\n        std::cin &gt;&gt; address &gt;&gt; data;\n        std::cin &gt;&gt; node[address].next;\n    }\n}\n\nint main() {\n    std::ios::sync_with_stdio(false); std::cin.tie(0);\n    parse_input();\n\n    for (s1; s1 != -1; s1 = node[s1].next)\n        node[s1].is_visited = true;\n\n    for (s2; s2 != -1; s2 = node[s2].next)\n        if (node[s2].is_visited) { printf(&quot;%05d&quot;,s2); return 0; }\n    std::cout &lt;&lt; -1;\n}\n\n</code></pre>\n<h2 id=\"解法二：双指针\">解法二：双指针</h2>\n<p>考虑将两条链合并，即左链结束时链接右链，右链结束时链接左链</p>\n<p>此时会出现一种现象：假设左链长n，右链长m，交点在左链的a位置，在右链的b位置，那么就有 m+a = n+b，也就是两个指针会在第二次遍历对方那条链时相遇</p>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\n\nstruct Node {\n\tchar val;\n\tint next = -1;\n} node[100002];\n\nchar val;\nint address, next, num, s1, s2;\n\nvoid parse_input() {\n\tscanf(&quot;%d%d%d&quot;, &amp;s1, &amp;s2, &amp;num);\n\tfor (int i = 0; i &lt; num; i++) {\n\t\tscanf(&quot;%d %c %d&quot;, &amp;address, &amp;val, &amp;next);\n\t\tnode[address] = { val,next };\n\t}\n}\n\nint get_intersection(int s1, int s2) {\n\tint curr_a = s1, curr_b = s2;\n\twhile (curr_a != -1 &amp;&amp; curr_b != -1) {\n\t\tif (curr_a == curr_b) return curr_a;         // 得到交点\n\t\tcurr_a = node[curr_a].next;\n\t\tcurr_b = node[curr_b].next;\n\t\tif (curr_a == -1 &amp;&amp; curr_b == -1) return -1; // 没找到，返回-1\n\t\tif (curr_a == -1) curr_a = s2;               // 接入b链\n\t\tif (curr_b == -1) curr_b = s1;               // 接入a链\n\t}\n\treturn -1;\n}\n\nint main() {\n\tparse_input();\n\tint ans = get_intersection(s1, s2);\n\tif (ans == -1) { printf(&quot;-1&quot;); return 0; }\n\tprintf(&quot;%05d&quot;, ans);\n}\n\n</code></pre>\n<h1 id=\"1052-Linked-List-Sorting-25分\"><a href=\"https://pintia.cn/problem-sets/994805342720868352/problems/994805425780670464\" target=\"_blank\" rel=\"noopener\">1052 Linked List Sorting (25分)</a></h1>\n<p><a href=\"PAT-Advanced-LinkedList/image-20200406210154317.png\" title=\"image-20200406210154317\" class=\"gallery-item\"><img src=\"image-20200406210154317.png\" alt=\"image-20200406210154317\"></a></p>\n<h2 id=\"解法一：二路归并（递归法）\">解法一：二路归并（递归法）</h2>\n<p>标准的链表归并排序</p>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\n\nstruct Node {\n\tint address = -1;\n\tint val = -1;\n\tint next = -1;\n} node[100002];\n\nint address, val, next, num, head;\n\nvoid parse_input() {\n\tscanf(&quot;%d%d&quot;, &amp;num, &amp;head);\n\tfor (int i = 0; i &lt; num; i++) {\n\t\tscanf(&quot;%d%d%d&quot;, &amp;address, &amp;val, &amp;next);\n\t\tnode[address] = { address,val,next };\n\t}\n}\n\nint get_len(int head) {\n\tint len = 0;\n\tfor (int i = head; i != -1; i = node[i].next) len++;\n\treturn len;\n}\n\nint merge_sort(int head) {\n\tif (head == -1 || node[head].next == -1) return head; // 递归结束条件\n\tint fast = node[head].next, slow = head;\n\twhile (fast != -1 &amp;&amp; node[fast].next != -1) {         // 定位到链表中点\n\t\tslow = node[slow].next;\n\t\tfast = node[node[fast].next].next;\n\t}\n\tint tmp = node[slow].next;\n\tnode[slow].next = -1;                                 // 截断前半段\n\tint left = merge_sort(head);                          // 递归左半边\n\tint right = merge_sort(tmp);                          // 递归右半边\n\tint h = 100001;\n\twhile (left != -1 &amp;&amp; right != -1) {                   // 转化为了 Merge two sorted list\n\t\tif (node[left].val &lt; node[right].val) {\n\t\t\tnode[h].next = left;\n\t\t\tleft = node[left].next;\n\t\t}\n\t\telse {\n\t\t\tnode[h].next = right;\n\t\t\tright = node[right].next;\n\t\t}\n\t\th = node[h].next;\n\t}\n\tnode[h].next = left != -1 ? left : right;\n\treturn node[100001].next;\n}\n\nint main() {\n\tparse_input();\n\thead = merge_sort(head);\n\tint len = get_len(head);\n\tif (len == 0) { printf(&quot;0 -1&quot;); return 0; }\n\tprintf(&quot;%d %05d\\n&quot;, len, head);\n\tfor (int i = head; i != -1; i = node[i].next) {\n\t\tprintf(&quot;%05d %d &quot;, node[i].address, node[i].val);\n\t\tif (node[i].next != -1) printf(&quot;%05d\\n&quot;, node[i].next);\n\t\telse printf(&quot;-1\\n&quot;);\n\t}\n}\n</code></pre>\n<h2 id=\"迭代法归并\">**迭代法归并</h2>\n<pre><code class=\"language-cpp\">int merge_sort(int head) {\n    int len = get_len(head);\n    \n    \n}\n</code></pre>\n<h2 id=\"解法二：快排\">解法二：快排</h2>\n<pre><code class=\"language-cpp\">int quick_sort(int head) {\n    \n}\n</code></pre>\n<h1 id=\"1097-Deduplication-on-a-Linked-List-25分\"><a href=\"https://pintia.cn/problem-sets/994805342720868352/problems/994805369774129152\" target=\"_blank\" rel=\"noopener\">1097 Deduplication on a Linked List (25分)</a></h1>\n<p><a href=\"PAT-Advanced-LinkedList/image-20200407165043580.png\" title=\"image-20200407165043580\" class=\"gallery-item\"><img src=\"image-20200407165043580.png\" alt=\"image-20200407165043580\"></a></p>\n<h2 id=\"解法一：模拟HashSet\">解法一：模拟HashSet</h2>\n<p>同理也可以用unordered_set，比这个多写几行但是节省空间</p>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\n\nstruct Node {\n\tint val = -1;\n\tint next = -1;\n} node[100003];\n\nint address, val, next, num, head;\nbool set[10000] = { false };\n\nvoid parse_input() {\n\tscanf(&quot;%d%d&quot;, &amp;head, &amp;num);\n\tfor (int i = 0; i &lt; num; i++) {\n\t\tscanf(&quot;%d%d%d&quot;, &amp;address, &amp;val, &amp;next);\n\t\tnode[address] = { val,next };\n\t}\n}\n\nvoid get_list(int m_head, int r_head) {\n\tif (head == -1) return;\n\tint h = m_head, r = r_head;\n\tfor (int i = head; i != -1; i = node[i].next) {\n\t\tif (!set[abs(node[i].val)]) {\n\t\t\tset[abs(node[i].val)] = true;\n\t\t\tnode[h].next = i;\n\t\t\th = i;\n\t\t}\n\t\telse {\n\t\t\tnode[r].next = i;\n\t\t\tr = i;\n\t\t}\n\t}\n\tnode[h].next = node[r].next = -1;\n}\n\nint main() {\n\tparse_input();\n\tint m_head = 100001, r_head = 100002;\n\tget_list(m_head, r_head);\n\tfor (int i = node[m_head].next; i != -1; i = node[i].next) {\n\t\tprintf(&quot;%05d %d &quot;, i, node[i].val);\n\t\tif (node[i].next != -1)printf(&quot;%05d\\n&quot;, node[i].next);\n\t\telse printf(&quot;-1\\n&quot;);\n\t}\n\n\tfor (int i = node[r_head].next; i != -1; i = node[i].next) {\n\t\tprintf(&quot;%05d %d &quot;, i, node[i].val);\n\t\tif (node[i].next != -1)printf(&quot;%05d\\n&quot;, node[i].next);\n\t\telse printf(&quot;-1\\n&quot;);\n\t}\n\n}\n\n</code></pre>\n<h1 id=\"1133-Splitting-A-Linked-List-25分\"><a href=\"https://pintia.cn/problem-sets/994805342720868352/problems/994805346776760320\" target=\"_blank\" rel=\"noopener\">1133 Splitting A Linked List (25分)</a></h1>\n<p><a href=\"PAT-Advanced-LinkedList/image-20200407180332306.png\" title=\"image-20200407180332306\" class=\"gallery-item\"><img src=\"image-20200407180332306.png\" alt=\"image-20200407180332306\"></a></p>\n<h2 id=\"完整解法\">完整解法</h2>\n<p>和上题思路完全一样，注意一下拼接三条子链的时候，如果二链为-1，要将一链接在三链上，否则将会丢失三链的数据</p>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\n\nstruct Node {\n\tint val = -1;\n\tint next = -1;\n} node[100004];\n\nint address, val, next, K, num, head;\nbool set[10000] = { false };\n\nvoid parse_input() {\n\tscanf(&quot;%d%d%d&quot;, &amp;head, &amp;num, &amp;K);\n\tfor (int i = 0; i &lt; num; i++) {\n\t\tscanf(&quot;%d%d%d&quot;, &amp;address, &amp;val, &amp;next);\n\t\tnode[address] = { val,next };\n\t}\n}\n\nvoid gen_list(int n_head, int k_head, int p_head) {\n\tint n = n_head, k = k_head, p = p_head;\n\tfor (int i = head; i != -1; i = node[i].next) {\n\t\tif (node[i].val &lt; 0) {\n\t\t\tnode[n].next = i;\n\t\t\tn = i;\n\t\t}\n\t\telse if (node[i].val &lt;= K) {\n\t\t\tnode[k].next = i;\n\t\t\tk = i;\n\t\t}\n\t\telse {\n\t\t\tnode[p].next = i;\n\t\t\tp = i;\n\t\t}\n\t}\n\tnode[n].next = node[k_head].next == -1 ? node[p_head].next : node[k_head].next;\n\tnode[k].next = node[p_head].next;\n\tnode[p].next = -1;\n}\n\nint main() {\n\tparse_input();\n\tint n_head = 100001, k_head = 100002, p_head = 100003;\n\tgen_list(n_head, k_head, p_head);\n\tfor (int i = node[n_head].next; i != -1; i = node[i].next) {\n\t\tprintf(&quot;%05d %d &quot;, i, node[i].val);\n\t\tif (node[i].next != -1)printf(&quot;%05d\\n&quot;, node[i].next);\n\t\telse printf(&quot;-1\\n&quot;);\n\t}\n}\n\n</code></pre>\n<h1 id=\"1074-Reversing-Linked-List-25分\"><a href=\"https://pintia.cn/problem-sets/994805342720868352/problems/994805394512134144\" target=\"_blank\" rel=\"noopener\">1074 Reversing Linked List (25分)</a></h1>\n<p><a href=\"PAT-Advanced-LinkedList/image-20200411200937050.png\" title=\"image-20200411200937050\" class=\"gallery-item\"><img src=\"image-20200411200937050.png\" alt=\"image-20200411200937050\"></a></p>\n<h2 id=\"解法一：快慢指针-（还没完全AC，不知道被什么卡了）\">解法一：快慢指针==（还没完全AC，不知道被什么卡了）==</h2>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\n#include&lt;vector&gt;\n\nint num, head, k, address, val, next;\nstruct Node {\n\tint val;\n\tint next = -1;\n} node[100000];\n\nvoid parseInput() {\n\tstd::ios::sync_with_stdio(false); std::cin.tie(0); // 取消同步以加快iostream\n\tstd::cin &gt;&gt; head &gt;&gt; num &gt;&gt; k;\n\tfor (int i = 0; i &lt; num; i++) {\n\t\tstd::cin &gt;&gt; address &gt;&gt; val &gt;&gt; next;\n\t\tnode[address] = { val,next };\n\t}\n}\n\nint reverseLinkedList(int k) {\n\tint prev, curr = head, tail = head, i = 0;\n\tfor (int i = 1; i &lt; k ; i++) tail = node[tail].next; // 定位到第k位\n\tprev = node[tail].next;                              // 准备将k以后作为前k尾部的next\n\tnode[tail].next = -1;                                // 截断前k位，方便反转\n\twhile (curr != -1) {                                 // 反转链表 \n\t\tint next = node[curr].next;\n\t\tnode[curr].next = prev;\n\t\tprev = curr;\n\t\tcurr = next;\n\t}\n\treturn prev;\n}\n\nint main() {\n\tparseInput();\n\thead = reverseLinkedList(k);\n\tfor (int i = head; i != -1; i = node[i].next) {\n\t\tprintf(&quot;%05d %d &quot;, i, node[i].val);\n\t\tif (node[i].next != -1) printf(&quot;%05d\\n&quot;, node[i].next);\n\t\telse printf(&quot;-1\\n&quot;);\n\t}\n}\n</code></pre>\n<script src=\"https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js\"></script><script>if (typeof lightGallery !== 'undefined') {\n        var options = {\n            selector: '.gallery-item'\n        };\n        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);\n        }</script>","categories":[{"name":"Algorithm","path":"api/categories/Algorithm.json"}],"tags":[{"name":"PAT-A","path":"api/tags/PAT-A.json"}]}