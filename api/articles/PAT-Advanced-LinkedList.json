{"title":"PAT-Advanced LinkedList","slug":"PAT-Advanced-LinkedList","date":"2020-04-06T09:06:54.000Z","updated":"2020-04-06T14:43:59.644Z","comments":true,"path":"api/articles/PAT-Advanced-LinkedList.json","excerpt":"Abstract：习惯静态链表操作是关键，输出格式是个坑","covers":["image-20200406170958083.png","image-20200406210154317.png"],"content":"<link rel=\"stylesheet\" type=\"text/css\" href=\"https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css\"><div class=\".article-gallery\" <p><strong>Abstract</strong>：习惯静态链表操作是关键，输出格式是个坑<p></p>\n<a id=\"more\"></a>\n<h1 id=\"1032-Sharing-25分\"><a href=\"https://pintia.cn/problem-sets/994805342720868352/problems/994805460652113920\" target=\"_blank\" rel=\"noopener\">1032 Sharing (25分)</a></h1>\n<p><a href=\"PAT-Advanced-LinkedList/image-20200406170958083.png\" title=\"image-20200406170958083\" class=\"gallery-item\"><img src=\"image-20200406170958083.png\" alt=\"image-20200406170958083\"></a><a href=\"PAT-Advanced-LinkedList/image-20200406171008546.png\" title=\"image-20200406171008546\" class=\"gallery-item\"><img src=\"image-20200406171008546.png\" alt=\"image-20200406171008546\"></a></p>\n<h2 id=\"解法一：标记法\">解法一：标记法</h2>\n<p>同HashSet法，遍历a链表将所有经过的节点标记一次，再遍历b输出遇到的第一个标记过的节点</p>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\n\nstruct Node {\n\tint next = -1;\n\tbool is_visited = false;\n} node[100001];\n\nchar data;\nint num, s1, s2, address;\n\nvoid parse_input() {\n\tstd::cin &gt;&gt; s1 &gt;&gt; s2 &gt;&gt; num;\n\tfor (int i = 0; i &lt; num; i++) {\n\t\tstd::cin &gt;&gt; address &gt;&gt; data;\n\t\tstd::cin &gt;&gt; node[address].next;\n\t}\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n\tparse_input();\n\t\n\tfor (s1; s1 != -1; s1 = node[s1].next)\n\t\tnode[s1].is_visited = true;\n\n\tfor (s2; s2 != -1; s2 = node[s2].next)\n\t\tif (node[s2].is_visited) { printf(&quot;%05d&quot;,s2); return 0; }\n\tstd::cout &lt;&lt; -1;\n}\n\n</code></pre>\n<h2 id=\"解法二：双指针\">解法二：双指针</h2>\n<p>考虑将两条链合并，即左链结束时链接右链，右链结束时链接左链</p>\n<p>此时会出现一种现象：假设左链长n，右链长m，交点在左链的a位置，在右链的b位置，那么就有 m+a = n+b，也就是两个指针会在第二次遍历对方那条链时相遇</p>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\n\nstruct Node {\n\tchar val;\n\tint next = -1;\n} node[100002];\n\nchar val;\nint address, next, num, s1, s2;\n\nvoid parse_input() {\n\tscanf(&quot;%d%d%d&quot;, &amp;s1, &amp;s2, &amp;num);\n\tfor (int i = 0; i &lt; num; i++) {\n\t\tscanf(&quot;%d %c %d&quot;, &amp;address, &amp;val, &amp;next);\n\t\tnode[address] = { val,next };\n\t}\n}\n\nint get_intersection(int s1, int s2) {\n\tint curr_a = s1, curr_b = s2;\n\twhile (curr_a != -1 &amp;&amp; curr_b != -1) {\n\t\tif (curr_a == curr_b) return curr_a;         // 得到交点\n\t\tcurr_a = node[curr_a].next;\n\t\tcurr_b = node[curr_b].next;\n\t\tif (curr_a == -1 &amp;&amp; curr_b == -1) return -1; // 没找到，返回-1\n\t\tif (curr_a == -1) curr_a = s2;               // 接入b链\n\t\tif (curr_b == -1) curr_b = s1;               // 接入a链\n\t}\n\treturn -1;\n}\n\nint main() {\n\tparse_input();\n\tint ans = get_intersection(s1, s2);\n\tif (ans == -1) { printf(&quot;-1&quot;); return 0; }\n\tprintf(&quot;%05d&quot;, ans);\n}\n\n</code></pre>\n<h1 id=\"1052-Linked-List-Sorting-25分\"><a href=\"https://pintia.cn/problem-sets/994805342720868352/problems/994805425780670464\" target=\"_blank\" rel=\"noopener\">1052 Linked List Sorting (25分)</a></h1>\n<p><a href=\"PAT-Advanced-LinkedList/image-20200406210154317.png\" title=\"image-20200406210154317\" class=\"gallery-item\"><img src=\"image-20200406210154317.png\" alt=\"image-20200406210154317\"></a></p>\n<h2 id=\"解法一：二路归并\">解法一：二路归并</h2>\n<p>标准的链表归并排序</p>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\n\nstruct Node {\n\tint address = -1;\n\tint val = -1;\n\tint next = -1;\n} node[100002];\n\nint address, val, next, num, head;\n\nvoid parse_input() {\n\tscanf(&quot;%d%d&quot;, &amp;num, &amp;head);\n\tfor (int i = 0; i &lt; num; i++) {\n\t\tscanf(&quot;%d%d%d&quot;, &amp;address, &amp;val, &amp;next);\n\t\tnode[address] = { address,val,next };\n\t}\n}\n\nint get_len(int head) {\n\tint len = 0;\n\tfor (int i = head; i != -1; i = node[i].next) len++;\n\treturn len;\n}\n\nint merge_sort(int head) {\n\tif (head == -1 || node[head].next == -1) return head; // 递归结束条件\n\tint fast = node[head].next, slow = head;\n\twhile (fast != -1 &amp;&amp; node[fast].next != -1) {         // 定位到链表中点\n\t\tslow = node[slow].next;\n\t\tfast = node[node[fast].next].next;\n\t}\n\tint tmp = node[slow].next;\n\tnode[slow].next = -1;                                 // 截断前半段\n\tint left = merge_sort(head);                          // 递归左半边\n\tint right = merge_sort(tmp);                          // 递归右半边\n\tint h = 100001;\n\twhile (left != -1 &amp;&amp; right != -1) {                   // 转化为了 Merge two sorted list\n\t\tif (node[left].val &lt; node[right].val) {\n\t\t\tnode[h].next = left;\n\t\t\tleft = node[left].next;\n\t\t}\n\t\telse {\n\t\t\tnode[h].next = right;\n\t\t\tright = node[right].next;\n\t\t}\n\t\th = node[h].next;\n\t}\n\tnode[h].next = left != -1 ? left : right;\n\treturn node[100001].next;\n}\n\nint main() {\n\tparse_input();\n\thead = merge_sort(head);\n\tint len = get_len(head);\n\tif (len == 0) { printf(&quot;0 -1&quot;); return 0; }\n\tprintf(&quot;%d %05d\\n&quot;, len, head);\n\tfor (int i = head; i != -1; i = node[i].next) {\n\t\tprintf(&quot;%05d %d &quot;, node[i].address, node[i].val);\n\t\tif (node[i].next != -1) printf(&quot;%05d\\n&quot;, node[i].next);\n\t\telse printf(&quot;-1\\n&quot;);\n\t}\n}\n</code></pre>\n<h2 id=\"解法二：快排\">解法二：快排</h2>\n<pre><code class=\"language-cpp\">int quick_sort(int head) {\n    \n}\n</code></pre>\n</div><script src=\"https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js\"></script><script>if (typeof lightGallery !== 'undefined') {\n        var options = {\n            selector: '.gallery-item'\n        };\n        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);\n        }</script>","more":"<h1 id=\"1032-Sharing-25分\"><a href=\"https://pintia.cn/problem-sets/994805342720868352/problems/994805460652113920\" target=\"_blank\" rel=\"noopener\">1032 Sharing (25分)</a></h1>\n<p><a href=\"PAT-Advanced-LinkedList/image-20200406170958083.png\" title=\"image-20200406170958083\" class=\"gallery-item\"><img src=\"image-20200406170958083.png\" alt=\"image-20200406170958083\"></a><a href=\"PAT-Advanced-LinkedList/image-20200406171008546.png\" title=\"image-20200406171008546\" class=\"gallery-item\"><img src=\"image-20200406171008546.png\" alt=\"image-20200406171008546\"></a></p>\n<h2 id=\"解法一：标记法\">解法一：标记法</h2>\n<p>同HashSet法，遍历a链表将所有经过的节点标记一次，再遍历b输出遇到的第一个标记过的节点</p>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\n\nstruct Node {\n\tint next = -1;\n\tbool is_visited = false;\n} node[100001];\n\nchar data;\nint num, s1, s2, address;\n\nvoid parse_input() {\n\tstd::cin &gt;&gt; s1 &gt;&gt; s2 &gt;&gt; num;\n\tfor (int i = 0; i &lt; num; i++) {\n\t\tstd::cin &gt;&gt; address &gt;&gt; data;\n\t\tstd::cin &gt;&gt; node[address].next;\n\t}\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n\tparse_input();\n\t\n\tfor (s1; s1 != -1; s1 = node[s1].next)\n\t\tnode[s1].is_visited = true;\n\n\tfor (s2; s2 != -1; s2 = node[s2].next)\n\t\tif (node[s2].is_visited) { printf(&quot;%05d&quot;,s2); return 0; }\n\tstd::cout &lt;&lt; -1;\n}\n\n</code></pre>\n<h2 id=\"解法二：双指针\">解法二：双指针</h2>\n<p>考虑将两条链合并，即左链结束时链接右链，右链结束时链接左链</p>\n<p>此时会出现一种现象：假设左链长n，右链长m，交点在左链的a位置，在右链的b位置，那么就有 m+a = n+b，也就是两个指针会在第二次遍历对方那条链时相遇</p>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\n\nstruct Node {\n\tchar val;\n\tint next = -1;\n} node[100002];\n\nchar val;\nint address, next, num, s1, s2;\n\nvoid parse_input() {\n\tscanf(&quot;%d%d%d&quot;, &amp;s1, &amp;s2, &amp;num);\n\tfor (int i = 0; i &lt; num; i++) {\n\t\tscanf(&quot;%d %c %d&quot;, &amp;address, &amp;val, &amp;next);\n\t\tnode[address] = { val,next };\n\t}\n}\n\nint get_intersection(int s1, int s2) {\n\tint curr_a = s1, curr_b = s2;\n\twhile (curr_a != -1 &amp;&amp; curr_b != -1) {\n\t\tif (curr_a == curr_b) return curr_a;         // 得到交点\n\t\tcurr_a = node[curr_a].next;\n\t\tcurr_b = node[curr_b].next;\n\t\tif (curr_a == -1 &amp;&amp; curr_b == -1) return -1; // 没找到，返回-1\n\t\tif (curr_a == -1) curr_a = s2;               // 接入b链\n\t\tif (curr_b == -1) curr_b = s1;               // 接入a链\n\t}\n\treturn -1;\n}\n\nint main() {\n\tparse_input();\n\tint ans = get_intersection(s1, s2);\n\tif (ans == -1) { printf(&quot;-1&quot;); return 0; }\n\tprintf(&quot;%05d&quot;, ans);\n}\n\n</code></pre>\n<h1 id=\"1052-Linked-List-Sorting-25分\"><a href=\"https://pintia.cn/problem-sets/994805342720868352/problems/994805425780670464\" target=\"_blank\" rel=\"noopener\">1052 Linked List Sorting (25分)</a></h1>\n<p><a href=\"PAT-Advanced-LinkedList/image-20200406210154317.png\" title=\"image-20200406210154317\" class=\"gallery-item\"><img src=\"image-20200406210154317.png\" alt=\"image-20200406210154317\"></a></p>\n<h2 id=\"解法一：二路归并\">解法一：二路归并</h2>\n<p>标准的链表归并排序</p>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\n\nstruct Node {\n\tint address = -1;\n\tint val = -1;\n\tint next = -1;\n} node[100002];\n\nint address, val, next, num, head;\n\nvoid parse_input() {\n\tscanf(&quot;%d%d&quot;, &amp;num, &amp;head);\n\tfor (int i = 0; i &lt; num; i++) {\n\t\tscanf(&quot;%d%d%d&quot;, &amp;address, &amp;val, &amp;next);\n\t\tnode[address] = { address,val,next };\n\t}\n}\n\nint get_len(int head) {\n\tint len = 0;\n\tfor (int i = head; i != -1; i = node[i].next) len++;\n\treturn len;\n}\n\nint merge_sort(int head) {\n\tif (head == -1 || node[head].next == -1) return head; // 递归结束条件\n\tint fast = node[head].next, slow = head;\n\twhile (fast != -1 &amp;&amp; node[fast].next != -1) {         // 定位到链表中点\n\t\tslow = node[slow].next;\n\t\tfast = node[node[fast].next].next;\n\t}\n\tint tmp = node[slow].next;\n\tnode[slow].next = -1;                                 // 截断前半段\n\tint left = merge_sort(head);                          // 递归左半边\n\tint right = merge_sort(tmp);                          // 递归右半边\n\tint h = 100001;\n\twhile (left != -1 &amp;&amp; right != -1) {                   // 转化为了 Merge two sorted list\n\t\tif (node[left].val &lt; node[right].val) {\n\t\t\tnode[h].next = left;\n\t\t\tleft = node[left].next;\n\t\t}\n\t\telse {\n\t\t\tnode[h].next = right;\n\t\t\tright = node[right].next;\n\t\t}\n\t\th = node[h].next;\n\t}\n\tnode[h].next = left != -1 ? left : right;\n\treturn node[100001].next;\n}\n\nint main() {\n\tparse_input();\n\thead = merge_sort(head);\n\tint len = get_len(head);\n\tif (len == 0) { printf(&quot;0 -1&quot;); return 0; }\n\tprintf(&quot;%d %05d\\n&quot;, len, head);\n\tfor (int i = head; i != -1; i = node[i].next) {\n\t\tprintf(&quot;%05d %d &quot;, node[i].address, node[i].val);\n\t\tif (node[i].next != -1) printf(&quot;%05d\\n&quot;, node[i].next);\n\t\telse printf(&quot;-1\\n&quot;);\n\t}\n}\n</code></pre>\n<h2 id=\"解法二：快排\">解法二：快排</h2>\n<pre><code class=\"language-cpp\">int quick_sort(int head) {\n    \n}\n</code></pre>\n<script src=\"https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js\"></script><script>if (typeof lightGallery !== 'undefined') {\n        var options = {\n            selector: '.gallery-item'\n        };\n        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);\n        }</script>","categories":[{"name":"Algorithm","path":"api/categories/Algorithm.json"}],"tags":[{"name":"PAT-A","path":"api/tags/PAT-A.json"}]}