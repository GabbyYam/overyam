{"title":"Search-Medium","slug":"Search-Medium","date":"2020-04-27T12:04:07.000Z","updated":"2020-05-05T06:45:36.752Z","comments":true,"path":"api/articles/Search-Medium.json","excerpt":"Abstract：leetcode 搜索相关题解合集","covers":["image-20200427200546326.png","image-20200430141640301.png","image-20200504151213466.png"],"content":"<link rel=\"stylesheet\" type=\"text/css\" href=\"https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css\"><div class=\".article-gallery\" <p><strong>Abstract</strong>：leetcode 搜索相关题解合集<p></p>\n<a id=\"more\"></a>\n<h1 id=\"33-Search-in-Rotated-Sorted-Array\"><a href=\"https://leetcode-cn.com/problems/search-in-rotated-sorted-array/\" target=\"_blank\" rel=\"noopener\">33. Search in Rotated Sorted Array</a></h1>\n<p><a href=\"Search-Medium/image-20200427200546326.png\" title=\"image-20200427200546326\" class=\"gallery-item\"><img src=\"image-20200427200546326.png\" alt=\"image-20200427200546326\"></a></p>\n<h2 id=\"解法一：二分查找\">解法一：二分查找</h2>\n<p>暴力法就不用多说了，本题是部分有序，但是不影响使用二分查找</p>\n<p>由于二分后，必然半边是有序的，我们就可以利用这半边作为线索来搜索</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    int search(vector&lt;int&gt;&amp; nums, int target) {\n        if(nums.empty()) return -1;\n        int lo = 0, hi = nums.size() - 1;\n        while (lo &lt;= hi) {\n            int mid = (lo + hi) / 2;\n            if (nums[mid] == target) return mid;\n            if (nums[0] &lt;= nums[mid]) {\n                if (nums[0] &lt;= target &amp;&amp; target &lt; nums[mid]) {\n                    hi = mid - 1;\n                } else {\n                    lo = mid + 1;\n                }\n            } else {\n                if (nums[mid] &lt; target &amp;&amp; target &lt;= nums[nums.size() - 1]) {\n                    lo = mid + 1;\n                } else {\n                    hi = mid - 1;\n                }\n            }\n        }\n        return -1;\n    }\n};\n</code></pre>\n<h1 id=\"34-Find-First-and-Last-Position-of-Element-in-Sorted-Array\"><a href=\"https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/\" target=\"_blank\" rel=\"noopener\">34. Find First and Last Position of Element in Sorted Array</a></h1>\n<p><a href=\"Search-Medium/image-20200430141640301.png\" title=\"image-20200430141640301\" class=\"gallery-item\"><img src=\"image-20200430141640301.png\" alt=\"image-20200430141640301\"></a></p>\n<h2 id=\"解法一：标准二分查找\">解法一：标准二分查找</h2>\n<p>标准的二分查找，只不过找到之后还要向左右再搜索一下，注意一下越界判定就行</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) {\n        int lo = 0, hi = nums.size() - 1;\n        while(lo &lt;= hi){\n            int mid = (lo + hi) / 2;\n            if(nums[mid] == target){\n                int i = mid, j = mid;\n                while(i &gt; 0 &amp;&amp; nums[i - 1] == target) i--;\n                while(j &lt; nums.size() - 1 &amp;&amp; nums[j + 1] == target) j++;\n                return {i,j};\n            } \n            else if(nums[mid] &lt; target)\n                lo = mid + 1;\n            else if(nums[mid] &gt; target)\n                hi = mid - 1;\n        }\n        return {-1,-1};\n    }\n};\n</code></pre>\n<h1 id=\"130-Surrounded-Regions\"><a href=\"https://leetcode-cn.com/problems/surrounded-regions/\" target=\"_blank\" rel=\"noopener\">130. Surrounded Regions</a></h1>\n<p><a href=\"Search-Medium/image-20200504151213466.png\" title=\"image-20200504151213466\" class=\"gallery-item\"><img src=\"image-20200504151213466.png\" alt=\"image-20200504151213466\"></a></p>\n<h2 id=\"解法一：递归dfs\">解法一：递归dfs</h2>\n<p>因为只有边缘的O不会被替换掉，因此从边缘的O开始找就行了，将边缘的O全部标记，最后再替换掉剩余的O</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    void solve(vector&lt;vector&lt;char&gt;&gt;&amp; board) {\n        if(board.empty()) return;\n        for (int i = 0; i &lt; board.size(); i++){\n            for (int j = 0; j &lt; board[0].size(); j++){\n                if(i == 0 || j == 0 || i == board.size() - 1 || j == board[0].size() - 1)\n                    dfs(board, i, j);\n            }\n        }\n\n        for(vector&lt;char&gt;&amp; v : board)\n            for(char&amp; c : v)\n                c = c == 'Y' ? 'O' : 'X';\n    }\n\n    void dfs(vector&lt;vector&lt;char&gt;&gt;&amp; board, int i, int j){\n        int row = board.size() - 1, col = board[0].size() - 1;\n        if(i &gt; row || i &lt; 0 || j &gt; col || j &lt; 0 || board[i][j] == 'X' || board[i][j] == 'Y') return;\n        board[i][j] = 'Y';\n        dfs(board, i + 1, j);\n        dfs(board, i, j + 1);\n        dfs(board, i - 1, j);\n        dfs(board, i, j - 1);\n    }\n};\n</code></pre>\n<h2 id=\"解法二：迭代dfs\">解法二：迭代dfs</h2>\n<p>每次从队首推入</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    struct Pos{\n        int x, y;\n        Pos(int a, int b) : x(a), y(b) {};\n    };\n\n    void solve(vector&lt;vector&lt;char&gt;&gt;&amp; board) {\n        if(board.empty()) return;\n        for (int i = 0; i &lt; board.size(); i++)\n            for (int j = 0; j &lt; board[0].size(); j++)\n                if(i == 0 || j == 0 || i == board.size() - 1 || j == board[0].size() - 1)\n                    bfs(board, i, j);\n\n        for(vector&lt;char&gt;&amp; v : board)\n            for(char&amp; c : v)\n                c = c == 'Y' ? 'O' : 'X';\n    }\n\n    void bfs(vector&lt;vector&lt;char&gt;&gt;&amp; board, int i, int j){\n        int row = board.size() - 1, col = board[0].size() - 1;\n        deque&lt;Pos&gt; q;\n        q.push_front({ i, j });\n        while(!q.empty()){\n            Pos curr = q.front(); q.pop_front();\n            i = curr.x, j = curr.y;\n            if(i &gt; row || i &lt; 0 || j &gt; col || j &lt; 0 || board[i][j] == 'X' || board[i][j] == 'Y')\n                continue;\n            board[i][j] = 'Y';\n            q.push_front({ i + 1, j });\n            q.push_front({ i - 1, j });\n            q.push_front({ i, j + 1 });\n            q.push_front({ i, j - 1 });\n        }\n    }\n};\n</code></pre>\n<h2 id=\"解法三：迭代bfs\">解法三：迭代bfs</h2>\n<p>每次从队尾推入</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    struct Pos{\n        int x, y;\n        Pos(int a, int b) : x(a), y(b) {};\n    };\n\n    void solve(vector&lt;vector&lt;char&gt;&gt;&amp; board) {\n        if(board.empty()) return;\n        for (int i = 0; i &lt; board.size(); i++)\n            for (int j = 0; j &lt; board[0].size(); j++)\n                if(i == 0 || j == 0 || i == board.size() - 1 || j == board[0].size() - 1)\n                    bfs(board, i, j);\n\n        for(vector&lt;char&gt;&amp; v : board)\n            for(char&amp; c : v)\n                c = c == 'Y' ? 'O' : 'X';\n    }\n\n    void bfs(vector&lt;vector&lt;char&gt;&gt;&amp; board, int i, int j){\n        int row = board.size() - 1, col = board[0].size() - 1;\n        queue&lt;Pos&gt; q;\n        q.push({ i, j });\n        while(!q.empty()){\n            Pos curr = q.front(); q.pop();\n            i = curr.x, j = curr.y;\n            if(i &gt; row || i &lt; 0 || j &gt; col || j &lt; 0 || board[i][j] == 'X' || board[i][j] == 'Y')\n                continue;\n            board[i][j] = 'Y';\n            q.push({ i + 1, j });\n            q.push({ i - 1, j });\n            q.push({ i, j + 1 });\n            q.push({ i, j - 1 });\n        }\n    }\n};\n</code></pre>\n</div><script src=\"https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js\"></script><script>if (typeof lightGallery !== 'undefined') {\n        var options = {\n            selector: '.gallery-item'\n        };\n        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);\n        }</script>","more":"<h1 id=\"33-Search-in-Rotated-Sorted-Array\"><a href=\"https://leetcode-cn.com/problems/search-in-rotated-sorted-array/\" target=\"_blank\" rel=\"noopener\">33. Search in Rotated Sorted Array</a></h1>\n<p><a href=\"Search-Medium/image-20200427200546326.png\" title=\"image-20200427200546326\" class=\"gallery-item\"><img src=\"image-20200427200546326.png\" alt=\"image-20200427200546326\"></a></p>\n<h2 id=\"解法一：二分查找\">解法一：二分查找</h2>\n<p>暴力法就不用多说了，本题是部分有序，但是不影响使用二分查找</p>\n<p>由于二分后，必然半边是有序的，我们就可以利用这半边作为线索来搜索</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    int search(vector&lt;int&gt;&amp; nums, int target) {\n        if(nums.empty()) return -1;\n        int lo = 0, hi = nums.size() - 1;\n        while (lo &lt;= hi) {\n            int mid = (lo + hi) / 2;\n            if (nums[mid] == target) return mid;\n            if (nums[0] &lt;= nums[mid]) {\n                if (nums[0] &lt;= target &amp;&amp; target &lt; nums[mid]) {\n                    hi = mid - 1;\n                } else {\n                    lo = mid + 1;\n                }\n            } else {\n                if (nums[mid] &lt; target &amp;&amp; target &lt;= nums[nums.size() - 1]) {\n                    lo = mid + 1;\n                } else {\n                    hi = mid - 1;\n                }\n            }\n        }\n        return -1;\n    }\n};\n</code></pre>\n<h1 id=\"34-Find-First-and-Last-Position-of-Element-in-Sorted-Array\"><a href=\"https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/\" target=\"_blank\" rel=\"noopener\">34. Find First and Last Position of Element in Sorted Array</a></h1>\n<p><a href=\"Search-Medium/image-20200430141640301.png\" title=\"image-20200430141640301\" class=\"gallery-item\"><img src=\"image-20200430141640301.png\" alt=\"image-20200430141640301\"></a></p>\n<h2 id=\"解法一：标准二分查找\">解法一：标准二分查找</h2>\n<p>标准的二分查找，只不过找到之后还要向左右再搜索一下，注意一下越界判定就行</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) {\n        int lo = 0, hi = nums.size() - 1;\n        while(lo &lt;= hi){\n            int mid = (lo + hi) / 2;\n            if(nums[mid] == target){\n                int i = mid, j = mid;\n                while(i &gt; 0 &amp;&amp; nums[i - 1] == target) i--;\n                while(j &lt; nums.size() - 1 &amp;&amp; nums[j + 1] == target) j++;\n                return {i,j};\n            } \n            else if(nums[mid] &lt; target)\n                lo = mid + 1;\n            else if(nums[mid] &gt; target)\n                hi = mid - 1;\n        }\n        return {-1,-1};\n    }\n};\n</code></pre>\n<h1 id=\"130-Surrounded-Regions\"><a href=\"https://leetcode-cn.com/problems/surrounded-regions/\" target=\"_blank\" rel=\"noopener\">130. Surrounded Regions</a></h1>\n<p><a href=\"Search-Medium/image-20200504151213466.png\" title=\"image-20200504151213466\" class=\"gallery-item\"><img src=\"image-20200504151213466.png\" alt=\"image-20200504151213466\"></a></p>\n<h2 id=\"解法一：递归dfs\">解法一：递归dfs</h2>\n<p>因为只有边缘的O不会被替换掉，因此从边缘的O开始找就行了，将边缘的O全部标记，最后再替换掉剩余的O</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    void solve(vector&lt;vector&lt;char&gt;&gt;&amp; board) {\n        if(board.empty()) return;\n        for (int i = 0; i &lt; board.size(); i++){\n            for (int j = 0; j &lt; board[0].size(); j++){\n                if(i == 0 || j == 0 || i == board.size() - 1 || j == board[0].size() - 1)\n                    dfs(board, i, j);\n            }\n        }\n\n        for(vector&lt;char&gt;&amp; v : board)\n            for(char&amp; c : v)\n                c = c == 'Y' ? 'O' : 'X';\n    }\n\n    void dfs(vector&lt;vector&lt;char&gt;&gt;&amp; board, int i, int j){\n        int row = board.size() - 1, col = board[0].size() - 1;\n        if(i &gt; row || i &lt; 0 || j &gt; col || j &lt; 0 || board[i][j] == 'X' || board[i][j] == 'Y') return;\n        board[i][j] = 'Y';\n        dfs(board, i + 1, j);\n        dfs(board, i, j + 1);\n        dfs(board, i - 1, j);\n        dfs(board, i, j - 1);\n    }\n};\n</code></pre>\n<h2 id=\"解法二：迭代dfs\">解法二：迭代dfs</h2>\n<p>每次从队首推入</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    struct Pos{\n        int x, y;\n        Pos(int a, int b) : x(a), y(b) {};\n    };\n\n    void solve(vector&lt;vector&lt;char&gt;&gt;&amp; board) {\n        if(board.empty()) return;\n        for (int i = 0; i &lt; board.size(); i++)\n            for (int j = 0; j &lt; board[0].size(); j++)\n                if(i == 0 || j == 0 || i == board.size() - 1 || j == board[0].size() - 1)\n                    bfs(board, i, j);\n\n        for(vector&lt;char&gt;&amp; v : board)\n            for(char&amp; c : v)\n                c = c == 'Y' ? 'O' : 'X';\n    }\n\n    void bfs(vector&lt;vector&lt;char&gt;&gt;&amp; board, int i, int j){\n        int row = board.size() - 1, col = board[0].size() - 1;\n        deque&lt;Pos&gt; q;\n        q.push_front({ i, j });\n        while(!q.empty()){\n            Pos curr = q.front(); q.pop_front();\n            i = curr.x, j = curr.y;\n            if(i &gt; row || i &lt; 0 || j &gt; col || j &lt; 0 || board[i][j] == 'X' || board[i][j] == 'Y')\n                continue;\n            board[i][j] = 'Y';\n            q.push_front({ i + 1, j });\n            q.push_front({ i - 1, j });\n            q.push_front({ i, j + 1 });\n            q.push_front({ i, j - 1 });\n        }\n    }\n};\n</code></pre>\n<h2 id=\"解法三：迭代bfs\">解法三：迭代bfs</h2>\n<p>每次从队尾推入</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    struct Pos{\n        int x, y;\n        Pos(int a, int b) : x(a), y(b) {};\n    };\n\n    void solve(vector&lt;vector&lt;char&gt;&gt;&amp; board) {\n        if(board.empty()) return;\n        for (int i = 0; i &lt; board.size(); i++)\n            for (int j = 0; j &lt; board[0].size(); j++)\n                if(i == 0 || j == 0 || i == board.size() - 1 || j == board[0].size() - 1)\n                    bfs(board, i, j);\n\n        for(vector&lt;char&gt;&amp; v : board)\n            for(char&amp; c : v)\n                c = c == 'Y' ? 'O' : 'X';\n    }\n\n    void bfs(vector&lt;vector&lt;char&gt;&gt;&amp; board, int i, int j){\n        int row = board.size() - 1, col = board[0].size() - 1;\n        queue&lt;Pos&gt; q;\n        q.push({ i, j });\n        while(!q.empty()){\n            Pos curr = q.front(); q.pop();\n            i = curr.x, j = curr.y;\n            if(i &gt; row || i &lt; 0 || j &gt; col || j &lt; 0 || board[i][j] == 'X' || board[i][j] == 'Y')\n                continue;\n            board[i][j] = 'Y';\n            q.push({ i + 1, j });\n            q.push({ i - 1, j });\n            q.push({ i, j + 1 });\n            q.push({ i, j - 1 });\n        }\n    }\n};\n</code></pre>\n<script src=\"https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js\"></script><script>if (typeof lightGallery !== 'undefined') {\n        var options = {\n            selector: '.gallery-item'\n        };\n        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);\n        }</script>","categories":[{"name":"Algorithm","path":"api/categories/Algorithm.json"}],"tags":[{"name":"Leetcode","path":"api/tags/Leetcode.json"}]}