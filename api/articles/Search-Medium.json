{"title":"Search-Medium","slug":"Search-Medium","date":"2020-04-27T12:04:07.000Z","updated":"2020-05-23T07:29:20.842Z","comments":true,"path":"api/articles/Search-Medium.json","excerpt":"Abstract：leetcode 搜索相关题解合集","covers":["image-20200427200546326.png","image-20200430141640301.png","image-20200504151213466.png","image-20200506145713267.png","image-20200507205502068.png","image-20200510163022286.png","image-20200510180157121.png","image-20200512163016773.png","image-20200517110032569.png","image-20200523135552024.png","image-20200523135602524.png"],"content":"<link rel=\"stylesheet\" type=\"text/css\" href=\"https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css\"><div class=\".article-gallery\" <p><strong>Abstract</strong>：leetcode 搜索相关题解合集<p></p>\n<a id=\"more\"></a>\n<h1 id=\"33-Search-in-Rotated-Sorted-Array\"><a href=\"https://leetcode-cn.com/problems/search-in-rotated-sorted-array/\" target=\"_blank\" rel=\"noopener\">33. Search in Rotated Sorted Array</a></h1>\n<p><a href=\"Search-Medium/image-20200427200546326.png\" title=\"image-20200427200546326\" class=\"gallery-item\"><img src=\"image-20200427200546326.png\" alt=\"image-20200427200546326\"></a></p>\n<h2 id=\"解法一：二分查找\">解法一：二分查找</h2>\n<p>线性遍历就不用多说了，本题是部分有序，但是不影响使用二分查找</p>\n<p>由于二分后，必然半边是有序的，我们就可以利用这半边作为线索来搜索</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    int search(vector&lt;int&gt;&amp; nums, int target) {\n        if(nums.empty()) return -1;\n        int lo = 0, hi = nums.size() - 1;\n        while (lo &lt;= hi) {\n            int mid = (lo + hi) / 2;\n            if (nums[mid] == target) return mid;\n            if (nums[0] &lt;= nums[mid]) {\n                if (nums[0] &lt;= target &amp;&amp; target &lt; nums[mid]) {\n                    hi = mid - 1;\n                } else {\n                    lo = mid + 1;\n                }\n            } else {\n                if (nums[mid] &lt; target &amp;&amp; target &lt;= nums[nums.size() - 1]) {\n                    lo = mid + 1;\n                } else {\n                    hi = mid - 1;\n                }\n            }\n        }\n        return -1;\n    }\n};\n</code></pre>\n<h1 id=\"34-Find-First-and-Last-Position-of-Element-in-Sorted-Array\"><a href=\"https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/\" target=\"_blank\" rel=\"noopener\">34. Find First and Last Position of Element in Sorted Array</a></h1>\n<p><a href=\"Search-Medium/image-20200430141640301.png\" title=\"image-20200430141640301\" class=\"gallery-item\"><img src=\"image-20200430141640301.png\" alt=\"image-20200430141640301\"></a></p>\n<h2 id=\"解法一：标准二分查找\">解法一：标准二分查找</h2>\n<p>标准的二分查找，只不过找到之后还要向左右再搜索一下，注意一下越界判定就行</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) {\n        int lo = 0, hi = nums.size() - 1;\n        while(lo &lt;= hi){\n            int mid = (lo + hi) / 2;\n            if(nums[mid] == target){\n                int i = mid, j = mid;\n                while(i &gt; 0 &amp;&amp; nums[i - 1] == target) i--;\n                while(j &lt; nums.size() - 1 &amp;&amp; nums[j + 1] == target) j++;\n                return {i,j};\n            } \n            else if(nums[mid] &lt; target)\n                lo = mid + 1;\n            else if(nums[mid] &gt; target)\n                hi = mid - 1;\n        }\n        return {-1,-1};\n    }\n};\n</code></pre>\n<h1 id=\"130-Surrounded-Regions\"><a href=\"https://leetcode-cn.com/problems/surrounded-regions/\" target=\"_blank\" rel=\"noopener\">130. Surrounded Regions</a></h1>\n<p><a href=\"Search-Medium/image-20200504151213466.png\" title=\"image-20200504151213466\" class=\"gallery-item\"><img src=\"image-20200504151213466.png\" alt=\"image-20200504151213466\"></a></p>\n<h2 id=\"解法一：递归dfs\">解法一：递归dfs</h2>\n<p>因为只有边缘的O不会被替换掉，因此从边缘的O开始找就行了，将边缘的O全部标记，最后再替换掉剩余的O</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    void solve(vector&lt;vector&lt;char&gt;&gt;&amp; board) {\n        if(board.empty()) return;\n        for (int i = 0; i &lt; board.size(); i++){\n            for (int j = 0; j &lt; board[0].size(); j++){\n                if(i == 0 || j == 0 || i == board.size() - 1 || j == board[0].size() - 1)\n                    dfs(board, i, j);\n            }\n        }\n\n        for(vector&lt;char&gt;&amp; v : board)\n            for(char&amp; c : v)\n                c = c == 'Y' ? 'O' : 'X';\n    }\n\n    void dfs(vector&lt;vector&lt;char&gt;&gt;&amp; board, int i, int j){\n        int row = board.size() - 1, col = board[0].size() - 1;\n        if(i &gt; row || i &lt; 0 || j &gt; col || j &lt; 0 || board[i][j] == 'X' || board[i][j] == 'Y') return;\n        board[i][j] = 'Y';\n        dfs(board, i + 1, j);\n        dfs(board, i, j + 1);\n        dfs(board, i - 1, j);\n        dfs(board, i, j - 1);\n    }\n};\n</code></pre>\n<h2 id=\"解法二：迭代dfs\">解法二：迭代dfs</h2>\n<p>每次从队首推入</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    struct Pos{\n        int x, y;\n        Pos(int a, int b) : x(a), y(b) {};\n    };\n\n    void solve(vector&lt;vector&lt;char&gt;&gt;&amp; board) {\n        if(board.empty()) return;\n        for (int i = 0; i &lt; board.size(); i++)\n            for (int j = 0; j &lt; board[0].size(); j++)\n                if(i == 0 || j == 0 || i == board.size() - 1 || j == board[0].size() - 1)\n                    bfs(board, i, j);\n\n        for(vector&lt;char&gt;&amp; v : board)\n            for(char&amp; c : v)\n                c = c == 'Y' ? 'O' : 'X';\n    }\n\n    void bfs(vector&lt;vector&lt;char&gt;&gt;&amp; board, int i, int j){\n        int row = board.size() - 1, col = board[0].size() - 1;\n        deque&lt;Pos&gt; q;\n        q.push_front({ i, j });\n        while(!q.empty()){\n            Pos curr = q.front(); q.pop_front();\n            i = curr.x, j = curr.y;\n            if(i &gt; row || i &lt; 0 || j &gt; col || j &lt; 0 || board[i][j] == 'X' || board[i][j] == 'Y')\n                continue;\n            board[i][j] = 'Y';\n            q.push_front({ i + 1, j });\n            q.push_front({ i - 1, j });\n            q.push_front({ i, j + 1 });\n            q.push_front({ i, j - 1 });\n        }\n    }\n};\n</code></pre>\n<h2 id=\"解法三：迭代bfs\">解法三：迭代bfs</h2>\n<p>每次从队尾推入</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    struct Pos{\n        int x, y;\n        Pos(int a, int b) : x(a), y(b) {};\n    };\n\n    void solve(vector&lt;vector&lt;char&gt;&gt;&amp; board) {\n        if(board.empty()) return;\n        for (int i = 0; i &lt; board.size(); i++)\n            for (int j = 0; j &lt; board[0].size(); j++)\n                if(i == 0 || j == 0 || i == board.size() - 1 || j == board[0].size() - 1)\n                    bfs(board, i, j);\n\n        for(vector&lt;char&gt;&amp; v : board)\n            for(char&amp; c : v)\n                c = c == 'Y' ? 'O' : 'X';\n    }\n\n    void bfs(vector&lt;vector&lt;char&gt;&gt;&amp; board, int i, int j){\n        int row = board.size() - 1, col = board[0].size() - 1;\n        queue&lt;Pos&gt; q;\n        q.push({ i, j });\n        while(!q.empty()){\n            Pos curr = q.front(); q.pop();\n            i = curr.x, j = curr.y;\n            if(i &gt; row || i &lt; 0 || j &gt; col || j &lt; 0 || board[i][j] == 'X' || board[i][j] == 'Y')\n                continue;\n            board[i][j] = 'Y';\n            q.push({ i + 1, j });\n            q.push({ i - 1, j });\n            q.push({ i, j + 1 });\n            q.push({ i, j - 1 });\n        }\n    }\n};\n</code></pre>\n<h1 id=\"200-Number-of-Islands\"><a href=\"https://leetcode-cn.com/problems/number-of-islands/\" target=\"_blank\" rel=\"noopener\">200. Number of Islands</a></h1>\n<p><a href=\"Search-Medium/image-20200506145713267.png\" title=\"image-20200506145713267\" class=\"gallery-item\"><img src=\"image-20200506145713267.png\" alt=\"image-20200506145713267\"></a></p>\n<h2 id=\"解法一：同上题\">解法一：同上题</h2>\n<p>贴一个递归dfs</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) {\n        if(grid.empty()) return 0;\n        int res = 0, row = grid.size(), col = grid[0].size();\n        for (int i = 0; i &lt; row; i++) {\n            for (int j = 0; j &lt; col; j++) {\n                if (grid[i][j] == '1') {\n                    res++;\n                    dfs(grid, i, j);\n                }\n            }\n        }\n        return res;\n    }\n\n    void dfs(vector&lt;vector&lt;char&gt;&gt;&amp; grid, int i, int j) {\n        if(i &lt; 0 || j &lt; 0 || i &gt; grid.size() - 1 || j &gt; grid[0].size() - 1 ||\n           grid[i][j] == '0') return;\n        grid[i][j] = '0';\n        dfs(grid, i + 1, j);\n        dfs(grid, i - 1, j);\n        dfs(grid, i, j + 1);\n        dfs(grid, i, j - 1); \n    }\n};\n</code></pre>\n<h1 id=\"240-Search-a-2D-Matrix-II\"><a href=\"https://leetcode-cn.com/problems/search-a-2d-matrix-ii/\" target=\"_blank\" rel=\"noopener\">240. Search a 2D Matrix II</a></h1>\n<p><a href=\"Search-Medium/image-20200507205502068.png\" title=\"image-20200507205502068\" class=\"gallery-item\"><img src=\"image-20200507205502068.png\" alt=\"image-20200507205502068\"></a></p>\n<h2 id=\"解法一：逐行二分查找\">解法一：逐行二分查找</h2>\n<p>先看target在不在这行的区间，如果在就二分查找一下，直到找到，复杂度O(mlogn)</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) {\n        if(matrix.empty() || matrix[0].empty()) return false;\n        int row = matrix.size(), col = matrix[0].size();\n        for(int i = 0; i &lt; row; i++) {\n            if(matrix[i][0] &lt;= target &amp;&amp; matrix[i][col - 1] &gt;= target &amp;&amp; binarySearch(matrix[i], target)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    bool binarySearch(vector&lt;int&gt; row, int target) {\n        int lo = 0, hi = row.size() - 1;\n        while (lo &lt;= hi) {\n            int mid = (lo + hi) / 2;\n            if(target == row[mid]) return true;\n            else if(target &lt; row[mid]) hi = mid - 1;\n            else lo = mid + 1;\n        }\n        return false;\n    }\n};\n</code></pre>\n<h2 id=\"解法二：减治法\">解法二：减治法</h2>\n<ul>\n<li>\n<p>从左下角开始找，如果大了向上移动一行，小了则向右移动一列，这样不会错过target，因为只有左下角的变化是单向的，也就是不会出现两条路径上都增大或减小的情况</p>\n</li>\n<li>\n<p>复杂度O(m + n)</p>\n</li>\n</ul>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) {\n        int row = matrix.size() - 1, col = 0;\n        while (row &gt; - 1 &amp;&amp; col &lt; matrix[0].size()) {\n            int val = matrix[row][col];\n            if(val == target) \n                return true;\n            else if(val &lt; target)\n                col++;\n            else \n                row--; \n        }\n        return false;\n    }\n};\n</code></pre>\n<h1 id=\"153-Find-Minimum-in-Rotated-Sorted-Array\"><a href=\"https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/\" target=\"_blank\" rel=\"noopener\">153. Find Minimum in Rotated Sorted Array</a></h1>\n<p><a href=\"Search-Medium/image-20200510163022286.png\" title=\"image-20200510163022286\" class=\"gallery-item\"><img src=\"image-20200510163022286.png\" alt=\"image-20200510163022286\"></a></p>\n<h2 id=\"解法零：暴力法\">解法零：暴力法</h2>\n<p>线性遍历，太俗就不说了</p>\n<h2 id=\"解法一：二分查找-v2\">解法一：二分查找</h2>\n<ul>\n<li>因为数组被旋转了，所以查找的时候只有一边是有序的</li>\n<li>如果满足 <code>nums[mid] &gt; nums[mid + 1]</code> 或 <code>nums[mid] &lt; nums[mid - 1]</code>都说明边界找到了</li>\n<li>如果没找到，判断哪一边是有序的，如果 <code>nums[mid] &lt; nums[0]</code>，说明当前在边界右边，要向左搜索，否则向右搜索</li>\n<li>有一种情况可能会让我们的代码越界，那就是数组没有被旋转的时候，此时会一直向右搜索直到 <code>mid = nums.size() - 1</code>，当我们判断 mid + 1 时就会越界，因此对于这种情况要特殊处理</li>\n</ul>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    int findMin(vector&lt;int&gt;&amp; nums) {\n        int lo = 0, hi = nums.size() - 1;\n        if(nums.size() == 1) return nums[0];\n        if(nums[hi] &gt; nums[lo]) return nums[0];\n        while(lo &lt;= hi) {\n            int mid = (lo + hi) / 2;\n            if(nums[mid] &gt; nums[mid + 1])\n                return nums[mid + 1];\n            if(nums[mid] &lt; nums[mid - 1])\n                return nums[mid];\n            if(nums[mid] &gt; nums[0])\n                lo = mid + 1;\n            else\n                hi = mid - 1;\n        }\n        return -1;\n    }\n};\n</code></pre>\n<h1 id=\"162-Find-Peak-Element\"><a href=\"https://leetcode-cn.com/problems/find-peak-element/\" target=\"_blank\" rel=\"noopener\">162. Find Peak Element</a></h1>\n<p><a href=\"Search-Medium/image-20200510180157121.png\" title=\"image-20200510180157121\" class=\"gallery-item\"><img src=\"image-20200510180157121.png\" alt=\"image-20200510180157121\"></a></p>\n<h2 id=\"解法一：暴力法\">解法一：暴力法</h2>\n<p>线性遍历，没想到居然95%，那就贴一下吧</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    int findPeakElement(vector&lt;int&gt;&amp; nums) {\n        int len = nums.size();\n        if(len == 1 || nums[0] &gt; nums[1]) return 0;\n        if(nums[len - 1] &gt; nums[len - 2]) return len - 1; \n        for(int i = 1; i &lt; nums.size() - 1; i++) {\n            if(nums[i] &gt; nums[i - 1] &amp;&amp; nums[i] &gt; nums[i + 1])\n                return i;\n        }\n        return -1;\n    }\n};\n</code></pre>\n<h2 id=\"解法二：二分查找\">解法二：二分查找</h2>\n<h1 id=\"322-Coin-Change\"><a href=\"https://leetcode-cn.com/problems/coin-change/\" target=\"_blank\" rel=\"noopener\">322. Coin Change</a></h1>\n<p><a href=\"Search-Medium/image-20200512163016773.png\" title=\"image-20200512163016773\" class=\"gallery-item\"><img src=\"image-20200512163016773.png\" alt=\"image-20200512163016773\"></a></p>\n<h2 id=\"解法一：DP\">解法一：DP</h2>\n<p>首先这题可以看作完全背包问题</p>\n<p>如果已知<code>amount &lt;  n</code>的答案，那么对于<code>amount == n</code>，有</p>\n<pre><code class=\"language-cpp\">dp[n] = min(dp[n], dp[n - coin_j]) { coin_j &lt; amount }\n</code></pre>\n<p>所以从0构造amount的前缀解，在通过转移方程即可求得结果</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    int coinChange(vector&lt;int&gt;&amp; coins, int amount) {\n        vector&lt;int&gt; dp(amount + 1, amount + 1); // dp值最大为amount\n        dp[0] = 0;\n        for(int i = 1; i &lt;= amount; i++) {\n            for(int j = 0; j &lt; coins.size(); j++) {\n                if(coins[j] &lt;= i)\n                    dp[i] = std::min(dp[i], dp[i - coins[j]] + 1);\n            }\n        }\n        return dp[amount] &gt; amount ? -1 : dp[amount];\n    }\n};\n</code></pre>\n<h2 id=\"解法二：贪心-dfs\">解法二：贪心 + dfs</h2>\n<p>这种找零钱的题第一反应当然是要从最大的开始找</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    int coinChange(vector&lt;int&gt;&amp; coins, int amount) {\n        std::sort(coins.rbegin(), coins.rend());\n        int cnt = 0;\n        for(int i = 0; i &lt; coins.size(); i++) {\n            if(amount == 0) return cnt;\n            if(coins[i] &gt; amount) continue;\n            int val = amount / coins[i];\n            amount -= coins[i] * val;\n            cnt += val;\n        }\n        return cnt == 0 ? -1 : cnt;\n    }\n};\n</code></pre>\n<p>但是直接贪心可能会导致找不出来的情况，所以要加入dfs进行搜索</p>\n<pre><code class=\"language-cpp\">int coinChange(vector&lt;int&gt;&amp; coins, int amount) {\n        std::sort(coins.rbegin(), coins.rend());\n        int res = INT32_MAX;\n        dfs(coins, amount, 0, 0, res);\n        return res == INT32_MAX ? -1 : res;\n    }\n\nvoid dfs(vector&lt;int&gt;&amp; coins, int amount, int idx, int cnt, int&amp; res) {\n        if (amount == 0) { res = std::min(cnt, res); return;}\n        if (idx &gt;= coins.size()) return;\n        for(int i = amount / coins[idx]; i &gt; -1; i--) {\n            dfs(coins, amount - coins[idx] * i, idx + 1, cnt + i, res);\n        }\n    }\n</code></pre>\n<p>但是做到这里会超时，如果进行剪枝，结果就大大不同，只需要8ms，可能这题测试用例的特殊性，导致剪枝效果超过了DP</p>\n<pre><code class=\"language-cpp\">for(int i = amount / coins[idx]; i &gt; -1 &amp;&amp; i + count &lt; res; i--) {\n    dfs(coins, amount - coins[idx] * i, idx + 1, cnt + i, res);\n}\n\n// 即在for-loop条件中加入 i + count &lt; res， 如果本次结果已经比所得的最小值大了，那么就没必要继续搜索下去了\n</code></pre>\n<h1 id=\"378-Kth-Smallest-Element-in-a-Sorted-Matrix\"><a href=\"https://leetcode-cn.com/problems/kth-smallest-element-in-a-sorted-matrix/\" target=\"_blank\" rel=\"noopener\">378. Kth Smallest Element in a Sorted Matrix</a></h1>\n<p><a href=\"Search-Medium/image-20200517110032569.png\" title=\"image-20200517110032569\" class=\"gallery-item\"><img src=\"image-20200517110032569.png\" alt=\"image-20200517110032569\"></a></p>\n<h2 id=\"解法一：小根堆\">解法一：小根堆</h2>\n<p>遍历一次构造小根堆，再pop k - 1 次即可</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    int kthSmallest(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int k) {\n        priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; q;\n        for(auto v : matrix)\n            for(int i : v)\n                q.push(i);\n        for(int i = 0; i &lt; k - 1; i++) q.pop();\n        return q.top();\n    }\n};\n</code></pre>\n<h2 id=\"解法二：快速选择\">解法二：快速选择</h2>\n<p>先转一维数组，Array里写过，相当于剪枝版的快排，但此处是局部有序的，应该考虑二分</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    int kthSmallest(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int k) {\n        int len = matrix.size() * matrix[0].size();\n        if(k &gt; len) return -1;\n        vector&lt;int&gt; nv;\n        for(auto v : matrix)\n            for(int i : v)\n                nv.push_back(i);\n        return getKth(nv, k - 1);\n    }\n\n    int getKth(vector&lt;int&gt;&amp; v, int k) {\n        int l = 0, r = v.size() - 1;\n        while(true) {\n            int idx = partition(v, l, r);\n            if(idx == k) return v[idx];\n            else if(idx &lt; k) {\n                l = idx + 1;\n            }\n            else {\n                r = idx - 1;\n            }\n        }\n    }\n\n    int partition(vector&lt;int&gt;&amp; v, int l, int r) {\n        ::swap(v[l], v[rand() % (r - l + 1) + l]);\n        int pivot = v[l], mid = l;\n        for(int i = l + 1; i &lt;= r; i++) {\n            if(v[i] &lt; pivot) ::swap(v[++mid], v[i]);\n        }\n        ::swap(v[l], v[mid]);\n        return mid;\n    } \n\n};\n</code></pre>\n<h2 id=\"解法三：二分查找\">解法三：二分查找</h2>\n<ul>\n<li>第k小说明在矩阵中有k - 1个小于它的数</li>\n<li>取搜索区间的中位数（可能不在矩阵内），计算矩阵中比这个中位数小的数</li>\n<li>如果结果 <code>idx &lt; k</code>，也就是要继续向上搜索</li>\n<li>否则说明在包括<code>mid</code>在内的 <code>[l, mid]</code> 闭区间内</li>\n</ul>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    int kthSmallest(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int k) {\n        int len = matrix.size();\n        int l = matrix[0][0], r = matrix[len - 1][len - 1];\n        while(l &lt; r) {\n            int mid = (l + r) &gt;&gt; 1;\n            int idx = divide(matrix, mid);\n            idx &lt; k ? l = mid + 1 : r = mid;\n        }\n        return l;\n    }\n\n    int divide(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int mid) {\n        int idx = 0, last = matrix.size() - 1;\n        int y = last, x = 0;\n        while(y &gt; -1 &amp;&amp; x &lt;= last) {\n            if(matrix[y][x] &lt;= mid) {\n                idx += y + 1;\n                x++;\n            } else y--;\n        }\n        return idx;\n    }\n\n};\n</code></pre>\n<h1 id=\"436-Find-Right-Interval\"><a href=\"https://leetcode-cn.com/problems/find-right-interval/\" target=\"_blank\" rel=\"noopener\">436. Find Right Interval</a></h1>\n<p><a href=\"Search-Medium/image-20200523135552024.png\" title=\"image-20200523135552024\" class=\"gallery-item\"><img src=\"image-20200523135552024.png\" alt=\"image-20200523135552024\"></a></p>\n<p><a href=\"Search-Medium/image-20200523135602524.png\" title=\"image-20200523135602524\" class=\"gallery-item\"><img src=\"image-20200523135602524.png\" alt=\"image-20200523135602524\"></a></p>\n<h2 id=\"解法一：二分查找-v3\">解法一：二分查找</h2>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    vector&lt;int&gt; findRightInterval(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) {\n        int len = intervals.size();\n        vector&lt;int&gt; res(len, -1);\n        map&lt;int, int&gt; tmap;\n\n        for(int i = 0; i &lt; len; i++) \n            tmap[intervals[i][0]] = i;\n        \n        for(int i = 0; i &lt; len; i++) {\n            auto t = tmap.lower_bound(intervals[i][1]); \n            if(t != tmap.end())\n                res[i] = t-&gt;second;\n        }\n        return res;\n    }\n};\n</code></pre>\n</div><script src=\"https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js\"></script><script>if (typeof lightGallery !== 'undefined') {\n        var options = {\n            selector: '.gallery-item'\n        };\n        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);\n        }</script>","more":"<h1 id=\"33-Search-in-Rotated-Sorted-Array\"><a href=\"https://leetcode-cn.com/problems/search-in-rotated-sorted-array/\" target=\"_blank\" rel=\"noopener\">33. Search in Rotated Sorted Array</a></h1>\n<p><a href=\"Search-Medium/image-20200427200546326.png\" title=\"image-20200427200546326\" class=\"gallery-item\"><img src=\"image-20200427200546326.png\" alt=\"image-20200427200546326\"></a></p>\n<h2 id=\"解法一：二分查找\">解法一：二分查找</h2>\n<p>线性遍历就不用多说了，本题是部分有序，但是不影响使用二分查找</p>\n<p>由于二分后，必然半边是有序的，我们就可以利用这半边作为线索来搜索</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    int search(vector&lt;int&gt;&amp; nums, int target) {\n        if(nums.empty()) return -1;\n        int lo = 0, hi = nums.size() - 1;\n        while (lo &lt;= hi) {\n            int mid = (lo + hi) / 2;\n            if (nums[mid] == target) return mid;\n            if (nums[0] &lt;= nums[mid]) {\n                if (nums[0] &lt;= target &amp;&amp; target &lt; nums[mid]) {\n                    hi = mid - 1;\n                } else {\n                    lo = mid + 1;\n                }\n            } else {\n                if (nums[mid] &lt; target &amp;&amp; target &lt;= nums[nums.size() - 1]) {\n                    lo = mid + 1;\n                } else {\n                    hi = mid - 1;\n                }\n            }\n        }\n        return -1;\n    }\n};\n</code></pre>\n<h1 id=\"34-Find-First-and-Last-Position-of-Element-in-Sorted-Array\"><a href=\"https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/\" target=\"_blank\" rel=\"noopener\">34. Find First and Last Position of Element in Sorted Array</a></h1>\n<p><a href=\"Search-Medium/image-20200430141640301.png\" title=\"image-20200430141640301\" class=\"gallery-item\"><img src=\"image-20200430141640301.png\" alt=\"image-20200430141640301\"></a></p>\n<h2 id=\"解法一：标准二分查找\">解法一：标准二分查找</h2>\n<p>标准的二分查找，只不过找到之后还要向左右再搜索一下，注意一下越界判定就行</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) {\n        int lo = 0, hi = nums.size() - 1;\n        while(lo &lt;= hi){\n            int mid = (lo + hi) / 2;\n            if(nums[mid] == target){\n                int i = mid, j = mid;\n                while(i &gt; 0 &amp;&amp; nums[i - 1] == target) i--;\n                while(j &lt; nums.size() - 1 &amp;&amp; nums[j + 1] == target) j++;\n                return {i,j};\n            } \n            else if(nums[mid] &lt; target)\n                lo = mid + 1;\n            else if(nums[mid] &gt; target)\n                hi = mid - 1;\n        }\n        return {-1,-1};\n    }\n};\n</code></pre>\n<h1 id=\"130-Surrounded-Regions\"><a href=\"https://leetcode-cn.com/problems/surrounded-regions/\" target=\"_blank\" rel=\"noopener\">130. Surrounded Regions</a></h1>\n<p><a href=\"Search-Medium/image-20200504151213466.png\" title=\"image-20200504151213466\" class=\"gallery-item\"><img src=\"image-20200504151213466.png\" alt=\"image-20200504151213466\"></a></p>\n<h2 id=\"解法一：递归dfs\">解法一：递归dfs</h2>\n<p>因为只有边缘的O不会被替换掉，因此从边缘的O开始找就行了，将边缘的O全部标记，最后再替换掉剩余的O</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    void solve(vector&lt;vector&lt;char&gt;&gt;&amp; board) {\n        if(board.empty()) return;\n        for (int i = 0; i &lt; board.size(); i++){\n            for (int j = 0; j &lt; board[0].size(); j++){\n                if(i == 0 || j == 0 || i == board.size() - 1 || j == board[0].size() - 1)\n                    dfs(board, i, j);\n            }\n        }\n\n        for(vector&lt;char&gt;&amp; v : board)\n            for(char&amp; c : v)\n                c = c == 'Y' ? 'O' : 'X';\n    }\n\n    void dfs(vector&lt;vector&lt;char&gt;&gt;&amp; board, int i, int j){\n        int row = board.size() - 1, col = board[0].size() - 1;\n        if(i &gt; row || i &lt; 0 || j &gt; col || j &lt; 0 || board[i][j] == 'X' || board[i][j] == 'Y') return;\n        board[i][j] = 'Y';\n        dfs(board, i + 1, j);\n        dfs(board, i, j + 1);\n        dfs(board, i - 1, j);\n        dfs(board, i, j - 1);\n    }\n};\n</code></pre>\n<h2 id=\"解法二：迭代dfs\">解法二：迭代dfs</h2>\n<p>每次从队首推入</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    struct Pos{\n        int x, y;\n        Pos(int a, int b) : x(a), y(b) {};\n    };\n\n    void solve(vector&lt;vector&lt;char&gt;&gt;&amp; board) {\n        if(board.empty()) return;\n        for (int i = 0; i &lt; board.size(); i++)\n            for (int j = 0; j &lt; board[0].size(); j++)\n                if(i == 0 || j == 0 || i == board.size() - 1 || j == board[0].size() - 1)\n                    bfs(board, i, j);\n\n        for(vector&lt;char&gt;&amp; v : board)\n            for(char&amp; c : v)\n                c = c == 'Y' ? 'O' : 'X';\n    }\n\n    void bfs(vector&lt;vector&lt;char&gt;&gt;&amp; board, int i, int j){\n        int row = board.size() - 1, col = board[0].size() - 1;\n        deque&lt;Pos&gt; q;\n        q.push_front({ i, j });\n        while(!q.empty()){\n            Pos curr = q.front(); q.pop_front();\n            i = curr.x, j = curr.y;\n            if(i &gt; row || i &lt; 0 || j &gt; col || j &lt; 0 || board[i][j] == 'X' || board[i][j] == 'Y')\n                continue;\n            board[i][j] = 'Y';\n            q.push_front({ i + 1, j });\n            q.push_front({ i - 1, j });\n            q.push_front({ i, j + 1 });\n            q.push_front({ i, j - 1 });\n        }\n    }\n};\n</code></pre>\n<h2 id=\"解法三：迭代bfs\">解法三：迭代bfs</h2>\n<p>每次从队尾推入</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    struct Pos{\n        int x, y;\n        Pos(int a, int b) : x(a), y(b) {};\n    };\n\n    void solve(vector&lt;vector&lt;char&gt;&gt;&amp; board) {\n        if(board.empty()) return;\n        for (int i = 0; i &lt; board.size(); i++)\n            for (int j = 0; j &lt; board[0].size(); j++)\n                if(i == 0 || j == 0 || i == board.size() - 1 || j == board[0].size() - 1)\n                    bfs(board, i, j);\n\n        for(vector&lt;char&gt;&amp; v : board)\n            for(char&amp; c : v)\n                c = c == 'Y' ? 'O' : 'X';\n    }\n\n    void bfs(vector&lt;vector&lt;char&gt;&gt;&amp; board, int i, int j){\n        int row = board.size() - 1, col = board[0].size() - 1;\n        queue&lt;Pos&gt; q;\n        q.push({ i, j });\n        while(!q.empty()){\n            Pos curr = q.front(); q.pop();\n            i = curr.x, j = curr.y;\n            if(i &gt; row || i &lt; 0 || j &gt; col || j &lt; 0 || board[i][j] == 'X' || board[i][j] == 'Y')\n                continue;\n            board[i][j] = 'Y';\n            q.push({ i + 1, j });\n            q.push({ i - 1, j });\n            q.push({ i, j + 1 });\n            q.push({ i, j - 1 });\n        }\n    }\n};\n</code></pre>\n<h1 id=\"200-Number-of-Islands\"><a href=\"https://leetcode-cn.com/problems/number-of-islands/\" target=\"_blank\" rel=\"noopener\">200. Number of Islands</a></h1>\n<p><a href=\"Search-Medium/image-20200506145713267.png\" title=\"image-20200506145713267\" class=\"gallery-item\"><img src=\"image-20200506145713267.png\" alt=\"image-20200506145713267\"></a></p>\n<h2 id=\"解法一：同上题\">解法一：同上题</h2>\n<p>贴一个递归dfs</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) {\n        if(grid.empty()) return 0;\n        int res = 0, row = grid.size(), col = grid[0].size();\n        for (int i = 0; i &lt; row; i++) {\n            for (int j = 0; j &lt; col; j++) {\n                if (grid[i][j] == '1') {\n                    res++;\n                    dfs(grid, i, j);\n                }\n            }\n        }\n        return res;\n    }\n\n    void dfs(vector&lt;vector&lt;char&gt;&gt;&amp; grid, int i, int j) {\n        if(i &lt; 0 || j &lt; 0 || i &gt; grid.size() - 1 || j &gt; grid[0].size() - 1 ||\n           grid[i][j] == '0') return;\n        grid[i][j] = '0';\n        dfs(grid, i + 1, j);\n        dfs(grid, i - 1, j);\n        dfs(grid, i, j + 1);\n        dfs(grid, i, j - 1); \n    }\n};\n</code></pre>\n<h1 id=\"240-Search-a-2D-Matrix-II\"><a href=\"https://leetcode-cn.com/problems/search-a-2d-matrix-ii/\" target=\"_blank\" rel=\"noopener\">240. Search a 2D Matrix II</a></h1>\n<p><a href=\"Search-Medium/image-20200507205502068.png\" title=\"image-20200507205502068\" class=\"gallery-item\"><img src=\"image-20200507205502068.png\" alt=\"image-20200507205502068\"></a></p>\n<h2 id=\"解法一：逐行二分查找\">解法一：逐行二分查找</h2>\n<p>先看target在不在这行的区间，如果在就二分查找一下，直到找到，复杂度O(mlogn)</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) {\n        if(matrix.empty() || matrix[0].empty()) return false;\n        int row = matrix.size(), col = matrix[0].size();\n        for(int i = 0; i &lt; row; i++) {\n            if(matrix[i][0] &lt;= target &amp;&amp; matrix[i][col - 1] &gt;= target &amp;&amp; binarySearch(matrix[i], target)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    bool binarySearch(vector&lt;int&gt; row, int target) {\n        int lo = 0, hi = row.size() - 1;\n        while (lo &lt;= hi) {\n            int mid = (lo + hi) / 2;\n            if(target == row[mid]) return true;\n            else if(target &lt; row[mid]) hi = mid - 1;\n            else lo = mid + 1;\n        }\n        return false;\n    }\n};\n</code></pre>\n<h2 id=\"解法二：减治法\">解法二：减治法</h2>\n<ul>\n<li>\n<p>从左下角开始找，如果大了向上移动一行，小了则向右移动一列，这样不会错过target，因为只有左下角的变化是单向的，也就是不会出现两条路径上都增大或减小的情况</p>\n</li>\n<li>\n<p>复杂度O(m + n)</p>\n</li>\n</ul>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) {\n        int row = matrix.size() - 1, col = 0;\n        while (row &gt; - 1 &amp;&amp; col &lt; matrix[0].size()) {\n            int val = matrix[row][col];\n            if(val == target) \n                return true;\n            else if(val &lt; target)\n                col++;\n            else \n                row--; \n        }\n        return false;\n    }\n};\n</code></pre>\n<h1 id=\"153-Find-Minimum-in-Rotated-Sorted-Array\"><a href=\"https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/\" target=\"_blank\" rel=\"noopener\">153. Find Minimum in Rotated Sorted Array</a></h1>\n<p><a href=\"Search-Medium/image-20200510163022286.png\" title=\"image-20200510163022286\" class=\"gallery-item\"><img src=\"image-20200510163022286.png\" alt=\"image-20200510163022286\"></a></p>\n<h2 id=\"解法零：暴力法\">解法零：暴力法</h2>\n<p>线性遍历，太俗就不说了</p>\n<h2 id=\"解法一：二分查找-v2\">解法一：二分查找</h2>\n<ul>\n<li>因为数组被旋转了，所以查找的时候只有一边是有序的</li>\n<li>如果满足 <code>nums[mid] &gt; nums[mid + 1]</code> 或 <code>nums[mid] &lt; nums[mid - 1]</code>都说明边界找到了</li>\n<li>如果没找到，判断哪一边是有序的，如果 <code>nums[mid] &lt; nums[0]</code>，说明当前在边界右边，要向左搜索，否则向右搜索</li>\n<li>有一种情况可能会让我们的代码越界，那就是数组没有被旋转的时候，此时会一直向右搜索直到 <code>mid = nums.size() - 1</code>，当我们判断 mid + 1 时就会越界，因此对于这种情况要特殊处理</li>\n</ul>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    int findMin(vector&lt;int&gt;&amp; nums) {\n        int lo = 0, hi = nums.size() - 1;\n        if(nums.size() == 1) return nums[0];\n        if(nums[hi] &gt; nums[lo]) return nums[0];\n        while(lo &lt;= hi) {\n            int mid = (lo + hi) / 2;\n            if(nums[mid] &gt; nums[mid + 1])\n                return nums[mid + 1];\n            if(nums[mid] &lt; nums[mid - 1])\n                return nums[mid];\n            if(nums[mid] &gt; nums[0])\n                lo = mid + 1;\n            else\n                hi = mid - 1;\n        }\n        return -1;\n    }\n};\n</code></pre>\n<h1 id=\"162-Find-Peak-Element\"><a href=\"https://leetcode-cn.com/problems/find-peak-element/\" target=\"_blank\" rel=\"noopener\">162. Find Peak Element</a></h1>\n<p><a href=\"Search-Medium/image-20200510180157121.png\" title=\"image-20200510180157121\" class=\"gallery-item\"><img src=\"image-20200510180157121.png\" alt=\"image-20200510180157121\"></a></p>\n<h2 id=\"解法一：暴力法\">解法一：暴力法</h2>\n<p>线性遍历，没想到居然95%，那就贴一下吧</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    int findPeakElement(vector&lt;int&gt;&amp; nums) {\n        int len = nums.size();\n        if(len == 1 || nums[0] &gt; nums[1]) return 0;\n        if(nums[len - 1] &gt; nums[len - 2]) return len - 1; \n        for(int i = 1; i &lt; nums.size() - 1; i++) {\n            if(nums[i] &gt; nums[i - 1] &amp;&amp; nums[i] &gt; nums[i + 1])\n                return i;\n        }\n        return -1;\n    }\n};\n</code></pre>\n<h2 id=\"解法二：二分查找\">解法二：二分查找</h2>\n<h1 id=\"322-Coin-Change\"><a href=\"https://leetcode-cn.com/problems/coin-change/\" target=\"_blank\" rel=\"noopener\">322. Coin Change</a></h1>\n<p><a href=\"Search-Medium/image-20200512163016773.png\" title=\"image-20200512163016773\" class=\"gallery-item\"><img src=\"image-20200512163016773.png\" alt=\"image-20200512163016773\"></a></p>\n<h2 id=\"解法一：DP\">解法一：DP</h2>\n<p>首先这题可以看作完全背包问题</p>\n<p>如果已知<code>amount &lt;  n</code>的答案，那么对于<code>amount == n</code>，有</p>\n<pre><code class=\"language-cpp\">dp[n] = min(dp[n], dp[n - coin_j]) { coin_j &lt; amount }\n</code></pre>\n<p>所以从0构造amount的前缀解，在通过转移方程即可求得结果</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    int coinChange(vector&lt;int&gt;&amp; coins, int amount) {\n        vector&lt;int&gt; dp(amount + 1, amount + 1); // dp值最大为amount\n        dp[0] = 0;\n        for(int i = 1; i &lt;= amount; i++) {\n            for(int j = 0; j &lt; coins.size(); j++) {\n                if(coins[j] &lt;= i)\n                    dp[i] = std::min(dp[i], dp[i - coins[j]] + 1);\n            }\n        }\n        return dp[amount] &gt; amount ? -1 : dp[amount];\n    }\n};\n</code></pre>\n<h2 id=\"解法二：贪心-dfs\">解法二：贪心 + dfs</h2>\n<p>这种找零钱的题第一反应当然是要从最大的开始找</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    int coinChange(vector&lt;int&gt;&amp; coins, int amount) {\n        std::sort(coins.rbegin(), coins.rend());\n        int cnt = 0;\n        for(int i = 0; i &lt; coins.size(); i++) {\n            if(amount == 0) return cnt;\n            if(coins[i] &gt; amount) continue;\n            int val = amount / coins[i];\n            amount -= coins[i] * val;\n            cnt += val;\n        }\n        return cnt == 0 ? -1 : cnt;\n    }\n};\n</code></pre>\n<p>但是直接贪心可能会导致找不出来的情况，所以要加入dfs进行搜索</p>\n<pre><code class=\"language-cpp\">int coinChange(vector&lt;int&gt;&amp; coins, int amount) {\n        std::sort(coins.rbegin(), coins.rend());\n        int res = INT32_MAX;\n        dfs(coins, amount, 0, 0, res);\n        return res == INT32_MAX ? -1 : res;\n    }\n\nvoid dfs(vector&lt;int&gt;&amp; coins, int amount, int idx, int cnt, int&amp; res) {\n        if (amount == 0) { res = std::min(cnt, res); return;}\n        if (idx &gt;= coins.size()) return;\n        for(int i = amount / coins[idx]; i &gt; -1; i--) {\n            dfs(coins, amount - coins[idx] * i, idx + 1, cnt + i, res);\n        }\n    }\n</code></pre>\n<p>但是做到这里会超时，如果进行剪枝，结果就大大不同，只需要8ms，可能这题测试用例的特殊性，导致剪枝效果超过了DP</p>\n<pre><code class=\"language-cpp\">for(int i = amount / coins[idx]; i &gt; -1 &amp;&amp; i + count &lt; res; i--) {\n    dfs(coins, amount - coins[idx] * i, idx + 1, cnt + i, res);\n}\n\n// 即在for-loop条件中加入 i + count &lt; res， 如果本次结果已经比所得的最小值大了，那么就没必要继续搜索下去了\n</code></pre>\n<h1 id=\"378-Kth-Smallest-Element-in-a-Sorted-Matrix\"><a href=\"https://leetcode-cn.com/problems/kth-smallest-element-in-a-sorted-matrix/\" target=\"_blank\" rel=\"noopener\">378. Kth Smallest Element in a Sorted Matrix</a></h1>\n<p><a href=\"Search-Medium/image-20200517110032569.png\" title=\"image-20200517110032569\" class=\"gallery-item\"><img src=\"image-20200517110032569.png\" alt=\"image-20200517110032569\"></a></p>\n<h2 id=\"解法一：小根堆\">解法一：小根堆</h2>\n<p>遍历一次构造小根堆，再pop k - 1 次即可</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    int kthSmallest(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int k) {\n        priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; q;\n        for(auto v : matrix)\n            for(int i : v)\n                q.push(i);\n        for(int i = 0; i &lt; k - 1; i++) q.pop();\n        return q.top();\n    }\n};\n</code></pre>\n<h2 id=\"解法二：快速选择\">解法二：快速选择</h2>\n<p>先转一维数组，Array里写过，相当于剪枝版的快排，但此处是局部有序的，应该考虑二分</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    int kthSmallest(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int k) {\n        int len = matrix.size() * matrix[0].size();\n        if(k &gt; len) return -1;\n        vector&lt;int&gt; nv;\n        for(auto v : matrix)\n            for(int i : v)\n                nv.push_back(i);\n        return getKth(nv, k - 1);\n    }\n\n    int getKth(vector&lt;int&gt;&amp; v, int k) {\n        int l = 0, r = v.size() - 1;\n        while(true) {\n            int idx = partition(v, l, r);\n            if(idx == k) return v[idx];\n            else if(idx &lt; k) {\n                l = idx + 1;\n            }\n            else {\n                r = idx - 1;\n            }\n        }\n    }\n\n    int partition(vector&lt;int&gt;&amp; v, int l, int r) {\n        ::swap(v[l], v[rand() % (r - l + 1) + l]);\n        int pivot = v[l], mid = l;\n        for(int i = l + 1; i &lt;= r; i++) {\n            if(v[i] &lt; pivot) ::swap(v[++mid], v[i]);\n        }\n        ::swap(v[l], v[mid]);\n        return mid;\n    } \n\n};\n</code></pre>\n<h2 id=\"解法三：二分查找\">解法三：二分查找</h2>\n<ul>\n<li>第k小说明在矩阵中有k - 1个小于它的数</li>\n<li>取搜索区间的中位数（可能不在矩阵内），计算矩阵中比这个中位数小的数</li>\n<li>如果结果 <code>idx &lt; k</code>，也就是要继续向上搜索</li>\n<li>否则说明在包括<code>mid</code>在内的 <code>[l, mid]</code> 闭区间内</li>\n</ul>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    int kthSmallest(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int k) {\n        int len = matrix.size();\n        int l = matrix[0][0], r = matrix[len - 1][len - 1];\n        while(l &lt; r) {\n            int mid = (l + r) &gt;&gt; 1;\n            int idx = divide(matrix, mid);\n            idx &lt; k ? l = mid + 1 : r = mid;\n        }\n        return l;\n    }\n\n    int divide(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int mid) {\n        int idx = 0, last = matrix.size() - 1;\n        int y = last, x = 0;\n        while(y &gt; -1 &amp;&amp; x &lt;= last) {\n            if(matrix[y][x] &lt;= mid) {\n                idx += y + 1;\n                x++;\n            } else y--;\n        }\n        return idx;\n    }\n\n};\n</code></pre>\n<h1 id=\"436-Find-Right-Interval\"><a href=\"https://leetcode-cn.com/problems/find-right-interval/\" target=\"_blank\" rel=\"noopener\">436. Find Right Interval</a></h1>\n<p><a href=\"Search-Medium/image-20200523135552024.png\" title=\"image-20200523135552024\" class=\"gallery-item\"><img src=\"image-20200523135552024.png\" alt=\"image-20200523135552024\"></a></p>\n<p><a href=\"Search-Medium/image-20200523135602524.png\" title=\"image-20200523135602524\" class=\"gallery-item\"><img src=\"image-20200523135602524.png\" alt=\"image-20200523135602524\"></a></p>\n<h2 id=\"解法一：二分查找-v3\">解法一：二分查找</h2>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    vector&lt;int&gt; findRightInterval(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) {\n        int len = intervals.size();\n        vector&lt;int&gt; res(len, -1);\n        map&lt;int, int&gt; tmap;\n\n        for(int i = 0; i &lt; len; i++) \n            tmap[intervals[i][0]] = i;\n        \n        for(int i = 0; i &lt; len; i++) {\n            auto t = tmap.lower_bound(intervals[i][1]); \n            if(t != tmap.end())\n                res[i] = t-&gt;second;\n        }\n        return res;\n    }\n};\n</code></pre>\n<script src=\"https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js\"></script><script>if (typeof lightGallery !== 'undefined') {\n        var options = {\n            selector: '.gallery-item'\n        };\n        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);\n        }</script>","categories":[{"name":"Algorithm","path":"api/categories/Algorithm.json"}],"tags":[{"name":"Leetcode","path":"api/tags/Leetcode.json"}]}