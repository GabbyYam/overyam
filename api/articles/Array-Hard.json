{"title":"Array-Hard","slug":"Array-Hard","date":"2020-04-27T12:21:31.000Z","updated":"2020-05-05T13:54:23.153Z","comments":true,"path":"api/articles/Array-Hard.json","excerpt":"Abstract：leetcode 线性表 hard 难度题解合集","covers":["image-20200427202304064.png"],"content":"<link rel=\"stylesheet\" type=\"text/css\" href=\"https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css\"><div class=\".article-gallery\" <p><strong>Abstract</strong>：leetcode 线性表 hard 难度题解合集<p></p>\n<a id=\"more\"></a>\n<h1 id=\"4-Median-of-Two-Sorted-Arrays\"><a href=\"https://leetcode-cn.com/problems/median-of-two-sorted-arrays/\" target=\"_blank\" rel=\"noopener\">4. Median of Two Sorted Arrays</a></h1>\n<p><a href=\"Array-Hard/image-20200427202304064.png\" title=\"image-20200427202304064\" class=\"gallery-item\"><img src=\"image-20200427202304064.png\" alt=\"image-20200427202304064\"></a></p>\n<h2 id=\"解法一：直接排序\">解法一：直接排序</h2>\n<p>直接拼起来，再排序，复杂度同排序复杂度</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) {\n        for(int i : nums2) nums1.push_back(i);\n        std::sort(nums1.begin(), nums1.end());\n        int len = nums1.size();\n        if(len % 2 != 0) \n            return (double)nums1[len/2];\n        else\n            return (((double)nums1[(len/2) - 1] + (double)nums1[len/2]) / 2); \n    }\n};\n</code></pre>\n<h2 id=\"解法二：插入排序\">解法二：插入排序</h2>\n<p>解法一是O((m + n)log(m + n))，显然如果插入排序的话，时间复杂度至少可以是O(m+n)</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) {\n        int i = 0, j = 0;\n        vector&lt;int&gt; nums;\n        while(i &lt; nums1.size() || j &lt; nums2.size()){\n            if(i &gt;= nums1.size()) \n                nums.push_back(nums2[j++]);\n            else if(j &gt;= nums2.size())\n                nums.push_back(nums1[i++]);\n            else if(nums1[i] &lt; nums2[j])\n                nums.push_back(nums1[i++]);\n            else \n                nums.push_back(nums2[j++]);\n        }\n        int len = nums.size();\n        if(len % 2 != 0) \n            return (double)nums[len/2];\n        else\n            return (((double)nums[(len/2) - 1] + (double)nums[len/2]) / 2);  \n    }\n};\n</code></pre>\n<h2 id=\"正解：二分法\">正解：二分法</h2>\n</div><script src=\"https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js\"></script><script>if (typeof lightGallery !== 'undefined') {\n        var options = {\n            selector: '.gallery-item'\n        };\n        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);\n        }</script>","more":"<h1 id=\"4-Median-of-Two-Sorted-Arrays\"><a href=\"https://leetcode-cn.com/problems/median-of-two-sorted-arrays/\" target=\"_blank\" rel=\"noopener\">4. Median of Two Sorted Arrays</a></h1>\n<p><a href=\"Array-Hard/image-20200427202304064.png\" title=\"image-20200427202304064\" class=\"gallery-item\"><img src=\"image-20200427202304064.png\" alt=\"image-20200427202304064\"></a></p>\n<h2 id=\"解法一：直接排序\">解法一：直接排序</h2>\n<p>直接拼起来，再排序，复杂度同排序复杂度</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) {\n        for(int i : nums2) nums1.push_back(i);\n        std::sort(nums1.begin(), nums1.end());\n        int len = nums1.size();\n        if(len % 2 != 0) \n            return (double)nums1[len/2];\n        else\n            return (((double)nums1[(len/2) - 1] + (double)nums1[len/2]) / 2); \n    }\n};\n</code></pre>\n<h2 id=\"解法二：插入排序\">解法二：插入排序</h2>\n<p>解法一是O((m + n)log(m + n))，显然如果插入排序的话，时间复杂度至少可以是O(m+n)</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) {\n        int i = 0, j = 0;\n        vector&lt;int&gt; nums;\n        while(i &lt; nums1.size() || j &lt; nums2.size()){\n            if(i &gt;= nums1.size()) \n                nums.push_back(nums2[j++]);\n            else if(j &gt;= nums2.size())\n                nums.push_back(nums1[i++]);\n            else if(nums1[i] &lt; nums2[j])\n                nums.push_back(nums1[i++]);\n            else \n                nums.push_back(nums2[j++]);\n        }\n        int len = nums.size();\n        if(len % 2 != 0) \n            return (double)nums[len/2];\n        else\n            return (((double)nums[(len/2) - 1] + (double)nums[len/2]) / 2);  \n    }\n};\n</code></pre>\n<h2 id=\"正解：二分法\">正解：二分法</h2>\n<script src=\"https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js\"></script><script>if (typeof lightGallery !== 'undefined') {\n        var options = {\n            selector: '.gallery-item'\n        };\n        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);\n        }</script>","categories":[{"name":"Algorithm","path":"api/categories/Algorithm.json"}],"tags":[{"name":"Leetcode","path":"api/tags/Leetcode.json"}]}