{"title":"Sliding-Window Hard","slug":"Sliding-Window-Hard","date":"2020-05-23T03:49:28.000Z","updated":"2020-05-23T15:38:02.548Z","comments":true,"path":"api/articles/Sliding-Window-Hard.json","excerpt":"Abstract: leetcode Sliding-Window","covers":["image-20200523115122161.png","image-20200523232236076.png"],"content":"<link rel=\"stylesheet\" type=\"text/css\" href=\"https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css\"><div class=\".article-gallery\" <p><strong>Abstract:</strong> leetcode Sliding-Window<p></p>\n<a id=\"more\"></a>\n<h1 id=\"76-Minimum-Window-Substring\"><a href=\"https://leetcode-cn.com/problems/minimum-window-substring/\" target=\"_blank\" rel=\"noopener\">76. Minimum Window Substring</a></h1>\n<p><a href=\"Sliding-Window-Hard/image-20200523115122161.png\" title=\"image-20200523115122161\" class=\"gallery-item\"><img src=\"image-20200523115122161.png\" alt=\"image-20200523115122161\"></a></p>\n<h2 id=\"解法一【超时】\">解法一【超时】</h2>\n<p>对于每一个start，复制一份HashTable，当表全小于0时更新最小长度，但由于本质还是暴力匹配，就超时了</p>\n<h2 id=\"解法二：滑动窗口\">解法二：滑动窗口</h2>\n<p>先找右边界，再缩小左边界</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    string minWindow(string s, string t) {\n        unordered_map&lt;char, int&gt; tmap, cmap;\n        for(const char&amp; c : t) ++tmap[c];\n\n        int l = 0, r = 0, min_len = INT32_MAX, res = -1, wnd_len = 0;\n        while(r &lt; s.length()) {\n            if(tmap.find(s[r]) != tmap.end())\n                ++cmap[s[r]];\n            while(l &lt;= r &amp;&amp; check(cmap, tmap)) {\n                if(r - l + 1 &lt; min_len) {\n                    min_len = r - l + 1;\n                    res = l;\n                }\n                --cmap[s[l]];\n                ++l;\n            }\n            ++r;\n        }\n        return res == -1 ? &quot;&quot; :s.substr(res, min_len);\n    }\n\n    bool check(unordered_map&lt;char, int&gt;&amp; cmap, unordered_map&lt;char, int&gt;&amp; tmap) {\n        for(auto&amp; k : tmap) {\n            if(cmap[k.first] &lt; k.second)\n                return false;\n        }\n        return true;\n    }\n};\n\n</code></pre>\n<h2 id=\"回溯优化\">回溯优化</h2>\n<p>重复check两个map很费时间</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    string minWindow(string s, string t) {\n        unordered_map&lt;char, int&gt; tmap;\n        for(const char&amp; c : t) ++tmap[c];\n\n        int l = 0, r = 0, min_len = INT32_MAX, res = -1, wnd_len = 0;\n        while(r &lt; s.length()) {\n            if(--tmap[s[r]] &gt;= 0) ++wnd_len;\n            while (wnd_len == t.length()) {\n                if(r - l + 1 &lt; min_len) {\n                    min_len = r - l + 1;\n                    res = l;\n                }\n                if(++tmap[s[l]] &gt; 0) --wnd_len;\n                ++l;\n            }\n            ++r;\n        }\n        return res == -1 ? &quot;&quot; : s.substr(res, min_len);\n    }\n};\n\n</code></pre>\n<h1 id=\"239-Sliding-Window-Maximum\"><a href=\"https://leetcode-cn.com/problems/sliding-window-maximum/\" target=\"_blank\" rel=\"noopener\">239. Sliding Window Maximum</a></h1>\n<p><a href=\"Sliding-Window-Hard/image-20200523232236076.png\" title=\"image-20200523232236076\" class=\"gallery-item\"><img src=\"image-20200523232236076.png\" alt=\"image-20200523232236076\"></a></p>\n<h2 id=\"解法一：单调队列模板题\">解法一：单调队列模板题</h2>\n<p>维护一个单调队列，详细请看Design篇</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) {\n        if(nums.empty() || k &gt; nums.size() || k &lt;= 0) return {};\n        vector&lt;int&gt; res;\n        deque&lt;int&gt; q;\n        int len = nums.size();\n        for(int i = 0; i &lt; len; i++) {\n            // window划过原先的最大值，弹出最大值\n            if(!q.empty() &amp;&amp; q.front() == i - k) q.pop_front();\n            // 尾部如果小于nums[i]，直接弹出，因为他们在窗口范围内不可能是最大值\n            while(!q.empty() &amp;&amp; nums[i] &gt; nums[q.back()]) q.pop_back();\n            q.push_back(i);\n            // 前k个，窗口大小不足k，跳过\n            if(i &lt; k - 1) continue;\n            // 更新当前位置slidingwindow的最大值\n            res.push_back(nums[q.front()]);\n        }\n        return res;\n    }\n};\n</code></pre>\n</div><script src=\"https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js\"></script><script>if (typeof lightGallery !== 'undefined') {\n        var options = {\n            selector: '.gallery-item'\n        };\n        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);\n        }</script>","more":"<h1 id=\"76-Minimum-Window-Substring\"><a href=\"https://leetcode-cn.com/problems/minimum-window-substring/\" target=\"_blank\" rel=\"noopener\">76. Minimum Window Substring</a></h1>\n<p><a href=\"Sliding-Window-Hard/image-20200523115122161.png\" title=\"image-20200523115122161\" class=\"gallery-item\"><img src=\"image-20200523115122161.png\" alt=\"image-20200523115122161\"></a></p>\n<h2 id=\"解法一【超时】\">解法一【超时】</h2>\n<p>对于每一个start，复制一份HashTable，当表全小于0时更新最小长度，但由于本质还是暴力匹配，就超时了</p>\n<h2 id=\"解法二：滑动窗口\">解法二：滑动窗口</h2>\n<p>先找右边界，再缩小左边界</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    string minWindow(string s, string t) {\n        unordered_map&lt;char, int&gt; tmap, cmap;\n        for(const char&amp; c : t) ++tmap[c];\n\n        int l = 0, r = 0, min_len = INT32_MAX, res = -1, wnd_len = 0;\n        while(r &lt; s.length()) {\n            if(tmap.find(s[r]) != tmap.end())\n                ++cmap[s[r]];\n            while(l &lt;= r &amp;&amp; check(cmap, tmap)) {\n                if(r - l + 1 &lt; min_len) {\n                    min_len = r - l + 1;\n                    res = l;\n                }\n                --cmap[s[l]];\n                ++l;\n            }\n            ++r;\n        }\n        return res == -1 ? &quot;&quot; :s.substr(res, min_len);\n    }\n\n    bool check(unordered_map&lt;char, int&gt;&amp; cmap, unordered_map&lt;char, int&gt;&amp; tmap) {\n        for(auto&amp; k : tmap) {\n            if(cmap[k.first] &lt; k.second)\n                return false;\n        }\n        return true;\n    }\n};\n\n</code></pre>\n<h2 id=\"回溯优化\">回溯优化</h2>\n<p>重复check两个map很费时间</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    string minWindow(string s, string t) {\n        unordered_map&lt;char, int&gt; tmap;\n        for(const char&amp; c : t) ++tmap[c];\n\n        int l = 0, r = 0, min_len = INT32_MAX, res = -1, wnd_len = 0;\n        while(r &lt; s.length()) {\n            if(--tmap[s[r]] &gt;= 0) ++wnd_len;\n            while (wnd_len == t.length()) {\n                if(r - l + 1 &lt; min_len) {\n                    min_len = r - l + 1;\n                    res = l;\n                }\n                if(++tmap[s[l]] &gt; 0) --wnd_len;\n                ++l;\n            }\n            ++r;\n        }\n        return res == -1 ? &quot;&quot; : s.substr(res, min_len);\n    }\n};\n\n</code></pre>\n<h1 id=\"239-Sliding-Window-Maximum\"><a href=\"https://leetcode-cn.com/problems/sliding-window-maximum/\" target=\"_blank\" rel=\"noopener\">239. Sliding Window Maximum</a></h1>\n<p><a href=\"Sliding-Window-Hard/image-20200523232236076.png\" title=\"image-20200523232236076\" class=\"gallery-item\"><img src=\"image-20200523232236076.png\" alt=\"image-20200523232236076\"></a></p>\n<h2 id=\"解法一：单调队列模板题\">解法一：单调队列模板题</h2>\n<p>维护一个单调队列，详细请看Design篇</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) {\n        if(nums.empty() || k &gt; nums.size() || k &lt;= 0) return {};\n        vector&lt;int&gt; res;\n        deque&lt;int&gt; q;\n        int len = nums.size();\n        for(int i = 0; i &lt; len; i++) {\n            // window划过原先的最大值，弹出最大值\n            if(!q.empty() &amp;&amp; q.front() == i - k) q.pop_front();\n            // 尾部如果小于nums[i]，直接弹出，因为他们在窗口范围内不可能是最大值\n            while(!q.empty() &amp;&amp; nums[i] &gt; nums[q.back()]) q.pop_back();\n            q.push_back(i);\n            // 前k个，窗口大小不足k，跳过\n            if(i &lt; k - 1) continue;\n            // 更新当前位置slidingwindow的最大值\n            res.push_back(nums[q.front()]);\n        }\n        return res;\n    }\n};\n</code></pre>\n<script src=\"https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js\"></script><script>if (typeof lightGallery !== 'undefined') {\n        var options = {\n            selector: '.gallery-item'\n        };\n        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);\n        }</script>","categories":[{"name":"Algorithm","path":"api/categories/Algorithm.json"}],"tags":[{"name":"Leetcode","path":"api/tags/Leetcode.json"}]}