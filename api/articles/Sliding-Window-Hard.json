{"title":"Sliding-Window Hard","slug":"Sliding-Window-Hard","date":"2020-05-23T03:49:28.000Z","updated":"2020-05-23T05:09:46.793Z","comments":true,"path":"api/articles/Sliding-Window-Hard.json","excerpt":"Abstract: leetcode Sliding-Window","covers":["image-20200523115122161.png"],"content":"<link rel=\"stylesheet\" type=\"text/css\" href=\"https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css\"><div class=\".article-gallery\" <p><strong>Abstract:</strong> leetcode Sliding-Window<p></p>\n<a id=\"more\"></a>\n<h1 id=\"76-Minimum-Window-Substring\"><a href=\"https://leetcode-cn.com/problems/minimum-window-substring/\" target=\"_blank\" rel=\"noopener\">76. Minimum Window Substring</a></h1>\n<p><a href=\"Sliding-Window-Hard/image-20200523115122161.png\" title=\"image-20200523115122161\" class=\"gallery-item\"><img src=\"image-20200523115122161.png\" alt=\"image-20200523115122161\"></a></p>\n<h2 id=\"解法一【超时】\">解法一【超时】</h2>\n<p>对于每一个start，复制一份HashTable，当表全小于0时更新最小长度，但由于本质还是暴力匹配，就超时了</p>\n<h2 id=\"解法二：滑动窗口\">解法二：滑动窗口</h2>\n<p>先找右边界，再缩小左边界</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    string minWindow(string s, string t) {\n        unordered_map&lt;char, int&gt; tmap, cmap;\n        for(const char&amp; c : t) ++tmap[c];\n\n        int l = 0, r = 0, min_len = INT32_MAX, res = -1, wnd_len = 0;\n        while(r &lt; s.length()) {\n            if(tmap.find(s[r]) != tmap.end())\n                ++cmap[s[r]];\n            while(l &lt;= r &amp;&amp; check(cmap, tmap)) {\n                if(r - l + 1 &lt; min_len) {\n                    min_len = r - l + 1;\n                    res = l;\n                }\n                --cmap[s[l]];\n                ++l;\n            }\n            ++r;\n        }\n        return res == -1 ? &quot;&quot; :s.substr(res, min_len);\n    }\n\n    bool check(unordered_map&lt;char, int&gt;&amp; cmap, unordered_map&lt;char, int&gt;&amp; tmap) {\n        for(auto&amp; k : tmap) {\n            if(cmap[k.first] &lt; k.second)\n                return false;\n        }\n        return true;\n    }\n};\n\n</code></pre>\n<h2 id=\"回溯优化\">回溯优化</h2>\n<p>重复check两个map很费时间</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    string minWindow(string s, string t) {\n        unordered_map&lt;char, int&gt; tmap;\n        for(const char&amp; c : t) ++tmap[c];\n\n        int l = 0, r = 0, min_len = INT32_MAX, res = -1, wnd_len = 0;\n        while(r &lt; s.length()) {\n            if(--tmap[s[r]] &gt;= 0) ++wnd_len;\n            while (wnd_len == t.length()) {\n                if(r - l + 1 &lt; min_len) {\n                    min_len = r - l + 1;\n                    res = l;\n                }\n                if(++tmap[s[l]] &gt; 0) --wnd_len;\n                ++l;\n            }\n            ++r;\n        }\n        return res == -1 ? &quot;&quot; : s.substr(res, min_len);\n    }\n};\n\n</code></pre>\n</div><script src=\"https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js\"></script><script>if (typeof lightGallery !== 'undefined') {\n        var options = {\n            selector: '.gallery-item'\n        };\n        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);\n        }</script>","more":"<h1 id=\"76-Minimum-Window-Substring\"><a href=\"https://leetcode-cn.com/problems/minimum-window-substring/\" target=\"_blank\" rel=\"noopener\">76. Minimum Window Substring</a></h1>\n<p><a href=\"Sliding-Window-Hard/image-20200523115122161.png\" title=\"image-20200523115122161\" class=\"gallery-item\"><img src=\"image-20200523115122161.png\" alt=\"image-20200523115122161\"></a></p>\n<h2 id=\"解法一【超时】\">解法一【超时】</h2>\n<p>对于每一个start，复制一份HashTable，当表全小于0时更新最小长度，但由于本质还是暴力匹配，就超时了</p>\n<h2 id=\"解法二：滑动窗口\">解法二：滑动窗口</h2>\n<p>先找右边界，再缩小左边界</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    string minWindow(string s, string t) {\n        unordered_map&lt;char, int&gt; tmap, cmap;\n        for(const char&amp; c : t) ++tmap[c];\n\n        int l = 0, r = 0, min_len = INT32_MAX, res = -1, wnd_len = 0;\n        while(r &lt; s.length()) {\n            if(tmap.find(s[r]) != tmap.end())\n                ++cmap[s[r]];\n            while(l &lt;= r &amp;&amp; check(cmap, tmap)) {\n                if(r - l + 1 &lt; min_len) {\n                    min_len = r - l + 1;\n                    res = l;\n                }\n                --cmap[s[l]];\n                ++l;\n            }\n            ++r;\n        }\n        return res == -1 ? &quot;&quot; :s.substr(res, min_len);\n    }\n\n    bool check(unordered_map&lt;char, int&gt;&amp; cmap, unordered_map&lt;char, int&gt;&amp; tmap) {\n        for(auto&amp; k : tmap) {\n            if(cmap[k.first] &lt; k.second)\n                return false;\n        }\n        return true;\n    }\n};\n\n</code></pre>\n<h2 id=\"回溯优化\">回溯优化</h2>\n<p>重复check两个map很费时间</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    string minWindow(string s, string t) {\n        unordered_map&lt;char, int&gt; tmap;\n        for(const char&amp; c : t) ++tmap[c];\n\n        int l = 0, r = 0, min_len = INT32_MAX, res = -1, wnd_len = 0;\n        while(r &lt; s.length()) {\n            if(--tmap[s[r]] &gt;= 0) ++wnd_len;\n            while (wnd_len == t.length()) {\n                if(r - l + 1 &lt; min_len) {\n                    min_len = r - l + 1;\n                    res = l;\n                }\n                if(++tmap[s[l]] &gt; 0) --wnd_len;\n                ++l;\n            }\n            ++r;\n        }\n        return res == -1 ? &quot;&quot; : s.substr(res, min_len);\n    }\n};\n\n</code></pre>\n<script src=\"https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js\"></script><script>if (typeof lightGallery !== 'undefined') {\n        var options = {\n            selector: '.gallery-item'\n        };\n        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);\n        }</script>","categories":[{"name":"Algorithm","path":"api/categories/Algorithm.json"}],"tags":[{"name":"Leetcode","path":"api/tags/Leetcode.json"}]}