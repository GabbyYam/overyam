{"title":"LinkedList-Medium","slug":"LinkedList-Medium","date":"2020-04-25T09:57:43.000Z","updated":"2020-05-17T07:27:17.964Z","comments":true,"path":"api/articles/LinkedList-Medium.json","excerpt":"Abstract：leetcode 链表中等难度题合集","covers":["image-20200425175926684.png","image-20200429150847161.png","image-20200502140417451.png","image-20200502142031537.png","image-20200502153133977.png","image-20200510154722042.png","image-20200516005205333.png"],"content":"<link rel=\"stylesheet\" type=\"text/css\" href=\"https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css\"><div class=\".article-gallery\" <p><strong>Abstract</strong>：leetcode 链表中等难度题合集<p></p>\n<a id=\"more\"></a>\n<h1 id=\"2-Add-Two-Numbers\"><a href=\"https://leetcode-cn.com/problems/add-two-numbers/\" target=\"_blank\" rel=\"noopener\">2. Add Two Numbers</a></h1>\n<p><a href=\"LinkedList-Medium/image-20200425175926684.png\" title=\"image-20200425175926684\" class=\"gallery-item\"><img src=\"image-20200425175926684.png\" alt=\"image-20200425175926684\"></a></p>\n<h2 id=\"解法一\">解法一</h2>\n<p>链表模拟加减法，先计算长度相等的部分，如果有一条链更长，那么第一次while结束后继续检查进位，不过这样子写很不优雅，下面优化版改了一下</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        int carry = 0;\n        ListNode* ans = new ListNode(-1);\n        ListNode* curr = ans;\n        while(l1 &amp;&amp; l2){\n            curr-&gt;next = new ListNode(l1-&gt;val + l2-&gt;val + carry);\n            curr = curr-&gt;next;\n            if(curr-&gt;val &gt; 9) {\n                curr-&gt;val -= 10;\n                carry = 1;\n            }\n            else carry = 0;\n            l1 = l1-&gt;next;\n            l2 = l2-&gt;next;\n        }\n        curr-&gt;next = l1 == NULL ? l2 : l1;\n        while(carry == 1 &amp;&amp; curr-&gt;next){\n            curr = curr-&gt;next;\n            curr-&gt;val += 1;\n            if(curr-&gt;val &gt; 9) curr-&gt;val -= 10;\n            else carry = 0;\n        }\n        if(curr-&gt;next == NULL &amp;&amp; carry == 1) curr-&gt;next = new ListNode(1); \n        return ans-&gt;next;\n    }\n};\n</code></pre>\n<h3 id=\"优化版\">优化版</h3>\n<p>没必要剪断之类的，如果某条链为0，直接加零就完事了</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        int carry = 0;\n        ListNode* head = new ListNode(-1);\n        ListNode* curr = head, * p1 = l1, * p2 = l2;\n        while(p1 != NULL || p2 != NULL){\n            int n1 = p1 == NULL ? 0 : p1-&gt;val;\n            int n2 = p2 == NULL ? 0 : p2-&gt;val;\n            int val = n1 + n2 + carry;\n            if(val &gt; 9){\n                val -= 10;\n                carry = 1;\n            }\n            else carry = 0;\n            curr-&gt;next = new ListNode(val);\n            curr = curr-&gt;next;\n            if(p1 != NULL) p1 = p1-&gt;next;\n            if(p2 != NULL) p2 = p2-&gt;next;\n        }\n        if(carry == 1) curr-&gt;next = new ListNode(1);\n        return head-&gt;next;\n    }\n};\n</code></pre>\n<h1 id=\"19-Remove-Nth-Node-From-End-of-List\"><a href=\"https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/\" target=\"_blank\" rel=\"noopener\">19. Remove Nth Node From End of List</a></h1>\n<p><a href=\"LinkedList-Medium/image-20200429150847161.png\" title=\"image-20200429150847161\" class=\"gallery-item\"><img src=\"image-20200429150847161.png\" alt=\"image-20200429150847161\"></a></p>\n<h2 id=\"解法一：快慢指针\">解法一：快慢指针</h2>\n<ul>\n<li>\n<p>经典链表操作快慢操作，类似的还有取中值</p>\n</li>\n<li>\n<p>由于n是合法的，不需要考虑超出长度的问题</p>\n</li>\n</ul>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n\tListNode* removeNthFromEnd(ListNode* head, int n) {\n\t\tListNode* h = new ListNode(-1);\n\t\th-&gt;next = head;\n\t\tListNode* fast = h, * slow = h;\n\t\tfor (int i = 0; i &lt;= n; i++)\n\t\t\tfast = fast-&gt;next;\n\t\tfor (fast; fast != NULL; fast = fast-&gt;next, slow = slow-&gt;next);\n\t\tslow-&gt;next = slow-&gt;next-&gt;next;\n\t\treturn h-&gt;next;\n\t}\n};\n</code></pre>\n<h1 id=\"86-Partition-List\"><a href=\"https://leetcode-cn.com/problems/partition-list/\" target=\"_blank\" rel=\"noopener\">86. Partition List</a></h1>\n<p><a href=\"LinkedList-Medium/image-20200502140417451.png\" title=\"image-20200502140417451\" class=\"gallery-item\"><img src=\"image-20200502140417451.png\" alt=\"image-20200502140417451\"></a></p>\n<h2 id=\"解法一：一次遍历\">解法一：一次遍历</h2>\n<p>加个表头方便操作</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    ListNode* partition(ListNode* head, int x) {\n        if(head == NULL) return head;\n        ListNode* curr = head, * n1 = new ListNode(-1), * n2 = new ListNode(-1),\n        * curr_1 = n1, * curr_2 = n2;\n        for(curr; curr != NULL; curr = curr-&gt;next){\n            if(curr-&gt;val &gt;= x){\n                curr_2-&gt;next = new ListNode(curr-&gt;val);\n                curr_2 = curr_2-&gt;next;\n            }\n            else{\n                curr_1-&gt;next = new ListNode(curr-&gt;val);\n                curr_1 = curr_1-&gt;next;\n            }\n        }\n        curr_1-&gt;next = n2-&gt;next;\n        return n1-&gt;next;\n    }\n};\n</code></pre>\n<h1 id=\"82-Remove-Duplicates-from-Sorted-List-II\"><a href=\"https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/\" target=\"_blank\" rel=\"noopener\">82. Remove Duplicates from Sorted List II</a></h1>\n<p><a href=\"LinkedList-Medium/image-20200502142031537.png\" title=\"image-20200502142031537\" class=\"gallery-item\"><img src=\"image-20200502142031537.png\" alt=\"image-20200502142031537\"></a></p>\n<h2 id=\"解法一：\">解法一：</h2>\n<p>因为单链表不能回溯且要求删掉所有出现重复的元素，因此需要进行预判，也就是</p>\n<pre><code class=\"language-cpp\">curr-&gt;next-&gt;next-&gt;val == curr-&gt;next-&gt;val\n</code></pre>\n<p>另外删完一组数后不要急着令curr = curr-&gt;next，因为可能存在连续的重复元素，如果直接指向下一个，那“预判”就失效了，因此我们让curr-&gt;next = n，这样就能用while继续预判了</p>\n<p>再另外，首位也可能重复，所以开一个新表头来预判首位元素</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    ListNode* deleteDuplicates(ListNode* head) {\n        ListNode* prev = new ListNode(-1), * curr = prev;\n        prev-&gt;next = head;\n        for (curr; curr != NULL; curr = curr-&gt;next){\n            while (curr-&gt;next &amp;&amp; curr-&gt;next-&gt;next &amp;&amp; curr-&gt;next-&gt;next-&gt;val == curr-&gt;next-&gt;val) {\n                int val = curr-&gt;next-&gt;val;\n                ListNode* n = curr-&gt;next;\n                for (n; n != NULL &amp;&amp; n-&gt;val == val; n = n-&gt;next);\n                curr-&gt;next = n;\n            }\n        }\n        return prev-&gt;next;\n    }\n};\n</code></pre>\n<h1 id=\"92-Reverse-Linked-List-II\"><a href=\"https://leetcode-cn.com/problems/reverse-linked-list-ii/\" target=\"_blank\" rel=\"noopener\">92. Reverse Linked List II</a></h1>\n<p><a href=\"LinkedList-Medium/image-20200502153133977.png\" title=\"image-20200502153133977\" class=\"gallery-item\"><img src=\"image-20200502153133977.png\" alt=\"image-20200502153133977\"></a></p>\n<h2 id=\"解法一：利用reverse\">解法一：利用reverse</h2>\n<p>已经写过reverse的代码了，怎么复用结果来解决这道题呢？很简单，掐掉头和尾，把中间的反转，再拼起来就行了</p>\n<ul>\n<li>原版的reverse略有改动，prev 为反转后的尾部，原本反转后的尾部为NULL，现在为了方便我们改成“掐得的tail”</li>\n</ul>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    ListNode* reverseBetween(ListNode* head, int m, int n) {\n        ListNode* dummy = new ListNode(-1), * prev = dummy;\n        dummy-&gt;next = head;\n        for(int i = 1; i &lt; m; i++) prev = prev-&gt;next;\n        ListNode* curr = prev-&gt;next;\n        for(int i = m; i &lt; n; i++) curr = curr-&gt;next;\n        ListNode* tail = curr-&gt;next;\n        curr-&gt;next = NULL;\n        prev-&gt;next = reverse(prev-&gt;next, tail);\n        return dummy-&gt;next;\n    }\n\n    ListNode* reverse(ListNode* head, ListNode* prev){\n        ListNode* curr = head;\n        while(curr != NULL){\n            ListNode* next = curr-&gt;next;\n            curr-&gt;next = prev;\n            prev = curr;\n            curr = next;\n        }\n        return prev;\n    }\n};\n</code></pre>\n<h1 id=\"142-Linked-List-Cycle-II\"><a href=\"https://leetcode-cn.com/problems/linked-list-cycle-ii/\" target=\"_blank\" rel=\"noopener\">142. Linked List Cycle II</a></h1>\n<p><a href=\"LinkedList-Medium/image-20200510154722042.png\" title=\"image-20200510154722042\" class=\"gallery-item\"><img src=\"image-20200510154722042.png\" alt=\"image-20200510154722042\"></a></p>\n<h2 id=\"解法一：快慢指针-v2\">解法一：快慢指针</h2>\n<p>不同于检测环，会想当然地以为快慢指针相等时即为结果，但是一轮找出的结果并不一定是环的入口</p>\n<p>因此要从head和交点开始重新一轮遍历，当两者相遇时，即为环的入口</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n        if(!head) return NULL;\n        ListNode* cycle = getCycle(head);\n        if(!cycle) return NULL;\n        ListNode* curr = head;\n        while(curr != cycle) {\n            curr = curr-&gt;next;\n            cycle = cycle-&gt;next;\n        }\n        return cycle;\n    }\n\n    ListNode* getCycle(ListNode* head) {\n        ListNode* slow = head, * fast = head;\n        while(fast &amp;&amp; fast-&gt;next) {\n            slow = slow-&gt;next;\n            fast = fast-&gt;next-&gt;next;\n            if(slow == fast) return slow;\n        }\n        return NULL;\n    } \n};\n</code></pre>\n<h2 id=\"解法二：哈希法\">解法二：哈希法</h2>\n<p>比较简单的做法，要消耗O(n)空间</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n        unordered_set&lt;ListNode*&gt; set;\n        for(ListNode* curr = head; curr; curr = curr-&gt;next) {\n            if(set.find(curr) != set.end()) return curr;\n            set.insert(curr);\n        } \n        return NULL;\n    } \n};\n</code></pre>\n<h1 id=\"61-Rotate-List\"><a href=\"https://leetcode-cn.com/problems/rotate-list/\" target=\"_blank\" rel=\"noopener\">61. Rotate List</a></h1>\n<p><a href=\"LinkedList-Medium/image-20200516005205333.png\" title=\"image-20200516005205333\" class=\"gallery-item\"><img src=\"image-20200516005205333.png\" alt=\"image-20200516005205333\"></a></p>\n<h2 id=\"解法一：反转\">解法一：反转</h2>\n<ul>\n<li>先计算长度，把 k 模到长度范围内</li>\n<li>将整个链表反转</li>\n<li>找到第k个节点，截断，分别反转前后两部分</li>\n<li>再拼接，即为结果</li>\n</ul>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    int getLength(ListNode* head) {\n        int len = 0;\n        while (head) {\n            head = head-&gt;next;\n            len++;\n        }\n        return len;\n    }\n\n    ListNode* rotateRight(ListNode* head, int k) {\n        if(head == NULL) return NULL;\n        int len = getLength(head);\n        k = k % (len);\n        ListNode* dummy = new ListNode(-1);\n        dummy-&gt;next = reverse(head, NULL);\n        \n        ListNode* curr = dummy;\n        for(int i = 0; i &lt; k; i++) curr = curr-&gt;next;\n        ListNode* next = curr-&gt;next;\n        curr-&gt;next = NULL;\n        return reverse(dummy-&gt;next, reverse(next, NULL));\n    }\n\n    ListNode* reverse(ListNode* head, ListNode* tail) {\n        ListNode* prev = tail;\n        ListNode* curr = head;\n        while(curr != NULL) {\n            ListNode* next = curr-&gt;next;\n            curr-&gt;next = prev;\n            prev = curr;\n            curr = next;\n        }\n        return prev;\n    }\n};\n</code></pre>\n</div><script src=\"https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js\"></script><script>if (typeof lightGallery !== 'undefined') {\n        var options = {\n            selector: '.gallery-item'\n        };\n        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);\n        }</script>","more":"<h1 id=\"2-Add-Two-Numbers\"><a href=\"https://leetcode-cn.com/problems/add-two-numbers/\" target=\"_blank\" rel=\"noopener\">2. Add Two Numbers</a></h1>\n<p><a href=\"LinkedList-Medium/image-20200425175926684.png\" title=\"image-20200425175926684\" class=\"gallery-item\"><img src=\"image-20200425175926684.png\" alt=\"image-20200425175926684\"></a></p>\n<h2 id=\"解法一\">解法一</h2>\n<p>链表模拟加减法，先计算长度相等的部分，如果有一条链更长，那么第一次while结束后继续检查进位，不过这样子写很不优雅，下面优化版改了一下</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        int carry = 0;\n        ListNode* ans = new ListNode(-1);\n        ListNode* curr = ans;\n        while(l1 &amp;&amp; l2){\n            curr-&gt;next = new ListNode(l1-&gt;val + l2-&gt;val + carry);\n            curr = curr-&gt;next;\n            if(curr-&gt;val &gt; 9) {\n                curr-&gt;val -= 10;\n                carry = 1;\n            }\n            else carry = 0;\n            l1 = l1-&gt;next;\n            l2 = l2-&gt;next;\n        }\n        curr-&gt;next = l1 == NULL ? l2 : l1;\n        while(carry == 1 &amp;&amp; curr-&gt;next){\n            curr = curr-&gt;next;\n            curr-&gt;val += 1;\n            if(curr-&gt;val &gt; 9) curr-&gt;val -= 10;\n            else carry = 0;\n        }\n        if(curr-&gt;next == NULL &amp;&amp; carry == 1) curr-&gt;next = new ListNode(1); \n        return ans-&gt;next;\n    }\n};\n</code></pre>\n<h3 id=\"优化版\">优化版</h3>\n<p>没必要剪断之类的，如果某条链为0，直接加零就完事了</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        int carry = 0;\n        ListNode* head = new ListNode(-1);\n        ListNode* curr = head, * p1 = l1, * p2 = l2;\n        while(p1 != NULL || p2 != NULL){\n            int n1 = p1 == NULL ? 0 : p1-&gt;val;\n            int n2 = p2 == NULL ? 0 : p2-&gt;val;\n            int val = n1 + n2 + carry;\n            if(val &gt; 9){\n                val -= 10;\n                carry = 1;\n            }\n            else carry = 0;\n            curr-&gt;next = new ListNode(val);\n            curr = curr-&gt;next;\n            if(p1 != NULL) p1 = p1-&gt;next;\n            if(p2 != NULL) p2 = p2-&gt;next;\n        }\n        if(carry == 1) curr-&gt;next = new ListNode(1);\n        return head-&gt;next;\n    }\n};\n</code></pre>\n<h1 id=\"19-Remove-Nth-Node-From-End-of-List\"><a href=\"https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/\" target=\"_blank\" rel=\"noopener\">19. Remove Nth Node From End of List</a></h1>\n<p><a href=\"LinkedList-Medium/image-20200429150847161.png\" title=\"image-20200429150847161\" class=\"gallery-item\"><img src=\"image-20200429150847161.png\" alt=\"image-20200429150847161\"></a></p>\n<h2 id=\"解法一：快慢指针\">解法一：快慢指针</h2>\n<ul>\n<li>\n<p>经典链表操作快慢操作，类似的还有取中值</p>\n</li>\n<li>\n<p>由于n是合法的，不需要考虑超出长度的问题</p>\n</li>\n</ul>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n\tListNode* removeNthFromEnd(ListNode* head, int n) {\n\t\tListNode* h = new ListNode(-1);\n\t\th-&gt;next = head;\n\t\tListNode* fast = h, * slow = h;\n\t\tfor (int i = 0; i &lt;= n; i++)\n\t\t\tfast = fast-&gt;next;\n\t\tfor (fast; fast != NULL; fast = fast-&gt;next, slow = slow-&gt;next);\n\t\tslow-&gt;next = slow-&gt;next-&gt;next;\n\t\treturn h-&gt;next;\n\t}\n};\n</code></pre>\n<h1 id=\"86-Partition-List\"><a href=\"https://leetcode-cn.com/problems/partition-list/\" target=\"_blank\" rel=\"noopener\">86. Partition List</a></h1>\n<p><a href=\"LinkedList-Medium/image-20200502140417451.png\" title=\"image-20200502140417451\" class=\"gallery-item\"><img src=\"image-20200502140417451.png\" alt=\"image-20200502140417451\"></a></p>\n<h2 id=\"解法一：一次遍历\">解法一：一次遍历</h2>\n<p>加个表头方便操作</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    ListNode* partition(ListNode* head, int x) {\n        if(head == NULL) return head;\n        ListNode* curr = head, * n1 = new ListNode(-1), * n2 = new ListNode(-1),\n        * curr_1 = n1, * curr_2 = n2;\n        for(curr; curr != NULL; curr = curr-&gt;next){\n            if(curr-&gt;val &gt;= x){\n                curr_2-&gt;next = new ListNode(curr-&gt;val);\n                curr_2 = curr_2-&gt;next;\n            }\n            else{\n                curr_1-&gt;next = new ListNode(curr-&gt;val);\n                curr_1 = curr_1-&gt;next;\n            }\n        }\n        curr_1-&gt;next = n2-&gt;next;\n        return n1-&gt;next;\n    }\n};\n</code></pre>\n<h1 id=\"82-Remove-Duplicates-from-Sorted-List-II\"><a href=\"https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/\" target=\"_blank\" rel=\"noopener\">82. Remove Duplicates from Sorted List II</a></h1>\n<p><a href=\"LinkedList-Medium/image-20200502142031537.png\" title=\"image-20200502142031537\" class=\"gallery-item\"><img src=\"image-20200502142031537.png\" alt=\"image-20200502142031537\"></a></p>\n<h2 id=\"解法一：\">解法一：</h2>\n<p>因为单链表不能回溯且要求删掉所有出现重复的元素，因此需要进行预判，也就是</p>\n<pre><code class=\"language-cpp\">curr-&gt;next-&gt;next-&gt;val == curr-&gt;next-&gt;val\n</code></pre>\n<p>另外删完一组数后不要急着令curr = curr-&gt;next，因为可能存在连续的重复元素，如果直接指向下一个，那“预判”就失效了，因此我们让curr-&gt;next = n，这样就能用while继续预判了</p>\n<p>再另外，首位也可能重复，所以开一个新表头来预判首位元素</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    ListNode* deleteDuplicates(ListNode* head) {\n        ListNode* prev = new ListNode(-1), * curr = prev;\n        prev-&gt;next = head;\n        for (curr; curr != NULL; curr = curr-&gt;next){\n            while (curr-&gt;next &amp;&amp; curr-&gt;next-&gt;next &amp;&amp; curr-&gt;next-&gt;next-&gt;val == curr-&gt;next-&gt;val) {\n                int val = curr-&gt;next-&gt;val;\n                ListNode* n = curr-&gt;next;\n                for (n; n != NULL &amp;&amp; n-&gt;val == val; n = n-&gt;next);\n                curr-&gt;next = n;\n            }\n        }\n        return prev-&gt;next;\n    }\n};\n</code></pre>\n<h1 id=\"92-Reverse-Linked-List-II\"><a href=\"https://leetcode-cn.com/problems/reverse-linked-list-ii/\" target=\"_blank\" rel=\"noopener\">92. Reverse Linked List II</a></h1>\n<p><a href=\"LinkedList-Medium/image-20200502153133977.png\" title=\"image-20200502153133977\" class=\"gallery-item\"><img src=\"image-20200502153133977.png\" alt=\"image-20200502153133977\"></a></p>\n<h2 id=\"解法一：利用reverse\">解法一：利用reverse</h2>\n<p>已经写过reverse的代码了，怎么复用结果来解决这道题呢？很简单，掐掉头和尾，把中间的反转，再拼起来就行了</p>\n<ul>\n<li>原版的reverse略有改动，prev 为反转后的尾部，原本反转后的尾部为NULL，现在为了方便我们改成“掐得的tail”</li>\n</ul>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    ListNode* reverseBetween(ListNode* head, int m, int n) {\n        ListNode* dummy = new ListNode(-1), * prev = dummy;\n        dummy-&gt;next = head;\n        for(int i = 1; i &lt; m; i++) prev = prev-&gt;next;\n        ListNode* curr = prev-&gt;next;\n        for(int i = m; i &lt; n; i++) curr = curr-&gt;next;\n        ListNode* tail = curr-&gt;next;\n        curr-&gt;next = NULL;\n        prev-&gt;next = reverse(prev-&gt;next, tail);\n        return dummy-&gt;next;\n    }\n\n    ListNode* reverse(ListNode* head, ListNode* prev){\n        ListNode* curr = head;\n        while(curr != NULL){\n            ListNode* next = curr-&gt;next;\n            curr-&gt;next = prev;\n            prev = curr;\n            curr = next;\n        }\n        return prev;\n    }\n};\n</code></pre>\n<h1 id=\"142-Linked-List-Cycle-II\"><a href=\"https://leetcode-cn.com/problems/linked-list-cycle-ii/\" target=\"_blank\" rel=\"noopener\">142. Linked List Cycle II</a></h1>\n<p><a href=\"LinkedList-Medium/image-20200510154722042.png\" title=\"image-20200510154722042\" class=\"gallery-item\"><img src=\"image-20200510154722042.png\" alt=\"image-20200510154722042\"></a></p>\n<h2 id=\"解法一：快慢指针-v2\">解法一：快慢指针</h2>\n<p>不同于检测环，会想当然地以为快慢指针相等时即为结果，但是一轮找出的结果并不一定是环的入口</p>\n<p>因此要从head和交点开始重新一轮遍历，当两者相遇时，即为环的入口</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n        if(!head) return NULL;\n        ListNode* cycle = getCycle(head);\n        if(!cycle) return NULL;\n        ListNode* curr = head;\n        while(curr != cycle) {\n            curr = curr-&gt;next;\n            cycle = cycle-&gt;next;\n        }\n        return cycle;\n    }\n\n    ListNode* getCycle(ListNode* head) {\n        ListNode* slow = head, * fast = head;\n        while(fast &amp;&amp; fast-&gt;next) {\n            slow = slow-&gt;next;\n            fast = fast-&gt;next-&gt;next;\n            if(slow == fast) return slow;\n        }\n        return NULL;\n    } \n};\n</code></pre>\n<h2 id=\"解法二：哈希法\">解法二：哈希法</h2>\n<p>比较简单的做法，要消耗O(n)空间</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n        unordered_set&lt;ListNode*&gt; set;\n        for(ListNode* curr = head; curr; curr = curr-&gt;next) {\n            if(set.find(curr) != set.end()) return curr;\n            set.insert(curr);\n        } \n        return NULL;\n    } \n};\n</code></pre>\n<h1 id=\"61-Rotate-List\"><a href=\"https://leetcode-cn.com/problems/rotate-list/\" target=\"_blank\" rel=\"noopener\">61. Rotate List</a></h1>\n<p><a href=\"LinkedList-Medium/image-20200516005205333.png\" title=\"image-20200516005205333\" class=\"gallery-item\"><img src=\"image-20200516005205333.png\" alt=\"image-20200516005205333\"></a></p>\n<h2 id=\"解法一：反转\">解法一：反转</h2>\n<ul>\n<li>先计算长度，把 k 模到长度范围内</li>\n<li>将整个链表反转</li>\n<li>找到第k个节点，截断，分别反转前后两部分</li>\n<li>再拼接，即为结果</li>\n</ul>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    int getLength(ListNode* head) {\n        int len = 0;\n        while (head) {\n            head = head-&gt;next;\n            len++;\n        }\n        return len;\n    }\n\n    ListNode* rotateRight(ListNode* head, int k) {\n        if(head == NULL) return NULL;\n        int len = getLength(head);\n        k = k % (len);\n        ListNode* dummy = new ListNode(-1);\n        dummy-&gt;next = reverse(head, NULL);\n        \n        ListNode* curr = dummy;\n        for(int i = 0; i &lt; k; i++) curr = curr-&gt;next;\n        ListNode* next = curr-&gt;next;\n        curr-&gt;next = NULL;\n        return reverse(dummy-&gt;next, reverse(next, NULL));\n    }\n\n    ListNode* reverse(ListNode* head, ListNode* tail) {\n        ListNode* prev = tail;\n        ListNode* curr = head;\n        while(curr != NULL) {\n            ListNode* next = curr-&gt;next;\n            curr-&gt;next = prev;\n            prev = curr;\n            curr = next;\n        }\n        return prev;\n    }\n};\n</code></pre>\n<script src=\"https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js\"></script><script>if (typeof lightGallery !== 'undefined') {\n        var options = {\n            selector: '.gallery-item'\n        };\n        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);\n        }</script>","categories":[{"name":"Algorithm","path":"api/categories/Algorithm.json"}],"tags":[{"name":"Leetcode","path":"api/tags/Leetcode.json"}]}