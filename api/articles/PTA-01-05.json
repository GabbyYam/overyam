{"title":"PTA 001-010","slug":"PTA-01-05","date":"2020-04-01T07:33:25.000Z","updated":"2020-04-01T11:45:38.289Z","comments":true,"path":"api/articles/PTA-01-05.json","excerpt":"Abstract：PTA乙级","covers":["image-20200401154141730.png","image-20200401163415171.png"],"content":"<link rel=\"stylesheet\" type=\"text/css\" href=\"https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css\"><div class=\".article-gallery\" <p><strong>Abstract</strong>：PTA乙级<p></p>\n<a id=\"more\"></a>\n<h1 id=\"1001-A-B-Format-20分\"><a href=\"https://pintia.cn/problem-sets/994805342720868352/problems/994805528788582400\" target=\"_blank\" rel=\"noopener\">1001 A+B Format (20分)</a></h1>\n<p><a href=\"PTA-01-05/image-20200401154141730.png\" title=\"image-20200401154141730\" class=\"gallery-item\"><img src=\"image-20200401154141730.png\" alt=\"image-20200401154141730\"></a></p>\n<h2 id=\"解法一\">解法一</h2>\n<ul>\n<li>每三个数加入一个逗号</li>\n<li>记得处理零，负号以及头部的逗号</li>\n</ul>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n\n// Parse number to string\nstd::string toString(int x) {\n\tstd::string ans = &quot;&quot;;\n\tint count = 0;\n\twhile (x != 0) {\n\t\tchar n = x % 10;\n\t\tans += n+48;\n\t\tcount++;\n\t\tif (count % 3 == 0)ans += ',';\n\t\tx /= 10;\n\t}\n\treturn ans;\n}\n\nint main(){\n\tint a, b;\n\tstd::cin &gt;&gt; a &gt;&gt; b;\n\tstd::string str;\n\tint number = a + b;\n\t// Zero\n\tif (number == 0) {\n\t\tstd::cout &lt;&lt; 0;\n\t\treturn 0;\n\t}\n\t// Negative\n\telse if (number &lt; 0) {\n\t\tstr = toString(-(number));\n\t\tstd::cout &lt;&lt; '-';\n\t}\n\t// Positive\n\telse str = toString(number);\n\n\t// Linear scan\n\tint len = str.length();\n\tfor (int i = len-1 ; i &gt; -1;i--) {\n\t\tif (i == len - 1 &amp;&amp; str.at(i) == ',')continue;\n\t\telse std::cout &lt;&lt; str.at(i);\n\t}\n}\n</code></pre>\n<h2 id=\"解法二：to-string（）\">解法二：to_string（）</h2>\n<p>to_string很方便，但是要动态输出逗号</p>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\nint main() {\n    int a, b;\n    std::cin &gt;&gt; a &gt;&gt; b;\n    std::string s = std::to_string(a + b);\n    int len = s.length();\n    for (int i = 0; i &lt; len; i++) {\n        std::cout &lt;&lt; s.at(i);\n        if (s.at(i) == '-') continue;\n        if ((i + 1) % 3 == len % 3 ) std::cout &lt;&lt; &quot;,&quot;;\n    }\n    return 0;\n}\n</code></pre>\n<h1 id=\"1002-A-B-for-Polynomials-25分\"><a href=\"https://pintia.cn/problem-sets/994805342720868352/problems/994805526272000000\" target=\"_blank\" rel=\"noopener\">1002 A+B for Polynomials (25分)</a></h1>\n<p><a href=\"PTA-01-05/image-20200401163415171.png\" title=\"image-20200401163415171\" class=\"gallery-item\"><img src=\"image-20200401163415171.png\" alt=\"image-20200401163415171\"></a></p>\n<h2 id=\"解法一：unordered-map\">解法一：unordered_map</h2>\n<p>也就是哈希表，剩下的就是将输入解析到map中再遍历输出，但是由于输出顺序原因没法通过的样子…</p>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;unordered_map&gt;\n\nstd::unordered_map&lt;float, float&gt; map;\n\n// Parse input\nvoid ParseInput() {\n\tint num;\n\tfloat coef, exp;\n\tstd::cin &gt;&gt; num;\n\tfor (int i = 0; i &lt; num; i++) {\n\t\tstd::cin &gt;&gt; exp &gt;&gt; coef;\n\t\tauto key = map.find(exp);                   // find exp\n\t\tif (key != map.end()) key-&gt;second += coef;  // Update value\n\t\telse map.insert(std::make_pair(exp, coef)); // If not exist , insert a new node\n\t}\n}\n\nint main() {\n\tParseInput(); // First line\n\tParseInput(); // Second line\n\n\t// Output\n\tstd::cout &lt;&lt; map.size(); \n\tfor (const auto &amp;it : map) {\n\t\tstd::cout &lt;&lt; &quot; &quot; &lt;&lt; it.first &lt;&lt; &quot; &quot; &lt;&lt; it.second;\n\t}\n\treturn 0;\n}\n</code></pre>\n<h2 id=\"解法二：数组模拟哈希表\">解法二：数组模拟哈希表</h2>\n<p>比上面更消耗空间，如果有更多的exp的话是没法这样做的，但这里只有1000个而且这种办法可以逆序遍历</p>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n\nfloat map[1005] = { 0 };\nint size = 0;\n\n// Parse input\nvoid ParseInput() {\n    int num, exp;\n    float coef;\n    std::cin &gt;&gt; num;\n    for (int i = 0; i &lt; num; i++) {\n        std::cin &gt;&gt; exp &gt;&gt; coef;\n        if (map[exp] == 0)size++;       // Count size\n        map[exp] += coef;               // Update value\n        if (map[exp] == 0)size--;       // If coef back to zero , delete it , or you have to transverse the map again\n    }\n}\n\nint main() {\n    ParseInput(); // First line\n    ParseInput(); // Second line\n\n    std::cout &lt;&lt; size;\n\n    for (int i = 1000; i &gt;= 0; i--) {\n        if (map[i] != 0.0)\n            std::cout &lt;&lt; &quot; &quot; &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; std::setiosflags(std::ios::fixed) &lt;&lt; std::setprecision(1) &lt;&lt; map[i]; \n        // fix the format of float\n    }\n    return 0;\n}\n</code></pre>\n<h1 id=\"New-Trick-in-coding\">New Trick in coding</h1>\n<ul>\n<li>\n<p>C++下的精度控制</p>\n<pre><code class=\"language-cpp\">// include others\n#include &lt;iomanip&gt;\n\n// main ...\nstd::cout &lt;&lt; std::setiosflags(std::ios::fixed) &lt;&lt; std::setprecision(1) &lt;&lt; floatNumber;\n</code></pre>\n</li>\n</ul>\n</div><script src=\"https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js\"></script><script>if (typeof lightGallery !== 'undefined') {\n        var options = {\n            selector: '.gallery-item'\n        };\n        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);\n        }</script>","more":"<h1 id=\"1001-A-B-Format-20分\"><a href=\"https://pintia.cn/problem-sets/994805342720868352/problems/994805528788582400\" target=\"_blank\" rel=\"noopener\">1001 A+B Format (20分)</a></h1>\n<p><a href=\"PTA-01-05/image-20200401154141730.png\" title=\"image-20200401154141730\" class=\"gallery-item\"><img src=\"image-20200401154141730.png\" alt=\"image-20200401154141730\"></a></p>\n<h2 id=\"解法一\">解法一</h2>\n<ul>\n<li>每三个数加入一个逗号</li>\n<li>记得处理零，负号以及头部的逗号</li>\n</ul>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n\n// Parse number to string\nstd::string toString(int x) {\n\tstd::string ans = &quot;&quot;;\n\tint count = 0;\n\twhile (x != 0) {\n\t\tchar n = x % 10;\n\t\tans += n+48;\n\t\tcount++;\n\t\tif (count % 3 == 0)ans += ',';\n\t\tx /= 10;\n\t}\n\treturn ans;\n}\n\nint main(){\n\tint a, b;\n\tstd::cin &gt;&gt; a &gt;&gt; b;\n\tstd::string str;\n\tint number = a + b;\n\t// Zero\n\tif (number == 0) {\n\t\tstd::cout &lt;&lt; 0;\n\t\treturn 0;\n\t}\n\t// Negative\n\telse if (number &lt; 0) {\n\t\tstr = toString(-(number));\n\t\tstd::cout &lt;&lt; '-';\n\t}\n\t// Positive\n\telse str = toString(number);\n\n\t// Linear scan\n\tint len = str.length();\n\tfor (int i = len-1 ; i &gt; -1;i--) {\n\t\tif (i == len - 1 &amp;&amp; str.at(i) == ',')continue;\n\t\telse std::cout &lt;&lt; str.at(i);\n\t}\n}\n</code></pre>\n<h2 id=\"解法二：to-string（）\">解法二：to_string（）</h2>\n<p>to_string很方便，但是要动态输出逗号</p>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\nint main() {\n    int a, b;\n    std::cin &gt;&gt; a &gt;&gt; b;\n    std::string s = std::to_string(a + b);\n    int len = s.length();\n    for (int i = 0; i &lt; len; i++) {\n        std::cout &lt;&lt; s.at(i);\n        if (s.at(i) == '-') continue;\n        if ((i + 1) % 3 == len % 3 ) std::cout &lt;&lt; &quot;,&quot;;\n    }\n    return 0;\n}\n</code></pre>\n<h1 id=\"1002-A-B-for-Polynomials-25分\"><a href=\"https://pintia.cn/problem-sets/994805342720868352/problems/994805526272000000\" target=\"_blank\" rel=\"noopener\">1002 A+B for Polynomials (25分)</a></h1>\n<p><a href=\"PTA-01-05/image-20200401163415171.png\" title=\"image-20200401163415171\" class=\"gallery-item\"><img src=\"image-20200401163415171.png\" alt=\"image-20200401163415171\"></a></p>\n<h2 id=\"解法一：unordered-map\">解法一：unordered_map</h2>\n<p>也就是哈希表，剩下的就是将输入解析到map中再遍历输出，但是由于输出顺序原因没法通过的样子…</p>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;unordered_map&gt;\n\nstd::unordered_map&lt;float, float&gt; map;\n\n// Parse input\nvoid ParseInput() {\n\tint num;\n\tfloat coef, exp;\n\tstd::cin &gt;&gt; num;\n\tfor (int i = 0; i &lt; num; i++) {\n\t\tstd::cin &gt;&gt; exp &gt;&gt; coef;\n\t\tauto key = map.find(exp);                   // find exp\n\t\tif (key != map.end()) key-&gt;second += coef;  // Update value\n\t\telse map.insert(std::make_pair(exp, coef)); // If not exist , insert a new node\n\t}\n}\n\nint main() {\n\tParseInput(); // First line\n\tParseInput(); // Second line\n\n\t// Output\n\tstd::cout &lt;&lt; map.size(); \n\tfor (const auto &amp;it : map) {\n\t\tstd::cout &lt;&lt; &quot; &quot; &lt;&lt; it.first &lt;&lt; &quot; &quot; &lt;&lt; it.second;\n\t}\n\treturn 0;\n}\n</code></pre>\n<h2 id=\"解法二：数组模拟哈希表\">解法二：数组模拟哈希表</h2>\n<p>比上面更消耗空间，如果有更多的exp的话是没法这样做的，但这里只有1000个而且这种办法可以逆序遍历</p>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n\nfloat map[1005] = { 0 };\nint size = 0;\n\n// Parse input\nvoid ParseInput() {\n    int num, exp;\n    float coef;\n    std::cin &gt;&gt; num;\n    for (int i = 0; i &lt; num; i++) {\n        std::cin &gt;&gt; exp &gt;&gt; coef;\n        if (map[exp] == 0)size++;       // Count size\n        map[exp] += coef;               // Update value\n        if (map[exp] == 0)size--;       // If coef back to zero , delete it , or you have to transverse the map again\n    }\n}\n\nint main() {\n    ParseInput(); // First line\n    ParseInput(); // Second line\n\n    std::cout &lt;&lt; size;\n\n    for (int i = 1000; i &gt;= 0; i--) {\n        if (map[i] != 0.0)\n            std::cout &lt;&lt; &quot; &quot; &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; std::setiosflags(std::ios::fixed) &lt;&lt; std::setprecision(1) &lt;&lt; map[i]; \n        // fix the format of float\n    }\n    return 0;\n}\n</code></pre>\n<h1 id=\"New-Trick-in-coding\">New Trick in coding</h1>\n<ul>\n<li>\n<p>C++下的精度控制</p>\n<pre><code class=\"language-cpp\">// include others\n#include &lt;iomanip&gt;\n\n// main ...\nstd::cout &lt;&lt; std::setiosflags(std::ios::fixed) &lt;&lt; std::setprecision(1) &lt;&lt; floatNumber;\n</code></pre>\n</li>\n</ul>\n<script src=\"https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js\"></script><script>if (typeof lightGallery !== 'undefined') {\n        var options = {\n            selector: '.gallery-item'\n        };\n        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);\n        }</script>","categories":[{"name":"Algorithm","path":"api/categories/Algorithm.json"}],"tags":[{"name":"PTA","path":"api/tags/PTA.json"}]}