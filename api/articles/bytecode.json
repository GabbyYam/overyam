{"title":"Java bytecode 玩法不完全指北","slug":"bytecode","date":"2020-03-05T04:24:18.000Z","updated":"2020-03-06T14:44:49.360Z","comments":true,"path":"api/articles/bytecode.json","excerpt":"Abstract：打开.class文件康康 byte code的组成 &amp; 字节码增强是什么(以Jvms8为例)","covers":["https://static.javatpoint.com/blog/images/java-bytecode.png","image-20200306180808028.png","image-20200305181623284.png","image-20200305183423582.png","image-20200306181105461.png","image-20200306181807754.png","image-20200305191859359.png","image-20200305183857544.png"],"content":"<link rel=\"stylesheet\" type=\"text/css\" href=\"https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css\"><div class=\".article-gallery\" <p><strong>Abstract</strong>：打开<code>.class</code>文件康康 <code>byte code</code>的组成 &amp; 字节码增强是什么(以Jvms8为例)<p></p>\n<a id=\"more\"></a>\n<p>要玩bytecode，还是先简单看一眼bytecode的设计定位和内部结构</p>\n<h1 id=\"What-？\">What ？</h1>\n<ul>\n<li>\n<p>bytecode是一套Java虚拟机的指令集，或者说是以.class文件为形式的机器码，再通过<strong>Java interpreter</strong>对接各种不同的操作系统，以此帮助Java实现了<strong>平台独立性</strong>，也就是<strong>compile once,run every where</strong></p>\n</li>\n<li>\n<p>另外，由于只要满足字节码的形式，JVM甚至可以兼容其他语言（Kotlin、Scala），大大提高了扩展性，当然本篇还是以Java为例</p>\n</li>\n</ul>\n<h1 id=\"How\">How ?</h1>\n<p><a href=\"https://static.javatpoint.com/blog/images/java-bytecode.png\" title=\"Java Bytecode\" class=\"gallery-item\"><img src=\"https://static.javatpoint.com/blog/images/java-bytecode.png\" alt=\"Java Bytecode\"></a></p>\n<ul>\n<li>.java 通过 <strong>javac</strong> 编译生成 .class文件</li>\n<li>.class文件通过 <strong>Java interpreter</strong>对接操作系统和硬件（当然不包括native method）</li>\n</ul>\n<h1 id=\"Structure\">Structure</h1>\n<p><a href=\"bytecode/image-20200306180808028.png\" title=\"image-20200306180808028\" class=\"gallery-item\"><img src=\"image-20200306180808028.png\" alt=\"image-20200306180808028\"></a></p>\n<ul>\n<li>上表中的结构不局限于HotSpot虚拟机，而是JVM Specification中的规定</li>\n<li>下面以这样一个自定义类为例：</li>\n</ul>\n<pre><code class=\"language-java\">/**\n * @author GabbyYam\n * @date 2020/3/5\n */\npublic class YamCode {\n    public String yam_name;\n    private int yam_total;\n\n    public String getYam_name() {\n        return yam_name;\n    }\n\n    public void setYam_name(String yam_name) {\n        this.yam_name = yam_name;\n    }\n\n    public int getYam_total() {\n        return yam_total;\n    }\n\n    public void setYam_total(int yam_total) {\n        this.yam_total = yam_total;\n    }\n}\n\n</code></pre>\n<h2 id=\"magic\">magic</h2>\n<ul>\n<li>对其<code>javac</code> 编译：可见.class文件中存在magic标记：cafebabe，代表初代开发团队成员喜欢的一种咖啡，是class文件的标记符</li>\n</ul>\n<p><a href=\"bytecode/image-20200305181623284.png\" title=\"image-20200305181623284\" class=\"gallery-item\"><img src=\"image-20200305181623284.png\" alt=\"image-20200305181623284\"></a></p>\n<ul>\n<li>为了方便理解（字节码也没法理解），我们<code>javap -verbose</code>反编译，将其转换为可理解的代码</li>\n</ul>\n<p><a href=\"bytecode/image-20200305183423582.png\" title=\"image-20200305183423582\" class=\"gallery-item\"><img src=\"image-20200305183423582.png\" alt=\"image-20200305183423582\"></a></p>\n<ul>\n<li>全限定类名、版本号以及权限控制相关的标记符</li>\n</ul>\n<h2 id=\"版本号\">版本号</h2>\n<ul>\n<li>主次版本号从45起记，各版本号范围依次为</li>\n<li>新版本可以兼容低版本，反之则不行</li>\n</ul>\n<p><a href=\"bytecode/image-20200306181105461.png\" title=\"image-20200306181105461\" class=\"gallery-item\"><img src=\"image-20200306181105461.png\" alt=\"image-20200306181105461\"></a></p>\n<h2 id=\"访问控制符\">访问控制符</h2>\n<ul>\n<li>其中MODULE为Java9新增的部分</li>\n</ul>\n<p><a href=\"bytecode/image-20200306181807754.png\" title=\"image-20200306181807754\" class=\"gallery-item\"><img src=\"image-20200306181807754.png\" alt=\"image-20200306181807754\"></a></p>\n<h2 id=\"常量池-Constant-pool\">常量池 Constant pool</h2>\n<p><a href=\"bytecode/image-20200305191859359.png\" title=\"image-20200305191859359\" class=\"gallery-item\"><img src=\"image-20200305191859359.png\" alt=\"image-20200305191859359\"></a></p>\n<ul>\n<li>需要注意的是常量池中的常量<strong>具备动态性</strong>，也就是说，不一定在编译期产生，比如常见的String.intern(String.valueOf(“xx”))</li>\n<li>也是基于动态性，常量池需要向<code>Method Area</code>申请方法区内存，所以有OutOfMemoryError的可能</li>\n</ul>\n<h2 id=\"方法属性method-info\">方法属性method_info</h2>\n<p><a href=\"bytecode/image-20200305183857544.png\" title=\"image-20200305183857544\" class=\"gallery-item\"><img src=\"image-20200305183857544.png\" alt=\"image-20200305183857544\"></a></p>\n<p><strong>其中有三段重要信息</strong></p>\n<h3 id=\"Code：即方法内包含的操作码集合\">Code：即方法内包含的操作码集合</h3>\n<ul>\n<li>对应JVM指令操作码，比如图中的aload_0表示将局部变量压入操作数栈，详细操作码解释参见<a href=\"https://en.wikipedia.org/wiki/Java_bytecode_instruction_listings\" target=\"_blank\" rel=\"noopener\">Java bytecode instruction listings</a></li>\n</ul>\n<h3 id=\"LineNumberTable\">LineNumberTable</h3>\n<ul>\n<li>\n<p>Code中操作码对应源码的行数，也即下面这句话对应的位置</p>\n<pre><code class=\"language-java\">return yam_name;\n</code></pre>\n</li>\n</ul>\n<h3 id=\"LocalVariableTable\">LocalVariableTable</h3>\n<ul>\n<li>方法内局部变量表</li>\n</ul>\n<h1 id=\"字节码增强\">字节码增强</h1>\n</div><script src=\"https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js\"></script><script>if (typeof lightGallery !== 'undefined') {\n        var options = {\n            selector: '.gallery-item'\n        };\n        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);\n        }</script>","more":"<p>要玩bytecode，还是先简单看一眼bytecode的设计定位和内部结构</p>\n<h1 id=\"What-？\">What ？</h1>\n<ul>\n<li>\n<p>bytecode是一套Java虚拟机的指令集，或者说是以.class文件为形式的机器码，再通过<strong>Java interpreter</strong>对接各种不同的操作系统，以此帮助Java实现了<strong>平台独立性</strong>，也就是<strong>compile once,run every where</strong></p>\n</li>\n<li>\n<p>另外，由于只要满足字节码的形式，JVM甚至可以兼容其他语言（Kotlin、Scala），大大提高了扩展性，当然本篇还是以Java为例</p>\n</li>\n</ul>\n<h1 id=\"How\">How ?</h1>\n<p><a href=\"https://static.javatpoint.com/blog/images/java-bytecode.png\" title=\"Java Bytecode\" class=\"gallery-item\"><img src=\"https://static.javatpoint.com/blog/images/java-bytecode.png\" alt=\"Java Bytecode\"></a></p>\n<ul>\n<li>.java 通过 <strong>javac</strong> 编译生成 .class文件</li>\n<li>.class文件通过 <strong>Java interpreter</strong>对接操作系统和硬件（当然不包括native method）</li>\n</ul>\n<h1 id=\"Structure\">Structure</h1>\n<p><a href=\"bytecode/image-20200306180808028.png\" title=\"image-20200306180808028\" class=\"gallery-item\"><img src=\"image-20200306180808028.png\" alt=\"image-20200306180808028\"></a></p>\n<ul>\n<li>上表中的结构不局限于HotSpot虚拟机，而是JVM Specification中的规定</li>\n<li>下面以这样一个自定义类为例：</li>\n</ul>\n<pre><code class=\"language-java\">/**\n * @author GabbyYam\n * @date 2020/3/5\n */\npublic class YamCode {\n    public String yam_name;\n    private int yam_total;\n\n    public String getYam_name() {\n        return yam_name;\n    }\n\n    public void setYam_name(String yam_name) {\n        this.yam_name = yam_name;\n    }\n\n    public int getYam_total() {\n        return yam_total;\n    }\n\n    public void setYam_total(int yam_total) {\n        this.yam_total = yam_total;\n    }\n}\n\n</code></pre>\n<h2 id=\"magic\">magic</h2>\n<ul>\n<li>对其<code>javac</code> 编译：可见.class文件中存在magic标记：cafebabe，代表初代开发团队成员喜欢的一种咖啡，是class文件的标记符</li>\n</ul>\n<p><a href=\"bytecode/image-20200305181623284.png\" title=\"image-20200305181623284\" class=\"gallery-item\"><img src=\"image-20200305181623284.png\" alt=\"image-20200305181623284\"></a></p>\n<ul>\n<li>为了方便理解（字节码也没法理解），我们<code>javap -verbose</code>反编译，将其转换为可理解的代码</li>\n</ul>\n<p><a href=\"bytecode/image-20200305183423582.png\" title=\"image-20200305183423582\" class=\"gallery-item\"><img src=\"image-20200305183423582.png\" alt=\"image-20200305183423582\"></a></p>\n<ul>\n<li>全限定类名、版本号以及权限控制相关的标记符</li>\n</ul>\n<h2 id=\"版本号\">版本号</h2>\n<ul>\n<li>主次版本号从45起记，各版本号范围依次为</li>\n<li>新版本可以兼容低版本，反之则不行</li>\n</ul>\n<p><a href=\"bytecode/image-20200306181105461.png\" title=\"image-20200306181105461\" class=\"gallery-item\"><img src=\"image-20200306181105461.png\" alt=\"image-20200306181105461\"></a></p>\n<h2 id=\"访问控制符\">访问控制符</h2>\n<ul>\n<li>其中MODULE为Java9新增的部分</li>\n</ul>\n<p><a href=\"bytecode/image-20200306181807754.png\" title=\"image-20200306181807754\" class=\"gallery-item\"><img src=\"image-20200306181807754.png\" alt=\"image-20200306181807754\"></a></p>\n<h2 id=\"常量池-Constant-pool\">常量池 Constant pool</h2>\n<p><a href=\"bytecode/image-20200305191859359.png\" title=\"image-20200305191859359\" class=\"gallery-item\"><img src=\"image-20200305191859359.png\" alt=\"image-20200305191859359\"></a></p>\n<ul>\n<li>需要注意的是常量池中的常量<strong>具备动态性</strong>，也就是说，不一定在编译期产生，比如常见的String.intern(String.valueOf(“xx”))</li>\n<li>也是基于动态性，常量池需要向<code>Method Area</code>申请方法区内存，所以有OutOfMemoryError的可能</li>\n</ul>\n<h2 id=\"方法属性method-info\">方法属性method_info</h2>\n<p><a href=\"bytecode/image-20200305183857544.png\" title=\"image-20200305183857544\" class=\"gallery-item\"><img src=\"image-20200305183857544.png\" alt=\"image-20200305183857544\"></a></p>\n<p><strong>其中有三段重要信息</strong></p>\n<h3 id=\"Code：即方法内包含的操作码集合\">Code：即方法内包含的操作码集合</h3>\n<ul>\n<li>对应JVM指令操作码，比如图中的aload_0表示将局部变量压入操作数栈，详细操作码解释参见<a href=\"https://en.wikipedia.org/wiki/Java_bytecode_instruction_listings\" target=\"_blank\" rel=\"noopener\">Java bytecode instruction listings</a></li>\n</ul>\n<h3 id=\"LineNumberTable\">LineNumberTable</h3>\n<ul>\n<li>\n<p>Code中操作码对应源码的行数，也即下面这句话对应的位置</p>\n<pre><code class=\"language-java\">return yam_name;\n</code></pre>\n</li>\n</ul>\n<h3 id=\"LocalVariableTable\">LocalVariableTable</h3>\n<ul>\n<li>方法内局部变量表</li>\n</ul>\n<h1 id=\"字节码增强\">字节码增强</h1>\n<script src=\"https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js\"></script><script>if (typeof lightGallery !== 'undefined') {\n        var options = {\n            selector: '.gallery-item'\n        };\n        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);\n        }</script>","categories":[{"name":"Java","path":"api/categories/Java.json"}],"tags":[]}