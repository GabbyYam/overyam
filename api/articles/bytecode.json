{"title":"Java bytecode 玩法指北","slug":"bytecode","date":"2020-03-05T04:24:18.000Z","updated":"2020-03-05T11:40:08.130Z","comments":true,"path":"api/articles/bytecode.json","excerpt":"Abstract：打开.class文件康康 byte code的组成 &amp; 字节码增强是什么","covers":["https://static.javatpoint.com/blog/images/java-bytecode.png","image-20200305181623284.png","image-20200305183423582.png","image-20200305191859359.png","image-20200305183857544.png"],"content":"<link rel=\"stylesheet\" type=\"text/css\" href=\"https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css\"><div class=\".article-gallery\" <p><strong>Abstract</strong>：打开<code>.class</code>文件康康 <code>byte code</code>的组成 &amp; 字节码增强是什么<p></p>\n<a id=\"more\"></a>\n<h1 id=\"What-？\">What ？</h1>\n<ul>\n<li>\n<p>bytecode是一套Java虚拟机的指令集，或者说是以.class文件为形式的机器码，再通过<strong>Java interpreter</strong>对接各种不同的操作系统，以此帮助Java实现了平台独立性，也就是<strong>compile once,run every where</strong></p>\n</li>\n<li>\n<p>另外，由于只要满足字节码的形式，JVM甚至可以兼容其他语言（Kotlin、Scala），大大提高了扩展性，当然本篇还是以Java为例</p>\n</li>\n</ul>\n<h1 id=\"How\">How ?</h1>\n<p><a href=\"https://static.javatpoint.com/blog/images/java-bytecode.png\" title=\"Java Bytecode\" class=\"gallery-item\"><img src=\"https://static.javatpoint.com/blog/images/java-bytecode.png\" alt=\"Java Bytecode\"></a></p>\n<ul>\n<li>.java 通过 <strong>javac</strong> 编译生成 .class文件</li>\n<li>.class文件通过 <strong>Java interpreter</strong>对接操作系统和硬件</li>\n</ul>\n<h1 id=\"Structure\">Structure</h1>\n<table>\n<thead>\n<tr>\n<th>Name</th>\n<th>Format</th>\n<th>Usage</th>\n<th>Size/byte</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Magic Number（魔数）</td>\n<td>0xCAFEBABE</td>\n<td>标记class文件</td>\n<td>4</td>\n</tr>\n<tr>\n<td>Version</td>\n<td>Minor Version + Major Version</td>\n<td>标记Java版本号</td>\n<td>4</td>\n</tr>\n<tr>\n<td>Constant_Pool</td>\n<td>count+[tag,length,bytes]*(count-1)</td>\n<td>常量池</td>\n<td>2+n</td>\n</tr>\n<tr>\n<td>Access_Flag</td>\n<td>0x00??</td>\n<td>标记关键字：权限控制符+static+final等</td>\n<td>2</td>\n</tr>\n<tr>\n<td>Class_Name</td>\n<td>xx.xx.xx如java.lang.String</td>\n<td>全限定类名</td>\n<td>2</td>\n</tr>\n<tr>\n<td>Parent_Name</td>\n<td>同上</td>\n<td>父类全限定类名</td>\n<td>2</td>\n</tr>\n<tr>\n<td>Interface_info</td>\n<td>count+[]*count</td>\n<td>接口信息</td>\n<td>2+n</td>\n</tr>\n<tr>\n<td>field</td>\n<td>count+[class_info]*count</td>\n<td>字段属性</td>\n<td>2+n</td>\n</tr>\n<tr>\n<td>method</td>\n<td>count+[method_info]*count</td>\n<td>方法表,其中方法名和方法的描述符都是常量池中的索引值，可以通过索引值在常量池中找到</td>\n<td>2+n</td>\n</tr>\n<tr>\n<td>method_property</td>\n<td><strong>code</strong>+<strong>LineNumberTable</strong>+<strong>LocalVariableTable</strong></td>\n<td>详细属性：字节码操作集合+行信息+本地变量</td>\n<td>n</td>\n</tr>\n<tr>\n<td>附加属性表</td>\n<td></td>\n<td>该项存放了在该文件中类或接口所定义属性的基本信息</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>下面以这样一个自定义类为例：</li>\n</ul>\n<pre><code class=\"language-java\">/**\n * @author GabbyYam\n * @date 2020/3/5\n */\npublic class YamCode {\n    public String yam_name;\n    private int yam_total;\n\n    public String getYam_name() {\n        return yam_name;\n    }\n\n    public void setYam_name(String yam_name) {\n        this.yam_name = yam_name;\n    }\n\n    public int getYam_total() {\n        return yam_total;\n    }\n\n    public void setYam_total(int yam_total) {\n        this.yam_total = yam_total;\n    }\n}\n\n</code></pre>\n<ul>\n<li>对其<code>javac</code> 编译：可见.class文件中存在magic_number标记</li>\n</ul>\n<p><a href=\"bytecode/image-20200305181623284.png\" title=\"image-20200305181623284\" class=\"gallery-item\"><img src=\"image-20200305181623284.png\" alt=\"image-20200305181623284\"></a></p>\n<ul>\n<li>为了方便理解（字节码也没法理解），我们<code>javap -verbose</code>反编译，将其转换为可理解的代码</li>\n</ul>\n<p><a href=\"bytecode/image-20200305183423582.png\" title=\"image-20200305183423582\" class=\"gallery-item\"><img src=\"image-20200305183423582.png\" alt=\"image-20200305183423582\"></a></p>\n<ul>\n<li>全限定类名、版本号以及权限控制相关的标记符</li>\n</ul>\n<h2 id=\"1、常量池\">1、常量池</h2>\n<p><a href=\"bytecode/image-20200305191859359.png\" title=\"image-20200305191859359\" class=\"gallery-item\"><img src=\"image-20200305191859359.png\" alt=\"image-20200305191859359\"></a></p>\n<h2 id=\"2、方法属性method-property\">2、方法属性method_property</h2>\n<p><a href=\"bytecode/image-20200305183857544.png\" title=\"image-20200305183857544\" class=\"gallery-item\"><img src=\"image-20200305183857544.png\" alt=\"image-20200305183857544\"></a></p>\n<p>其中有三段重要信息</p>\n<h3 id=\"Code：即方法内包含的操作码集合\">Code：即方法内包含的操作码集合</h3>\n<ul>\n<li>对应JVM指令操作码，比如图中的aload_0表示将局部变量压入操作数栈，详细操作码解释参见<a href=\"https://en.wikipedia.org/wiki/Java_bytecode_instruction_listings\" target=\"_blank\" rel=\"noopener\">Java bytecode instruction listings</a></li>\n</ul>\n<h3 id=\"LineNumberTable\">LineNumberTable</h3>\n<ul>\n<li>\n<p>Code中操作码对应源码的行数，也即下面这句话对应的位置</p>\n<pre><code class=\"language-java\">return yam_name;\n</code></pre>\n</li>\n</ul>\n<h3 id=\"LocalVariableTable\">LocalVariableTable</h3>\n<ul>\n<li>本地变量，一般的类不会出现</li>\n</ul>\n<h1 id=\"字节码增强\">字节码增强</h1>\n<p>下次接着写.jpg</p>\n</div><script src=\"https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js\"></script><script>if (typeof lightGallery !== 'undefined') {\n        var options = {\n            selector: '.gallery-item'\n        };\n        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);\n        }</script>","more":"<h1 id=\"What-？\">What ？</h1>\n<ul>\n<li>\n<p>bytecode是一套Java虚拟机的指令集，或者说是以.class文件为形式的机器码，再通过<strong>Java interpreter</strong>对接各种不同的操作系统，以此帮助Java实现了平台独立性，也就是<strong>compile once,run every where</strong></p>\n</li>\n<li>\n<p>另外，由于只要满足字节码的形式，JVM甚至可以兼容其他语言（Kotlin、Scala），大大提高了扩展性，当然本篇还是以Java为例</p>\n</li>\n</ul>\n<h1 id=\"How\">How ?</h1>\n<p><a href=\"https://static.javatpoint.com/blog/images/java-bytecode.png\" title=\"Java Bytecode\" class=\"gallery-item\"><img src=\"https://static.javatpoint.com/blog/images/java-bytecode.png\" alt=\"Java Bytecode\"></a></p>\n<ul>\n<li>.java 通过 <strong>javac</strong> 编译生成 .class文件</li>\n<li>.class文件通过 <strong>Java interpreter</strong>对接操作系统和硬件</li>\n</ul>\n<h1 id=\"Structure\">Structure</h1>\n<table>\n<thead>\n<tr>\n<th>Name</th>\n<th>Format</th>\n<th>Usage</th>\n<th>Size/byte</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Magic Number（魔数）</td>\n<td>0xCAFEBABE</td>\n<td>标记class文件</td>\n<td>4</td>\n</tr>\n<tr>\n<td>Version</td>\n<td>Minor Version + Major Version</td>\n<td>标记Java版本号</td>\n<td>4</td>\n</tr>\n<tr>\n<td>Constant_Pool</td>\n<td>count+[tag,length,bytes]*(count-1)</td>\n<td>常量池</td>\n<td>2+n</td>\n</tr>\n<tr>\n<td>Access_Flag</td>\n<td>0x00??</td>\n<td>标记关键字：权限控制符+static+final等</td>\n<td>2</td>\n</tr>\n<tr>\n<td>Class_Name</td>\n<td>xx.xx.xx如java.lang.String</td>\n<td>全限定类名</td>\n<td>2</td>\n</tr>\n<tr>\n<td>Parent_Name</td>\n<td>同上</td>\n<td>父类全限定类名</td>\n<td>2</td>\n</tr>\n<tr>\n<td>Interface_info</td>\n<td>count+[]*count</td>\n<td>接口信息</td>\n<td>2+n</td>\n</tr>\n<tr>\n<td>field</td>\n<td>count+[class_info]*count</td>\n<td>字段属性</td>\n<td>2+n</td>\n</tr>\n<tr>\n<td>method</td>\n<td>count+[method_info]*count</td>\n<td>方法表,其中方法名和方法的描述符都是常量池中的索引值，可以通过索引值在常量池中找到</td>\n<td>2+n</td>\n</tr>\n<tr>\n<td>method_property</td>\n<td><strong>code</strong>+<strong>LineNumberTable</strong>+<strong>LocalVariableTable</strong></td>\n<td>详细属性：字节码操作集合+行信息+本地变量</td>\n<td>n</td>\n</tr>\n<tr>\n<td>附加属性表</td>\n<td></td>\n<td>该项存放了在该文件中类或接口所定义属性的基本信息</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>下面以这样一个自定义类为例：</li>\n</ul>\n<pre><code class=\"language-java\">/**\n * @author GabbyYam\n * @date 2020/3/5\n */\npublic class YamCode {\n    public String yam_name;\n    private int yam_total;\n\n    public String getYam_name() {\n        return yam_name;\n    }\n\n    public void setYam_name(String yam_name) {\n        this.yam_name = yam_name;\n    }\n\n    public int getYam_total() {\n        return yam_total;\n    }\n\n    public void setYam_total(int yam_total) {\n        this.yam_total = yam_total;\n    }\n}\n\n</code></pre>\n<ul>\n<li>对其<code>javac</code> 编译：可见.class文件中存在magic_number标记</li>\n</ul>\n<p><a href=\"bytecode/image-20200305181623284.png\" title=\"image-20200305181623284\" class=\"gallery-item\"><img src=\"image-20200305181623284.png\" alt=\"image-20200305181623284\"></a></p>\n<ul>\n<li>为了方便理解（字节码也没法理解），我们<code>javap -verbose</code>反编译，将其转换为可理解的代码</li>\n</ul>\n<p><a href=\"bytecode/image-20200305183423582.png\" title=\"image-20200305183423582\" class=\"gallery-item\"><img src=\"image-20200305183423582.png\" alt=\"image-20200305183423582\"></a></p>\n<ul>\n<li>全限定类名、版本号以及权限控制相关的标记符</li>\n</ul>\n<h2 id=\"1、常量池\">1、常量池</h2>\n<p><a href=\"bytecode/image-20200305191859359.png\" title=\"image-20200305191859359\" class=\"gallery-item\"><img src=\"image-20200305191859359.png\" alt=\"image-20200305191859359\"></a></p>\n<h2 id=\"2、方法属性method-property\">2、方法属性method_property</h2>\n<p><a href=\"bytecode/image-20200305183857544.png\" title=\"image-20200305183857544\" class=\"gallery-item\"><img src=\"image-20200305183857544.png\" alt=\"image-20200305183857544\"></a></p>\n<p>其中有三段重要信息</p>\n<h3 id=\"Code：即方法内包含的操作码集合\">Code：即方法内包含的操作码集合</h3>\n<ul>\n<li>对应JVM指令操作码，比如图中的aload_0表示将局部变量压入操作数栈，详细操作码解释参见<a href=\"https://en.wikipedia.org/wiki/Java_bytecode_instruction_listings\" target=\"_blank\" rel=\"noopener\">Java bytecode instruction listings</a></li>\n</ul>\n<h3 id=\"LineNumberTable\">LineNumberTable</h3>\n<ul>\n<li>\n<p>Code中操作码对应源码的行数，也即下面这句话对应的位置</p>\n<pre><code class=\"language-java\">return yam_name;\n</code></pre>\n</li>\n</ul>\n<h3 id=\"LocalVariableTable\">LocalVariableTable</h3>\n<ul>\n<li>本地变量，一般的类不会出现</li>\n</ul>\n<h1 id=\"字节码增强\">字节码增强</h1>\n<p>下次接着写.jpg</p>\n<script src=\"https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js\"></script><script>if (typeof lightGallery !== 'undefined') {\n        var options = {\n            selector: '.gallery-item'\n        };\n        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);\n        }</script>","categories":[{"name":"Java","path":"api/categories/Java.json"}],"tags":[]}