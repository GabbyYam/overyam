{"title":"Tree-Easy","slug":"Tree-Easy","date":"2020-02-26T15:16:54.000Z","updated":"2020-02-27T03:25:46.200Z","comments":true,"path":"api/articles/Tree-Easy.json","excerpt":"Abstract： 更新部分Easy难度 Tree相关题解","covers":["image-20200226235645269.png","image-20200226235710713.png","image-20200226235849611.png","image-20200226235908321.png","image-20200226235927904.png"],"content":"<link rel=\"stylesheet\" type=\"text/css\" href=\"https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css\"><div class=\".article-gallery\" <p><strong>Abstract：</strong> 更新部分<code>Easy</code>难度 <code>Tree</code>相关题解<p></p>\n<a id=\"more\"></a>\n<h1 id=\"965-Univalued-Binary-Tree\"><a href=\"https://leetcode-cn.com/problems/univalued-binary-tree/\" target=\"_blank\" rel=\"noopener\">965. Univalued Binary Tree</a></h1>\n<p><a href=\"Tree-Easy/image-20200226235645269.png\" title=\"image-20200226235645269\" class=\"gallery-item\"><img src=\"image-20200226235645269.png\" alt=\"image-20200226235645269\"></a></p>\n<p class=\"code-caption\" data-lang=\"java\" data-line_number=\"frontend\" data-trim_indent=\"backend\" data-label_position=\"outer\" data-labels_left=\"Code\" data-labels_right=\":\" data-labels_copy=\"Copy Code\"><span class=\"code-caption-label\"></span></p>\n<pre><code class=\"language-java\">/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\n</code></pre>\n<h2 id=\"解法一：递归遍历\">解法一：递归遍历</h2>\n<p>记录根节点的值，逐一向下遍历即可</p>\n<p class=\"code-caption\" data-lang=\"java\" data-line_number=\"frontend\" data-trim_indent=\"backend\" data-label_position=\"outer\" data-labels_left=\"Code\" data-labels_right=\":\" data-labels_copy=\"Copy Code\"><span class=\"code-caption-label\"></span></p>\n<pre><code class=\"language-java\">class Solution {\n    public boolean isUnivalTree(TreeNode root) {\n        if(root==null){return true;}//注意这里要判空一次，否则root.val会报空指针\n        return isUnival(root,root.val);\n    }\n    public boolean isUnival(TreeNode root,int val){\n        if(root==null){return true;}\n        if(root.val!=val){return false;}\n        return isUnival(root.left,val) &amp;&amp; isUnival(root.right,val); //左右都true才是true\n    }\n}\n</code></pre>\n<h1 id=\"112-Path-Sum\"><a href=\"https://leetcode-cn.com/problems/path-sum/\" target=\"_blank\" rel=\"noopener\">112. Path Sum</a></h1>\n<p><a href=\"Tree-Easy/image-20200226235710713.png\" title=\"image-20200226235710713\" class=\"gallery-item\"><img src=\"image-20200226235710713.png\" alt=\"image-20200226235710713\"></a></p>\n<h2 id=\"解法一：-DFS\">解法一： DFS</h2>\n<p><mark>DFS的核心三步</mark>：</p>\n<ol>\n<li><strong>终止条件：root==null的时候返回什么？</strong></li>\n<li><strong>处理过程：对root和root.val 如何处理？</strong></li>\n<li><strong>递归条件：对左右子树如何处理？</strong></li>\n</ol>\n<p class=\"code-caption\" data-lang=\"java\" data-line_number=\"frontend\" data-trim_indent=\"backend\" data-label_position=\"outer\" data-labels_left=\"Code\" data-labels_right=\":\" data-labels_copy=\"Copy Code\"><span class=\"code-caption-label\"></span></p>\n<pre><code class=\"language-java\">class Solution {\n    public boolean hasPathSum(TreeNode root, int sum) {\n        if(root==null){return false;}  //为空时返回false,考虑空树和空子树的情况可以得到这个结论\n        sum-=root.val; //减去当前val\n        if(root.left==null &amp;&amp; root.right==null){ //为叶子节点时，要判断是不是满足条件\n            if(sum==0){return true;}\n            else return false;\n        }\n        return hasPathSum(root.left,sum) || hasPathSum(root.right,sum); \n        //左右子树一方满足即可\n    }\n}\n</code></pre>\n<h1 id=\"100-Same-Tree\"><a href=\"https://leetcode-cn.com/problems/same-tree/\" target=\"_blank\" rel=\"noopener\">100. Same Tree</a></h1>\n<p><a href=\"Tree-Easy/image-20200226235849611.png\" title=\"image-20200226235849611\" class=\"gallery-item\"><img src=\"image-20200226235849611.png\" alt=\"image-20200226235849611\"></a></p>\n<h2 id=\"解法一：递归法\">解法一：递归法</h2>\n<ol>\n<li><strong>判空</strong>，分两种情况，两者都为空和只有一者为空</li>\n<li><strong>比值</strong>，对比值是否相等</li>\n<li><strong>递归</strong>，递归左右子树的结果，取**&amp;&amp;**</li>\n</ol>\n<p class=\"code-caption\" data-lang=\"java\" data-line_number=\"frontend\" data-trim_indent=\"backend\" data-label_position=\"outer\" data-labels_left=\"Code\" data-labels_right=\":\" data-labels_copy=\"Copy Code\"><span class=\"code-caption-label\"></span></p>\n<pre><code class=\"language-java\">class Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if(p==null &amp;&amp; q==null){return true;} //如果都为空，视为相等\n        if(p==null || q==null){return false;} //如果一方为空，显然是不等\n        if(p.val!=q.val){return false;} //比较val\n        return isSameTree(p.left,q.left) &amp;&amp; isSameTree(p.right,q.right); //递归左右子树\n    }\n}\n</code></pre>\n<h2 id=\"解法二：迭代法-没搞懂，以后再看\">解法二：迭代法(<mark>没搞懂，以后再看</mark>)</h2>\n<p class=\"code-caption\" data-lang=\"java\" data-line_number=\"frontend\" data-trim_indent=\"backend\" data-label_position=\"outer\" data-labels_left=\"Code\" data-labels_right=\":\" data-labels_copy=\"Copy Code\"><span class=\"code-caption-label\"></span></p>\n<pre><code class=\"language-java\">class Solution {\n\tpublic boolean check(TreeNode p,TreeNode q){\n        if(p==null &amp;&amp; q==null){return true;} //如果都为空，视为相等\n        if(p==null || q==null){return false;} //如果一方为空，显然是不等\n        if(p.val!=q.val){return false;} //比较val\n        return true;\n    }\n    \n    public boolean isSameTree(TreeNode p,TreeNode q){\n        if(!check(p,q)){return false;}\n        //下面没写完\n    }\n}\n</code></pre>\n<h1 id=\"111-Minimum-Depth-of-Binary-Tree\"><a href=\"https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/\" target=\"_blank\" rel=\"noopener\">111. Minimum Depth of Binary Tree</a></h1>\n<p><a href=\"Tree-Easy/image-20200226235908321.png\" title=\"image-20200226235908321\" class=\"gallery-item\"><img src=\"image-20200226235908321.png\" alt=\"image-20200226235908321\"></a></p>\n<h2 id=\"解法一：递归遍历-v2\">解法一：递归遍历</h2>\n<ol>\n<li>\n<p><strong>判空</strong>：空时为0</p>\n</li>\n<li>\n<p><strong>判断是否为叶子节点</strong>：如果是返回1</p>\n</li>\n<li>\n<p><strong>判断是否有一边为null</strong>：如果只有一边为null的话，应该对其忽略不计，否则会把此处错误地当做最小深度</p>\n</li>\n<li>\n<p><strong>递归</strong>：最小深度为左右子树的最小深度中更小的那者再+1</p>\n</li>\n</ol>\n<p class=\"code-caption\" data-lang=\"java\" data-line_number=\"frontend\" data-trim_indent=\"backend\" data-label_position=\"outer\" data-labels_left=\"Code\" data-labels_right=\":\" data-labels_copy=\"Copy Code\"><span class=\"code-caption-label\"></span></p>\n<pre><code class=\"language-java\">class Solution {\n    public int minDepth(TreeNode root) {\n        if(root==null){return 0;} //判空\n        if(root.left==null &amp;&amp; root.right==null){return 1;} //对叶子节点的处理\n        if(root.left==null || root.right==null){ //如果只有一方为空要忽略处理，这里用的是max的方法\n            return Math.max(1+minDepth(root.left),1+minDepth(root.right));}\n        return 1+Math.min(minDepth(root.left),minDepth(root.right)); //递归的最小值+1即为结果\n    }\n}\n</code></pre>\n<h1 id=\"257-Binary-Tree-Paths\"><a href=\"https://leetcode-cn.com/problems/binary-tree-paths/\" target=\"_blank\" rel=\"noopener\">257. Binary Tree Paths</a></h1>\n<p><a href=\"Tree-Easy/image-20200226235927904.png\" title=\"image-20200226235927904\" class=\"gallery-item\"><img src=\"image-20200226235927904.png\" alt=\"image-20200226235927904\"></a></p>\n<h2 id=\"解法一：-标准DFS\">解法一： 标准DFS</h2>\n<p>没啥可说的，标准DFS不会剁手</p>\n<p class=\"code-caption\" data-lang=\"java\" data-line_number=\"frontend\" data-trim_indent=\"backend\" data-label_position=\"outer\" data-labels_left=\"Code\" data-labels_right=\":\" data-labels_copy=\"Copy Code\"><span class=\"code-caption-label\"></span></p>\n<pre><code class=\"language-java\">class Solution {\n    public List&lt;String&gt; binaryTreePaths(TreeNode root) {\n        return TreePaths(root,&quot;&quot;,new ArrayList&lt;String&gt;());\n    }\n\n    public List&lt;String&gt; TreePaths(TreeNode root,String path,List&lt;String&gt; paths){\n        if(root!=null){ //判空，为空不加入\n            path+=root.val; //先拼val\n            if(root.left==null&amp;root.right==null){ //如果是叶子节点，那么add path\n                paths.add(path);\n            }\n            else{ //否则继续递归，拼上 '-&gt;'\n                path+=&quot;-&gt;&quot;;\n                TreePaths(root.left,path,paths);\n                TreePaths(root.right,path,paths);\n            }\n        }\n        return paths; //返回结果\n    }\n}\n</code></pre>\n</div><script src=\"https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js\"></script><script>if (typeof lightGallery !== 'undefined') {\n        var options = {\n            selector: '.gallery-item'\n        };\n        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);\n        }</script>","more":"<h1 id=\"965-Univalued-Binary-Tree\"><a href=\"https://leetcode-cn.com/problems/univalued-binary-tree/\" target=\"_blank\" rel=\"noopener\">965. Univalued Binary Tree</a></h1>\n<p><a href=\"Tree-Easy/image-20200226235645269.png\" title=\"image-20200226235645269\" class=\"gallery-item\"><img src=\"image-20200226235645269.png\" alt=\"image-20200226235645269\"></a></p>\n<p class=\"code-caption\" data-lang=\"java\" data-line_number=\"frontend\" data-trim_indent=\"backend\" data-label_position=\"outer\" data-labels_left=\"Code\" data-labels_right=\":\" data-labels_copy=\"Copy Code\"><span class=\"code-caption-label\"></span></p>\n<pre><code class=\"language-java\">/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\n</code></pre>\n<h2 id=\"解法一：递归遍历\">解法一：递归遍历</h2>\n<p>记录根节点的值，逐一向下遍历即可</p>\n<p class=\"code-caption\" data-lang=\"java\" data-line_number=\"frontend\" data-trim_indent=\"backend\" data-label_position=\"outer\" data-labels_left=\"Code\" data-labels_right=\":\" data-labels_copy=\"Copy Code\"><span class=\"code-caption-label\"></span></p>\n<pre><code class=\"language-java\">class Solution {\n    public boolean isUnivalTree(TreeNode root) {\n        if(root==null){return true;}//注意这里要判空一次，否则root.val会报空指针\n        return isUnival(root,root.val);\n    }\n    public boolean isUnival(TreeNode root,int val){\n        if(root==null){return true;}\n        if(root.val!=val){return false;}\n        return isUnival(root.left,val) &amp;&amp; isUnival(root.right,val); //左右都true才是true\n    }\n}\n</code></pre>\n<h1 id=\"112-Path-Sum\"><a href=\"https://leetcode-cn.com/problems/path-sum/\" target=\"_blank\" rel=\"noopener\">112. Path Sum</a></h1>\n<p><a href=\"Tree-Easy/image-20200226235710713.png\" title=\"image-20200226235710713\" class=\"gallery-item\"><img src=\"image-20200226235710713.png\" alt=\"image-20200226235710713\"></a></p>\n<h2 id=\"解法一：-DFS\">解法一： DFS</h2>\n<p><mark>DFS的核心三步</mark>：</p>\n<ol>\n<li><strong>终止条件：root==null的时候返回什么？</strong></li>\n<li><strong>处理过程：对root和root.val 如何处理？</strong></li>\n<li><strong>递归条件：对左右子树如何处理？</strong></li>\n</ol>\n<p class=\"code-caption\" data-lang=\"java\" data-line_number=\"frontend\" data-trim_indent=\"backend\" data-label_position=\"outer\" data-labels_left=\"Code\" data-labels_right=\":\" data-labels_copy=\"Copy Code\"><span class=\"code-caption-label\"></span></p>\n<pre><code class=\"language-java\">class Solution {\n    public boolean hasPathSum(TreeNode root, int sum) {\n        if(root==null){return false;}  //为空时返回false,考虑空树和空子树的情况可以得到这个结论\n        sum-=root.val; //减去当前val\n        if(root.left==null &amp;&amp; root.right==null){ //为叶子节点时，要判断是不是满足条件\n            if(sum==0){return true;}\n            else return false;\n        }\n        return hasPathSum(root.left,sum) || hasPathSum(root.right,sum); \n        //左右子树一方满足即可\n    }\n}\n</code></pre>\n<h1 id=\"100-Same-Tree\"><a href=\"https://leetcode-cn.com/problems/same-tree/\" target=\"_blank\" rel=\"noopener\">100. Same Tree</a></h1>\n<p><a href=\"Tree-Easy/image-20200226235849611.png\" title=\"image-20200226235849611\" class=\"gallery-item\"><img src=\"image-20200226235849611.png\" alt=\"image-20200226235849611\"></a></p>\n<h2 id=\"解法一：递归法\">解法一：递归法</h2>\n<ol>\n<li><strong>判空</strong>，分两种情况，两者都为空和只有一者为空</li>\n<li><strong>比值</strong>，对比值是否相等</li>\n<li><strong>递归</strong>，递归左右子树的结果，取**&amp;&amp;**</li>\n</ol>\n<p class=\"code-caption\" data-lang=\"java\" data-line_number=\"frontend\" data-trim_indent=\"backend\" data-label_position=\"outer\" data-labels_left=\"Code\" data-labels_right=\":\" data-labels_copy=\"Copy Code\"><span class=\"code-caption-label\"></span></p>\n<pre><code class=\"language-java\">class Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if(p==null &amp;&amp; q==null){return true;} //如果都为空，视为相等\n        if(p==null || q==null){return false;} //如果一方为空，显然是不等\n        if(p.val!=q.val){return false;} //比较val\n        return isSameTree(p.left,q.left) &amp;&amp; isSameTree(p.right,q.right); //递归左右子树\n    }\n}\n</code></pre>\n<h2 id=\"解法二：迭代法-没搞懂，以后再看\">解法二：迭代法(<mark>没搞懂，以后再看</mark>)</h2>\n<p class=\"code-caption\" data-lang=\"java\" data-line_number=\"frontend\" data-trim_indent=\"backend\" data-label_position=\"outer\" data-labels_left=\"Code\" data-labels_right=\":\" data-labels_copy=\"Copy Code\"><span class=\"code-caption-label\"></span></p>\n<pre><code class=\"language-java\">class Solution {\n\tpublic boolean check(TreeNode p,TreeNode q){\n        if(p==null &amp;&amp; q==null){return true;} //如果都为空，视为相等\n        if(p==null || q==null){return false;} //如果一方为空，显然是不等\n        if(p.val!=q.val){return false;} //比较val\n        return true;\n    }\n    \n    public boolean isSameTree(TreeNode p,TreeNode q){\n        if(!check(p,q)){return false;}\n        //下面没写完\n    }\n}\n</code></pre>\n<h1 id=\"111-Minimum-Depth-of-Binary-Tree\"><a href=\"https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/\" target=\"_blank\" rel=\"noopener\">111. Minimum Depth of Binary Tree</a></h1>\n<p><a href=\"Tree-Easy/image-20200226235908321.png\" title=\"image-20200226235908321\" class=\"gallery-item\"><img src=\"image-20200226235908321.png\" alt=\"image-20200226235908321\"></a></p>\n<h2 id=\"解法一：递归遍历-v2\">解法一：递归遍历</h2>\n<ol>\n<li>\n<p><strong>判空</strong>：空时为0</p>\n</li>\n<li>\n<p><strong>判断是否为叶子节点</strong>：如果是返回1</p>\n</li>\n<li>\n<p><strong>判断是否有一边为null</strong>：如果只有一边为null的话，应该对其忽略不计，否则会把此处错误地当做最小深度</p>\n</li>\n<li>\n<p><strong>递归</strong>：最小深度为左右子树的最小深度中更小的那者再+1</p>\n</li>\n</ol>\n<p class=\"code-caption\" data-lang=\"java\" data-line_number=\"frontend\" data-trim_indent=\"backend\" data-label_position=\"outer\" data-labels_left=\"Code\" data-labels_right=\":\" data-labels_copy=\"Copy Code\"><span class=\"code-caption-label\"></span></p>\n<pre><code class=\"language-java\">class Solution {\n    public int minDepth(TreeNode root) {\n        if(root==null){return 0;} //判空\n        if(root.left==null &amp;&amp; root.right==null){return 1;} //对叶子节点的处理\n        if(root.left==null || root.right==null){ //如果只有一方为空要忽略处理，这里用的是max的方法\n            return Math.max(1+minDepth(root.left),1+minDepth(root.right));}\n        return 1+Math.min(minDepth(root.left),minDepth(root.right)); //递归的最小值+1即为结果\n    }\n}\n</code></pre>\n<h1 id=\"257-Binary-Tree-Paths\"><a href=\"https://leetcode-cn.com/problems/binary-tree-paths/\" target=\"_blank\" rel=\"noopener\">257. Binary Tree Paths</a></h1>\n<p><a href=\"Tree-Easy/image-20200226235927904.png\" title=\"image-20200226235927904\" class=\"gallery-item\"><img src=\"image-20200226235927904.png\" alt=\"image-20200226235927904\"></a></p>\n<h2 id=\"解法一：-标准DFS\">解法一： 标准DFS</h2>\n<p>没啥可说的，标准DFS不会剁手</p>\n<p class=\"code-caption\" data-lang=\"java\" data-line_number=\"frontend\" data-trim_indent=\"backend\" data-label_position=\"outer\" data-labels_left=\"Code\" data-labels_right=\":\" data-labels_copy=\"Copy Code\"><span class=\"code-caption-label\"></span></p>\n<pre><code class=\"language-java\">class Solution {\n    public List&lt;String&gt; binaryTreePaths(TreeNode root) {\n        return TreePaths(root,&quot;&quot;,new ArrayList&lt;String&gt;());\n    }\n\n    public List&lt;String&gt; TreePaths(TreeNode root,String path,List&lt;String&gt; paths){\n        if(root!=null){ //判空，为空不加入\n            path+=root.val; //先拼val\n            if(root.left==null&amp;root.right==null){ //如果是叶子节点，那么add path\n                paths.add(path);\n            }\n            else{ //否则继续递归，拼上 '-&gt;'\n                path+=&quot;-&gt;&quot;;\n                TreePaths(root.left,path,paths);\n                TreePaths(root.right,path,paths);\n            }\n        }\n        return paths; //返回结果\n    }\n}\n</code></pre>\n<script src=\"https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js\"></script><script>if (typeof lightGallery !== 'undefined') {\n        var options = {\n            selector: '.gallery-item'\n        };\n        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);\n        }</script>","categories":[{"name":"Algorithm","path":"api/categories/Algorithm.json"}],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"}]}