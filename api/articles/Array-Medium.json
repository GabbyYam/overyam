{"title":"Array-Medium","slug":"Array-Medium","date":"2020-04-27T13:50:02.000Z","updated":"2020-05-04T08:22:00.717Z","comments":true,"path":"api/articles/Array-Medium.json","excerpt":"Abstract：leetcode 线性表相关 Medium 难度 题解合集","covers":["image-20200427215132211.png","image-20200429140647649.png","image-20200429143922947.png","image-20200430144224282.png","image-20200430144236162.png","image-20200430171033116.png","image-20200430171047297.png","image-20200430171056746.png","image-20200430235816762.png","image-20200501001955053.png","image-20200501003723728.png","image-20200501120709959.png","image-20200501120721893.png","image-20200501120732859.png","image-20200501140513629.png","image-20200504020253182.png"],"content":"<link rel=\"stylesheet\" type=\"text/css\" href=\"https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css\"><div class=\".article-gallery\" <p><strong>Abstract</strong>：leetcode 线性表相关 Medium 难度 题解合集<p></p>\n<a id=\"more\"></a>\n<h1 id=\"16-3Sum-Closest\"><a href=\"https://leetcode-cn.com/problems/3sum-closest/\" target=\"_blank\" rel=\"noopener\">16. 3Sum Closest</a></h1>\n<p><a href=\"Array-Medium/image-20200427215132211.png\" title=\"image-20200427215132211\" class=\"gallery-item\"><img src=\"image-20200427215132211.png\" alt=\"image-20200427215132211\"></a></p>\n<h2 id=\"解法一：暴力法\">解法一：暴力法</h2>\n<p>遍历所有可能的3组数，求最接近的sum</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) {\n        int min = INT32_MAX, res = min;\n        for(int i = 0; i&lt;nums.size(); i++){\n            for(int j = i + 1; j&lt;nums.size(); j++){\n                for(int k = j + 1; k&lt;nums.size(); k++){\n                    int sum = nums[i] + nums[j] + nums[k];\n                    int val = std::abs(sum - target);\n                    if(val == 0) return sum;\n                    if(val &lt; min){\n                        min = val;\n                        res = sum;\n                    }\n                }\n            }\n        }\n        return res;\n    }\n};\n</code></pre>\n<h2 id=\"解法二：排序-双指针\">解法二：排序+双指针</h2>\n<p>还记得两数之和那题是靠双指针做的，这题也可以，但是要固定一个数，而且这个数必须从小到大变化，所以先排序，然后就转换成两数之和了</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) {\n        int min = INT32_MAX, res = min;\n        std::sort(nums.begin(), nums.end());\n        for(int i = 0; i&lt;nums.size(); i++){\n            int lo = i + 1, hi = nums.size() - 1;\n            while(lo &lt; hi){\n                int sum = nums[i] + nums[lo] + nums[hi];\n                int val = std::abs(sum - target);\n                if (val &lt; min) {\n                    res = sum;\n                    min = val;\n                }\n                if(sum &lt; target) lo++;\n                else if(sum &gt; target) hi--;\n                else return res;\n            }\n        }\n        return res;\n    }\n};\n</code></pre>\n<h1 id=\"15-3Sum\"><a href=\"https://leetcode-cn.com/problems/3sum/\" target=\"_blank\" rel=\"noopener\">15. 3Sum</a></h1>\n<p><a href=\"Array-Medium/image-20200429140647649.png\" title=\"image-20200429140647649\" class=\"gallery-item\"><img src=\"image-20200429140647649.png\" alt=\"image-20200429140647649\"></a></p>\n<h2 id=\"解法一：排序-双指针\">解法一：排序 + 双指针</h2>\n<p>同上题，暴力解就不写了，这题的坑点在去重，因为要求<strong>unique triplets</strong></p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n\tvector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) {\n\t\tstd::vector&lt;vector&lt;int&gt;&gt; res;\n\t\tif (nums.size() &lt; 3) return res;\n\t\tstd::sort(nums.begin(), nums.end());\n\n\t\tfor (int i = 0; i &lt; nums.size() - 2; i++) {\n\t\t\tif (nums[i] &gt; 0) return res;\n\t\t\tif (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) continue;\n\t\t\tint lo = i + 1, hi = nums.size() - 1;\n\t\t\twhile (lo &lt; hi) {\n\t\t\t\tint sum = nums[i] + nums[lo] + nums[hi];\n\t\t\t\tif (sum == 0) {\n\t\t\t\t\tres.push_back({ nums[i], nums[lo], nums[hi] });\n\t\t\t\t\twhile (lo &lt; hi &amp;&amp; nums[lo] == nums[lo + 1]) lo++;\n\t\t\t\t\twhile (lo &lt; hi &amp;&amp; nums[hi] == nums[hi - 1]) hi--;\n\t\t\t\t\tlo++;\n\t\t\t\t\thi--;\n\t\t\t\t}\n\t\t\t\telse if (sum &gt; 0)\n\t\t\t\t\thi--;\n\t\t\t\telse\n\t\t\t\t\tlo++;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\n</code></pre>\n<h1 id=\"18-4Sum\"><a href=\"https://leetcode-cn.com/problems/4sum/\" target=\"_blank\" rel=\"noopener\">18. 4Sum</a></h1>\n<p><a href=\"Array-Medium/image-20200429143922947.png\" title=\"image-20200429143922947\" class=\"gallery-item\"><img src=\"image-20200429143922947.png\" alt=\"image-20200429143922947\"></a></p>\n<h2 id=\"解法一：同上\">解法一：同上</h2>\n<p>同上，好像只能套一层双指针的样子，复杂度依然有n^3</p>\n<p>另外由于target可以为负数，所以nums[i] &gt; target  &amp; nums[i] + nums[j] &gt; target 就 return 的好性质就没了</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n\tvector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target) {\n\t\tvector&lt;vector&lt;int&gt;&gt; res;\n\t\tif (nums.size() &lt; 4) return res;\n\t\tstd::sort(nums.begin(), nums.end());\n\n\t\tfor (int i = 0; i &lt; nums.size() - 3; i++) {\n\t\t\tif (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) continue;\n\t\t\tfor (int j = i + 1; j &lt; nums.size() - 2; j++) {\n\t\t\t\tif (j &gt; i + 1 &amp;&amp; nums[j] == nums[j - 1]) continue;\n\t\t\t\tint lo = j + 1, hi = nums.size() - 1;\n\t\t\t\twhile (lo &lt; hi) {\n\t\t\t\t\tint sum = nums[i] + nums[j] + nums[lo] + nums[hi];\n\t\t\t\t\tif (sum == target) {\n\t\t\t\t\t\tres.push_back({ nums[i],nums[j],nums[lo],nums[hi] });\n\t\t\t\t\t\twhile (lo &lt; hi &amp;&amp; nums[lo] == nums[lo + 1]) lo++;\n\t\t\t\t\t\twhile (lo &lt; hi &amp;&amp; nums[hi] == nums[hi - 1]) hi--;\n\t\t\t\t\t\tlo++;\n\t\t\t\t\t\thi--;\n\t\t\t\t\t}\n\t\t\t\t\telse if (sum &gt; target) hi--;\n\t\t\t\t\telse if (sum &lt; target) lo++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\n</code></pre>\n<h1 id=\"48-Rotate-Image\"><a href=\"https://leetcode-cn.com/problems/rotate-image/\" target=\"_blank\" rel=\"noopener\">48. Rotate Image</a></h1>\n<p><a href=\"Array-Medium/image-20200430144224282.png\" title=\"image-20200430144224282\" class=\"gallery-item\"><img src=\"image-20200430144224282.png\" alt=\"image-20200430144224282\"></a></p>\n<p><a href=\"Array-Medium/image-20200430144236162.png\" title=\"image-20200430144236162\" class=\"gallery-item\"><img src=\"image-20200430144236162.png\" alt=\"image-20200430144236162\"></a></p>\n<h2 id=\"解法一：先转置再求反\">解法一：先转置再求反</h2>\n<p>一开始以为是转置，结果发现刚好反过来，那就再求一次reverse就好了，但是直觉上就知道这样有点先降温再烧水的意味</p>\n<ul>\n<li>注意交换的时候只交换上三角</li>\n</ul>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {\n        int row = matrix.size(), col = matrix[0].size();\n        for (int i = 0; i &lt; row; i++) {\n            for (int j = i + 1; j &lt; col; j++) {\n                int tmp = matrix[i][j];\n                matrix[i][j] = matrix[j][i];\n                matrix[j][i] = tmp;\n            }\n        }\n        for (vector&lt;int&gt;&amp; v : matrix) {\n            std::reverse(v.begin(), v.end());\n        }\n    }\n};\n</code></pre>\n<h2 id=\"解法二：旋转变换\">解法二：旋转变换</h2>\n<p>反正我是没想出来，抄答案的</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {\n        int n = matrix.size();\n        for (int i = 0; i &lt; (n + 1) / 2; i++) {\n            for (int j = 0; j &lt; n / 2; j++) {\n                int temp = matrix[n - 1 - j][i];\n                matrix[n - 1 - j][i] = matrix[n - 1 - i][n - j - 1];\n                matrix[n - 1 - i][n - j - 1] = matrix[j][n - 1 - i];\n                matrix[j][n - 1 - i] = matrix[i][j];\n                matrix[i][j] = temp;\n            }\n        }\n    }\n};\n</code></pre>\n<h1 id=\"36-Valid-Sudoku\"><a href=\"https://leetcode-cn.com/problems/valid-sudoku/\" target=\"_blank\" rel=\"noopener\">36. Valid Sudoku</a></h1>\n<p><a href=\"Array-Medium/image-20200430171033116.png\" title=\"image-20200430171033116\" class=\"gallery-item\"><img src=\"image-20200430171033116.png\" alt=\"image-20200430171033116\"></a></p>\n<p><a href=\"Array-Medium/image-20200430171047297.png\" title=\"image-20200430171047297\" class=\"gallery-item\"><img src=\"image-20200430171047297.png\" alt=\"image-20200430171047297\"></a></p>\n<p><a href=\"Array-Medium/image-20200430171056746.png\" title=\"image-20200430171056746\" class=\"gallery-item\"><img src=\"image-20200430171056746.png\" alt=\"image-20200430171056746\"></a></p>\n<h2 id=\"解法一：暴力法（三次遍历）\">解法一：暴力法（三次遍历）</h2>\n<p>依次按行遍历，按列遍历，按九宫格遍历，用unordered_map记录出现的数字的次数，每轮超过一次算错</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n\tbool isValidSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) {\n\t\tunordered_map&lt;char, int&gt; map;\n\t\tfor (int i = 0; i &lt; board.size(); i++) {\n\t\t\tmap.clear();\n\t\t\tfor (int j = 0; j &lt; board[0].size(); j++) {\n\t\t\t\tint count = map[board[i][j]]++;\n\t\t\t\tif (isdigit(board[i][j]) &amp;&amp; count &gt; 0)\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i &lt; board.size(); i++) {\n\t\t\tmap.clear();\n\t\t\tfor (int j = 0; j &lt; board[0].size(); j++) {\n\t\t\t\tint count = map[board[j][i]]++;\n\t\t\t\tif (isdigit(board[j][i]) &amp;&amp; count &gt; 0)\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i &lt; 3; i++) {\n\t\t\tfor (int j = 0; j &lt; 3; j++) {\n\t\t\t\tmap.clear();\n\t\t\t\tfor (int m = i * 3; m &lt; i * 3 + 3; m++) {\n\t\t\t\t\tfor (int n = j * 3; n &lt; j * 3 + 3; n++) {\n\t\t\t\t\t\tint count = map[board[m][n]]++;\n\t\t\t\t\t\tif (isdigit(board[m][n]) &amp;&amp; count &gt; 0)\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n};\n</code></pre>\n<h2 id=\"解法二：一次遍历\">解法二：一次遍历</h2>\n<p>其实可以一次遍历，前提是要知道在哪行哪列哪个box</p>\n<p>因为只有9个数，哈希容器也可以换成bool数组</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    bool isValidSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) {\n        bool row[9][9] = { false }, col[9][9] = { false }, box[9][9] = { false };\n        for (int i = 0; i &lt; 9; i++) {\n            for (int j = 0; j &lt; 9; j++) {\n                if (board[i][j] == '.') continue;\n                int box_idx = (i / 3) * 3 + j / 3;\n                int val = board[i][j] - '1';\n                if (row[i][val] || col[j][val] || box[box_idx][val])\n                    return false;\n                row[i][val] = col[j][val] = box[box_idx][val] = true;\n            }\n        }\n        return true;\n    }\n};\n</code></pre>\n<h1 id=\"54-Spiral-Matrix\"><a href=\"https://leetcode-cn.com/problems/spiral-matrix/\" target=\"_blank\" rel=\"noopener\">54. Spiral Matrix</a></h1>\n<p><a href=\"Array-Medium/image-20200430235816762.png\" title=\"image-20200430235816762\" class=\"gallery-item\"><img src=\"image-20200430235816762.png\" alt=\"image-20200430235816762\"></a></p>\n<h2 id=\"解法一：标记访问点\">解法一：标记访问点</h2>\n<p>按顺序向右，向下，向左，向上，直到”撞墙“，需要“预判”，当下一个被访问过或要越界的时候就转向</p>\n<p>这里有点投机取巧，用INT32_MAX作标记，而且直接修改了原数组脏了数据</p>\n<p>替代方案是开另一个等大的数组来记录是否被访问过，但我懒得改了（ 就这样吧（</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {\n        if (matrix.empty()) return {};\n        int row = matrix.size(), col = matrix[0].size();\n        vector&lt;int&gt; sp = vector&lt;int&gt;(row * col);\n        int num = 0, tot = row * col, x, y;\n        sp[0] = matrix[y = 0][x = 0];\n        matrix[0][0] = INT32_MAX;\n        while (num &lt; tot - 1) {\n            while (x &lt; col - 1 &amp;&amp; INT32_MAX != matrix[y][x + 1]) { sp[++num] = matrix[y][++x]; matrix[y][x] = INT32_MAX; }\n            while (y &lt; row - 1 &amp;&amp; INT32_MAX != matrix[y + 1][x]) { sp[++num] = matrix[++y][x]; matrix[y][x] = INT32_MAX; }\n            while (x &gt; 0 &amp;&amp; INT32_MAX != matrix[y][x - 1]) { sp[++num] = matrix[y][--x]; matrix[y][x] = INT32_MAX; }\n            while (y &gt; 0 &amp;&amp; INT32_MAX != matrix[y - 1][x]) { sp[++num] = matrix[--y][x]; matrix[y][x] = INT32_MAX; }\n        }\n        return sp;\n    }\n};\n</code></pre>\n<h1 id=\"59-Spiral-Matrix-II\"><a href=\"https://leetcode-cn.com/problems/spiral-matrix-ii/\" target=\"_blank\" rel=\"noopener\">59. Spiral Matrix II</a></h1>\n<p><a href=\"Array-Medium/image-20200501001955053.png\" title=\"image-20200501001955053\" class=\"gallery-item\"><img src=\"image-20200501001955053.png\" alt=\"image-20200501001955053\"></a></p>\n<h2 id=\"解法一：紫书原题好吧\">解法一：紫书原题好吧</h2>\n<p>做法同54题 <code>Spiral Matrix</code>，比起Ⅰ甚至不需要标记访问点了，更简单了</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    vector&lt;vector&lt;int&gt;&gt; generateMatrix(int n) {\n        if(n == 0) return {};\n        int size = n * n, tot = 1, x, y;\n        vector&lt;vector&lt;int&gt;&gt; map = vector&lt;vector&lt;int&gt;&gt;(n);\n        for(vector&lt;int&gt;&amp; v : map) v = vector&lt;int&gt;(n);\n        map[x = 0][y = 0] = 1;\n        while(tot &lt; size){\n            while(x + 1 &lt; n &amp;&amp; !map[y][x+1]) map[y][++x] = ++tot;\n            while(y + 1 &lt; n &amp;&amp; !map[y+1][x]) map[++y][x] = ++tot;\n            while(x &gt; 0 &amp;&amp; !map[y][x-1]) map[y][--x] = ++tot;\n            while(y &gt; 0 &amp;&amp; !map[y-1][x]) map[--y][x] = ++tot;\n        }\n        return map;\n    }\n};\n</code></pre>\n<h1 id=\"73-Set-Matrix-Zeroes\"><a href=\"https://leetcode-cn.com/problems/set-matrix-zeroes/\" target=\"_blank\" rel=\"noopener\">73. Set Matrix Zeroes</a></h1>\n<p><a href=\"Array-Medium/image-20200501003723728.png\" title=\"image-20200501003723728\" class=\"gallery-item\"><img src=\"image-20200501003723728.png\" alt=\"image-20200501003723728\"></a></p>\n<h2 id=\"解法一：暴力法-v2\">解法一：暴力法</h2>\n<p>先遍历一次记下所有0元素的行数和列数，然后重新遍历一次把对应的行和列置零，空间复杂度O(m + n)</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    void setZeroes(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {\n        unordered_set&lt;int&gt; row, col;\n        for(int i = 0;i&lt;matrix.size();i++){\n            for(int j = 0;j&lt;matrix[0].size();j++){\n                if(matrix[i][j] == 0){\n                    row.emplace(i);\n                    col.emplace(j);\n                }\n            }\n        }\n\n        for(int i = 0;i&lt;matrix.size();i++){\n            for(int j = 0;j&lt;matrix[0].size();j++){\n                if(row.find(i) != row.end() || col.find(j) != col.end())\n                    matrix[i][j] = 0;\n            }\n        }\n    }\n};\n</code></pre>\n<h2 id=\"解法二：\">解法二：</h2>\n<h1 id=\"1424-Diagonal-Traverse-II\"><a href=\"https://leetcode-cn.com/problems/diagonal-traverse-ii/\" target=\"_blank\" rel=\"noopener\">1424. Diagonal Traverse II</a></h1>\n<p><a href=\"Array-Medium/image-20200501120709959.png\" title=\"image-20200501120709959\" class=\"gallery-item\"><img src=\"image-20200501120709959.png\" alt=\"image-20200501120709959\"></a></p>\n<p><a href=\"Array-Medium/image-20200501120721893.png\" title=\"image-20200501120721893\" class=\"gallery-item\"><img src=\"image-20200501120721893.png\" alt=\"image-20200501120721893\"></a></p>\n<p><a href=\"Array-Medium/image-20200501120732859.png\" title=\"image-20200501120732859\" class=\"gallery-item\"><img src=\"image-20200501120732859.png\" alt=\"image-20200501120732859\"></a></p>\n<h2 id=\"解法一：顺序遍历\">解法一：顺序遍历</h2>\n<p>学过初中数学都知道，直线上 x + y = c (c为常数)，依照这个性质就可以用正常的遍历顺序取到每一层反向的结果，最后再反向存入一个新的res数组就行了</p>\n<ul>\n<li>顺带一提，由于i,j的规模达到10^9，暴力法是不可行的，会超时，即使是顺序遍历也要500ms上下</li>\n</ul>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    vector&lt;int&gt; findDiagonalOrder(vector&lt;vector&lt;int&gt;&gt;&amp; nums) {\n        vector&lt;vector&lt;int&gt;&gt; map;\n        for(int i = 0;i &lt; nums.size(); i++){\n            for(int j = 0; j &lt; nums[i].size(); j++){\n                int idx = i + j;\n                if(idx &gt;= map.size()) map.push_back({});\n                map[idx].push_back(nums[i][j]);\n            }\n        }\n        vector&lt;int&gt; res;\n        for(int i = 0;i&lt;map.size();i++){\n            for(int j = map[i].size() - 1; j&gt;-1;j--){\n                res.push_back(map[i][j]);\n            }\n        }\n        return res;\n    }\n};\n</code></pre>\n<h1 id=\"56-Merge-Intervals\"><a href=\"https://leetcode-cn.com/problems/merge-intervals/\" target=\"_blank\" rel=\"noopener\">56. Merge Intervals</a></h1>\n<p><a href=\"Array-Medium/image-20200501140513629.png\" title=\"image-20200501140513629\" class=\"gallery-item\"><img src=\"image-20200501140513629.png\" alt=\"image-20200501140513629\"></a></p>\n<h2 id=\"解法一：先排序\">解法一：先排序</h2>\n<p>按左端点排序，那么判断重合就好办了</p>\n<ul>\n<li>只要下一个区间的左端点小于等于这个区间的右端点，就修改这个区间的左右端点</li>\n<li>如果不重合，就直接push下一个区间，同时指向下一个区间</li>\n</ul>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    vector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) {\n        if(intervals.size() &lt;= 1) return intervals;\n        std::sort(intervals.begin(),intervals.end(),[](vector&lt;int&gt; a, vector&lt;int&gt; b){\n            return a[0] &lt; b[0];\n        });\n        vector&lt;vector&lt;int&gt;&gt; res;\n        int i = 0, j = 1;\n        res.push_back(intervals[0]);\n        while(j &lt; intervals.size()) {\n            if(intervals[j][0] &lt;= res[i][1]){\n                res[i][0] = std::min(res[i][0], intervals[j][0]);\n                res[i][1] = std::max(res[i][1], intervals[j][1]);\n                j++;\n            }\n            else{\n                res.push_back(intervals[j]);\n                i++;\n            }   \n        }\n        return res;\n    }\n};\n</code></pre>\n<p>原来vector可以默认按第一位排序。。删掉lambda比较函数后，快了不少。。</p>\n<pre><code class=\"language-cpp\">std::sort(intervals.begin(),intervals.end());\n</code></pre>\n<h1 id=\"137-Single-Number-II\"><a href=\"https://leetcode-cn.com/problems/single-number-ii/\" target=\"_blank\" rel=\"noopener\">137. Single Number II</a></h1>\n<p><a href=\"Array-Medium/image-20200504020253182.png\" title=\"image-20200504020253182\" class=\"gallery-item\"><img src=\"image-20200504020253182.png\" alt=\"image-20200504020253182\"></a></p>\n<h2 id=\"解法一：unordered-map\">解法一：unordered_map</h2>\n<p>最简单的办法显然是用map统计出现的次数，再找到出现次数不等于3的那个</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    int singleNumber(vector&lt;int&gt;&amp; nums) {\n        unordered_map&lt;int, int&gt; map;\n        for(int i : nums) map[i]++;\n        for(auto i : map)\n            if(i.second != 3) \n                return i.first;\n        return -1;\n    }\n};\n</code></pre>\n<h2 id=\"解法二：位操作\">解法二：位操作</h2>\n<ul>\n<li>基本思路是一个数 异或（^） 自己 奇数次时不为零，反之为零</li>\n<li>统计一次和三次，都是奇数怎么办，维护两个掩码来做</li>\n<li></li>\n</ul>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    int singleNumber(vector&lt;int&gt;&amp; nums) {\n        int once = 0, twice = 0;\n        for(int i : nums){\n            once  = ~twice &amp; (once  ^ i);\n            twice = ~once  &amp; (twice ^ i);\n        }\n        return once;\n    }\n};\n</code></pre>\n</div><script src=\"https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js\"></script><script>if (typeof lightGallery !== 'undefined') {\n        var options = {\n            selector: '.gallery-item'\n        };\n        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);\n        }</script>","more":"<h1 id=\"16-3Sum-Closest\"><a href=\"https://leetcode-cn.com/problems/3sum-closest/\" target=\"_blank\" rel=\"noopener\">16. 3Sum Closest</a></h1>\n<p><a href=\"Array-Medium/image-20200427215132211.png\" title=\"image-20200427215132211\" class=\"gallery-item\"><img src=\"image-20200427215132211.png\" alt=\"image-20200427215132211\"></a></p>\n<h2 id=\"解法一：暴力法\">解法一：暴力法</h2>\n<p>遍历所有可能的3组数，求最接近的sum</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) {\n        int min = INT32_MAX, res = min;\n        for(int i = 0; i&lt;nums.size(); i++){\n            for(int j = i + 1; j&lt;nums.size(); j++){\n                for(int k = j + 1; k&lt;nums.size(); k++){\n                    int sum = nums[i] + nums[j] + nums[k];\n                    int val = std::abs(sum - target);\n                    if(val == 0) return sum;\n                    if(val &lt; min){\n                        min = val;\n                        res = sum;\n                    }\n                }\n            }\n        }\n        return res;\n    }\n};\n</code></pre>\n<h2 id=\"解法二：排序-双指针\">解法二：排序+双指针</h2>\n<p>还记得两数之和那题是靠双指针做的，这题也可以，但是要固定一个数，而且这个数必须从小到大变化，所以先排序，然后就转换成两数之和了</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) {\n        int min = INT32_MAX, res = min;\n        std::sort(nums.begin(), nums.end());\n        for(int i = 0; i&lt;nums.size(); i++){\n            int lo = i + 1, hi = nums.size() - 1;\n            while(lo &lt; hi){\n                int sum = nums[i] + nums[lo] + nums[hi];\n                int val = std::abs(sum - target);\n                if (val &lt; min) {\n                    res = sum;\n                    min = val;\n                }\n                if(sum &lt; target) lo++;\n                else if(sum &gt; target) hi--;\n                else return res;\n            }\n        }\n        return res;\n    }\n};\n</code></pre>\n<h1 id=\"15-3Sum\"><a href=\"https://leetcode-cn.com/problems/3sum/\" target=\"_blank\" rel=\"noopener\">15. 3Sum</a></h1>\n<p><a href=\"Array-Medium/image-20200429140647649.png\" title=\"image-20200429140647649\" class=\"gallery-item\"><img src=\"image-20200429140647649.png\" alt=\"image-20200429140647649\"></a></p>\n<h2 id=\"解法一：排序-双指针\">解法一：排序 + 双指针</h2>\n<p>同上题，暴力解就不写了，这题的坑点在去重，因为要求<strong>unique triplets</strong></p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n\tvector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) {\n\t\tstd::vector&lt;vector&lt;int&gt;&gt; res;\n\t\tif (nums.size() &lt; 3) return res;\n\t\tstd::sort(nums.begin(), nums.end());\n\n\t\tfor (int i = 0; i &lt; nums.size() - 2; i++) {\n\t\t\tif (nums[i] &gt; 0) return res;\n\t\t\tif (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) continue;\n\t\t\tint lo = i + 1, hi = nums.size() - 1;\n\t\t\twhile (lo &lt; hi) {\n\t\t\t\tint sum = nums[i] + nums[lo] + nums[hi];\n\t\t\t\tif (sum == 0) {\n\t\t\t\t\tres.push_back({ nums[i], nums[lo], nums[hi] });\n\t\t\t\t\twhile (lo &lt; hi &amp;&amp; nums[lo] == nums[lo + 1]) lo++;\n\t\t\t\t\twhile (lo &lt; hi &amp;&amp; nums[hi] == nums[hi - 1]) hi--;\n\t\t\t\t\tlo++;\n\t\t\t\t\thi--;\n\t\t\t\t}\n\t\t\t\telse if (sum &gt; 0)\n\t\t\t\t\thi--;\n\t\t\t\telse\n\t\t\t\t\tlo++;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\n</code></pre>\n<h1 id=\"18-4Sum\"><a href=\"https://leetcode-cn.com/problems/4sum/\" target=\"_blank\" rel=\"noopener\">18. 4Sum</a></h1>\n<p><a href=\"Array-Medium/image-20200429143922947.png\" title=\"image-20200429143922947\" class=\"gallery-item\"><img src=\"image-20200429143922947.png\" alt=\"image-20200429143922947\"></a></p>\n<h2 id=\"解法一：同上\">解法一：同上</h2>\n<p>同上，好像只能套一层双指针的样子，复杂度依然有n^3</p>\n<p>另外由于target可以为负数，所以nums[i] &gt; target  &amp; nums[i] + nums[j] &gt; target 就 return 的好性质就没了</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n\tvector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target) {\n\t\tvector&lt;vector&lt;int&gt;&gt; res;\n\t\tif (nums.size() &lt; 4) return res;\n\t\tstd::sort(nums.begin(), nums.end());\n\n\t\tfor (int i = 0; i &lt; nums.size() - 3; i++) {\n\t\t\tif (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) continue;\n\t\t\tfor (int j = i + 1; j &lt; nums.size() - 2; j++) {\n\t\t\t\tif (j &gt; i + 1 &amp;&amp; nums[j] == nums[j - 1]) continue;\n\t\t\t\tint lo = j + 1, hi = nums.size() - 1;\n\t\t\t\twhile (lo &lt; hi) {\n\t\t\t\t\tint sum = nums[i] + nums[j] + nums[lo] + nums[hi];\n\t\t\t\t\tif (sum == target) {\n\t\t\t\t\t\tres.push_back({ nums[i],nums[j],nums[lo],nums[hi] });\n\t\t\t\t\t\twhile (lo &lt; hi &amp;&amp; nums[lo] == nums[lo + 1]) lo++;\n\t\t\t\t\t\twhile (lo &lt; hi &amp;&amp; nums[hi] == nums[hi - 1]) hi--;\n\t\t\t\t\t\tlo++;\n\t\t\t\t\t\thi--;\n\t\t\t\t\t}\n\t\t\t\t\telse if (sum &gt; target) hi--;\n\t\t\t\t\telse if (sum &lt; target) lo++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\n</code></pre>\n<h1 id=\"48-Rotate-Image\"><a href=\"https://leetcode-cn.com/problems/rotate-image/\" target=\"_blank\" rel=\"noopener\">48. Rotate Image</a></h1>\n<p><a href=\"Array-Medium/image-20200430144224282.png\" title=\"image-20200430144224282\" class=\"gallery-item\"><img src=\"image-20200430144224282.png\" alt=\"image-20200430144224282\"></a></p>\n<p><a href=\"Array-Medium/image-20200430144236162.png\" title=\"image-20200430144236162\" class=\"gallery-item\"><img src=\"image-20200430144236162.png\" alt=\"image-20200430144236162\"></a></p>\n<h2 id=\"解法一：先转置再求反\">解法一：先转置再求反</h2>\n<p>一开始以为是转置，结果发现刚好反过来，那就再求一次reverse就好了，但是直觉上就知道这样有点先降温再烧水的意味</p>\n<ul>\n<li>注意交换的时候只交换上三角</li>\n</ul>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {\n        int row = matrix.size(), col = matrix[0].size();\n        for (int i = 0; i &lt; row; i++) {\n            for (int j = i + 1; j &lt; col; j++) {\n                int tmp = matrix[i][j];\n                matrix[i][j] = matrix[j][i];\n                matrix[j][i] = tmp;\n            }\n        }\n        for (vector&lt;int&gt;&amp; v : matrix) {\n            std::reverse(v.begin(), v.end());\n        }\n    }\n};\n</code></pre>\n<h2 id=\"解法二：旋转变换\">解法二：旋转变换</h2>\n<p>反正我是没想出来，抄答案的</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {\n        int n = matrix.size();\n        for (int i = 0; i &lt; (n + 1) / 2; i++) {\n            for (int j = 0; j &lt; n / 2; j++) {\n                int temp = matrix[n - 1 - j][i];\n                matrix[n - 1 - j][i] = matrix[n - 1 - i][n - j - 1];\n                matrix[n - 1 - i][n - j - 1] = matrix[j][n - 1 - i];\n                matrix[j][n - 1 - i] = matrix[i][j];\n                matrix[i][j] = temp;\n            }\n        }\n    }\n};\n</code></pre>\n<h1 id=\"36-Valid-Sudoku\"><a href=\"https://leetcode-cn.com/problems/valid-sudoku/\" target=\"_blank\" rel=\"noopener\">36. Valid Sudoku</a></h1>\n<p><a href=\"Array-Medium/image-20200430171033116.png\" title=\"image-20200430171033116\" class=\"gallery-item\"><img src=\"image-20200430171033116.png\" alt=\"image-20200430171033116\"></a></p>\n<p><a href=\"Array-Medium/image-20200430171047297.png\" title=\"image-20200430171047297\" class=\"gallery-item\"><img src=\"image-20200430171047297.png\" alt=\"image-20200430171047297\"></a></p>\n<p><a href=\"Array-Medium/image-20200430171056746.png\" title=\"image-20200430171056746\" class=\"gallery-item\"><img src=\"image-20200430171056746.png\" alt=\"image-20200430171056746\"></a></p>\n<h2 id=\"解法一：暴力法（三次遍历）\">解法一：暴力法（三次遍历）</h2>\n<p>依次按行遍历，按列遍历，按九宫格遍历，用unordered_map记录出现的数字的次数，每轮超过一次算错</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n\tbool isValidSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) {\n\t\tunordered_map&lt;char, int&gt; map;\n\t\tfor (int i = 0; i &lt; board.size(); i++) {\n\t\t\tmap.clear();\n\t\t\tfor (int j = 0; j &lt; board[0].size(); j++) {\n\t\t\t\tint count = map[board[i][j]]++;\n\t\t\t\tif (isdigit(board[i][j]) &amp;&amp; count &gt; 0)\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i &lt; board.size(); i++) {\n\t\t\tmap.clear();\n\t\t\tfor (int j = 0; j &lt; board[0].size(); j++) {\n\t\t\t\tint count = map[board[j][i]]++;\n\t\t\t\tif (isdigit(board[j][i]) &amp;&amp; count &gt; 0)\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i &lt; 3; i++) {\n\t\t\tfor (int j = 0; j &lt; 3; j++) {\n\t\t\t\tmap.clear();\n\t\t\t\tfor (int m = i * 3; m &lt; i * 3 + 3; m++) {\n\t\t\t\t\tfor (int n = j * 3; n &lt; j * 3 + 3; n++) {\n\t\t\t\t\t\tint count = map[board[m][n]]++;\n\t\t\t\t\t\tif (isdigit(board[m][n]) &amp;&amp; count &gt; 0)\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n};\n</code></pre>\n<h2 id=\"解法二：一次遍历\">解法二：一次遍历</h2>\n<p>其实可以一次遍历，前提是要知道在哪行哪列哪个box</p>\n<p>因为只有9个数，哈希容器也可以换成bool数组</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    bool isValidSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) {\n        bool row[9][9] = { false }, col[9][9] = { false }, box[9][9] = { false };\n        for (int i = 0; i &lt; 9; i++) {\n            for (int j = 0; j &lt; 9; j++) {\n                if (board[i][j] == '.') continue;\n                int box_idx = (i / 3) * 3 + j / 3;\n                int val = board[i][j] - '1';\n                if (row[i][val] || col[j][val] || box[box_idx][val])\n                    return false;\n                row[i][val] = col[j][val] = box[box_idx][val] = true;\n            }\n        }\n        return true;\n    }\n};\n</code></pre>\n<h1 id=\"54-Spiral-Matrix\"><a href=\"https://leetcode-cn.com/problems/spiral-matrix/\" target=\"_blank\" rel=\"noopener\">54. Spiral Matrix</a></h1>\n<p><a href=\"Array-Medium/image-20200430235816762.png\" title=\"image-20200430235816762\" class=\"gallery-item\"><img src=\"image-20200430235816762.png\" alt=\"image-20200430235816762\"></a></p>\n<h2 id=\"解法一：标记访问点\">解法一：标记访问点</h2>\n<p>按顺序向右，向下，向左，向上，直到”撞墙“，需要“预判”，当下一个被访问过或要越界的时候就转向</p>\n<p>这里有点投机取巧，用INT32_MAX作标记，而且直接修改了原数组脏了数据</p>\n<p>替代方案是开另一个等大的数组来记录是否被访问过，但我懒得改了（ 就这样吧（</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {\n        if (matrix.empty()) return {};\n        int row = matrix.size(), col = matrix[0].size();\n        vector&lt;int&gt; sp = vector&lt;int&gt;(row * col);\n        int num = 0, tot = row * col, x, y;\n        sp[0] = matrix[y = 0][x = 0];\n        matrix[0][0] = INT32_MAX;\n        while (num &lt; tot - 1) {\n            while (x &lt; col - 1 &amp;&amp; INT32_MAX != matrix[y][x + 1]) { sp[++num] = matrix[y][++x]; matrix[y][x] = INT32_MAX; }\n            while (y &lt; row - 1 &amp;&amp; INT32_MAX != matrix[y + 1][x]) { sp[++num] = matrix[++y][x]; matrix[y][x] = INT32_MAX; }\n            while (x &gt; 0 &amp;&amp; INT32_MAX != matrix[y][x - 1]) { sp[++num] = matrix[y][--x]; matrix[y][x] = INT32_MAX; }\n            while (y &gt; 0 &amp;&amp; INT32_MAX != matrix[y - 1][x]) { sp[++num] = matrix[--y][x]; matrix[y][x] = INT32_MAX; }\n        }\n        return sp;\n    }\n};\n</code></pre>\n<h1 id=\"59-Spiral-Matrix-II\"><a href=\"https://leetcode-cn.com/problems/spiral-matrix-ii/\" target=\"_blank\" rel=\"noopener\">59. Spiral Matrix II</a></h1>\n<p><a href=\"Array-Medium/image-20200501001955053.png\" title=\"image-20200501001955053\" class=\"gallery-item\"><img src=\"image-20200501001955053.png\" alt=\"image-20200501001955053\"></a></p>\n<h2 id=\"解法一：紫书原题好吧\">解法一：紫书原题好吧</h2>\n<p>做法同54题 <code>Spiral Matrix</code>，比起Ⅰ甚至不需要标记访问点了，更简单了</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    vector&lt;vector&lt;int&gt;&gt; generateMatrix(int n) {\n        if(n == 0) return {};\n        int size = n * n, tot = 1, x, y;\n        vector&lt;vector&lt;int&gt;&gt; map = vector&lt;vector&lt;int&gt;&gt;(n);\n        for(vector&lt;int&gt;&amp; v : map) v = vector&lt;int&gt;(n);\n        map[x = 0][y = 0] = 1;\n        while(tot &lt; size){\n            while(x + 1 &lt; n &amp;&amp; !map[y][x+1]) map[y][++x] = ++tot;\n            while(y + 1 &lt; n &amp;&amp; !map[y+1][x]) map[++y][x] = ++tot;\n            while(x &gt; 0 &amp;&amp; !map[y][x-1]) map[y][--x] = ++tot;\n            while(y &gt; 0 &amp;&amp; !map[y-1][x]) map[--y][x] = ++tot;\n        }\n        return map;\n    }\n};\n</code></pre>\n<h1 id=\"73-Set-Matrix-Zeroes\"><a href=\"https://leetcode-cn.com/problems/set-matrix-zeroes/\" target=\"_blank\" rel=\"noopener\">73. Set Matrix Zeroes</a></h1>\n<p><a href=\"Array-Medium/image-20200501003723728.png\" title=\"image-20200501003723728\" class=\"gallery-item\"><img src=\"image-20200501003723728.png\" alt=\"image-20200501003723728\"></a></p>\n<h2 id=\"解法一：暴力法-v2\">解法一：暴力法</h2>\n<p>先遍历一次记下所有0元素的行数和列数，然后重新遍历一次把对应的行和列置零，空间复杂度O(m + n)</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    void setZeroes(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {\n        unordered_set&lt;int&gt; row, col;\n        for(int i = 0;i&lt;matrix.size();i++){\n            for(int j = 0;j&lt;matrix[0].size();j++){\n                if(matrix[i][j] == 0){\n                    row.emplace(i);\n                    col.emplace(j);\n                }\n            }\n        }\n\n        for(int i = 0;i&lt;matrix.size();i++){\n            for(int j = 0;j&lt;matrix[0].size();j++){\n                if(row.find(i) != row.end() || col.find(j) != col.end())\n                    matrix[i][j] = 0;\n            }\n        }\n    }\n};\n</code></pre>\n<h2 id=\"解法二：\">解法二：</h2>\n<h1 id=\"1424-Diagonal-Traverse-II\"><a href=\"https://leetcode-cn.com/problems/diagonal-traverse-ii/\" target=\"_blank\" rel=\"noopener\">1424. Diagonal Traverse II</a></h1>\n<p><a href=\"Array-Medium/image-20200501120709959.png\" title=\"image-20200501120709959\" class=\"gallery-item\"><img src=\"image-20200501120709959.png\" alt=\"image-20200501120709959\"></a></p>\n<p><a href=\"Array-Medium/image-20200501120721893.png\" title=\"image-20200501120721893\" class=\"gallery-item\"><img src=\"image-20200501120721893.png\" alt=\"image-20200501120721893\"></a></p>\n<p><a href=\"Array-Medium/image-20200501120732859.png\" title=\"image-20200501120732859\" class=\"gallery-item\"><img src=\"image-20200501120732859.png\" alt=\"image-20200501120732859\"></a></p>\n<h2 id=\"解法一：顺序遍历\">解法一：顺序遍历</h2>\n<p>学过初中数学都知道，直线上 x + y = c (c为常数)，依照这个性质就可以用正常的遍历顺序取到每一层反向的结果，最后再反向存入一个新的res数组就行了</p>\n<ul>\n<li>顺带一提，由于i,j的规模达到10^9，暴力法是不可行的，会超时，即使是顺序遍历也要500ms上下</li>\n</ul>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    vector&lt;int&gt; findDiagonalOrder(vector&lt;vector&lt;int&gt;&gt;&amp; nums) {\n        vector&lt;vector&lt;int&gt;&gt; map;\n        for(int i = 0;i &lt; nums.size(); i++){\n            for(int j = 0; j &lt; nums[i].size(); j++){\n                int idx = i + j;\n                if(idx &gt;= map.size()) map.push_back({});\n                map[idx].push_back(nums[i][j]);\n            }\n        }\n        vector&lt;int&gt; res;\n        for(int i = 0;i&lt;map.size();i++){\n            for(int j = map[i].size() - 1; j&gt;-1;j--){\n                res.push_back(map[i][j]);\n            }\n        }\n        return res;\n    }\n};\n</code></pre>\n<h1 id=\"56-Merge-Intervals\"><a href=\"https://leetcode-cn.com/problems/merge-intervals/\" target=\"_blank\" rel=\"noopener\">56. Merge Intervals</a></h1>\n<p><a href=\"Array-Medium/image-20200501140513629.png\" title=\"image-20200501140513629\" class=\"gallery-item\"><img src=\"image-20200501140513629.png\" alt=\"image-20200501140513629\"></a></p>\n<h2 id=\"解法一：先排序\">解法一：先排序</h2>\n<p>按左端点排序，那么判断重合就好办了</p>\n<ul>\n<li>只要下一个区间的左端点小于等于这个区间的右端点，就修改这个区间的左右端点</li>\n<li>如果不重合，就直接push下一个区间，同时指向下一个区间</li>\n</ul>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    vector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) {\n        if(intervals.size() &lt;= 1) return intervals;\n        std::sort(intervals.begin(),intervals.end(),[](vector&lt;int&gt; a, vector&lt;int&gt; b){\n            return a[0] &lt; b[0];\n        });\n        vector&lt;vector&lt;int&gt;&gt; res;\n        int i = 0, j = 1;\n        res.push_back(intervals[0]);\n        while(j &lt; intervals.size()) {\n            if(intervals[j][0] &lt;= res[i][1]){\n                res[i][0] = std::min(res[i][0], intervals[j][0]);\n                res[i][1] = std::max(res[i][1], intervals[j][1]);\n                j++;\n            }\n            else{\n                res.push_back(intervals[j]);\n                i++;\n            }   \n        }\n        return res;\n    }\n};\n</code></pre>\n<p>原来vector可以默认按第一位排序。。删掉lambda比较函数后，快了不少。。</p>\n<pre><code class=\"language-cpp\">std::sort(intervals.begin(),intervals.end());\n</code></pre>\n<h1 id=\"137-Single-Number-II\"><a href=\"https://leetcode-cn.com/problems/single-number-ii/\" target=\"_blank\" rel=\"noopener\">137. Single Number II</a></h1>\n<p><a href=\"Array-Medium/image-20200504020253182.png\" title=\"image-20200504020253182\" class=\"gallery-item\"><img src=\"image-20200504020253182.png\" alt=\"image-20200504020253182\"></a></p>\n<h2 id=\"解法一：unordered-map\">解法一：unordered_map</h2>\n<p>最简单的办法显然是用map统计出现的次数，再找到出现次数不等于3的那个</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    int singleNumber(vector&lt;int&gt;&amp; nums) {\n        unordered_map&lt;int, int&gt; map;\n        for(int i : nums) map[i]++;\n        for(auto i : map)\n            if(i.second != 3) \n                return i.first;\n        return -1;\n    }\n};\n</code></pre>\n<h2 id=\"解法二：位操作\">解法二：位操作</h2>\n<ul>\n<li>基本思路是一个数 异或（^） 自己 奇数次时不为零，反之为零</li>\n<li>统计一次和三次，都是奇数怎么办，维护两个掩码来做</li>\n<li></li>\n</ul>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    int singleNumber(vector&lt;int&gt;&amp; nums) {\n        int once = 0, twice = 0;\n        for(int i : nums){\n            once  = ~twice &amp; (once  ^ i);\n            twice = ~once  &amp; (twice ^ i);\n        }\n        return once;\n    }\n};\n</code></pre>\n<script src=\"https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js\"></script><script>if (typeof lightGallery !== 'undefined') {\n        var options = {\n            selector: '.gallery-item'\n        };\n        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);\n        }</script>","categories":[{"name":"Algorithm","path":"api/categories/Algorithm.json"}],"tags":[{"name":"Leetcode","path":"api/tags/Leetcode.json"}]}