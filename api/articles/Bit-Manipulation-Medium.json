{"title":"Bit-Manipulation Medium","slug":"Bit-Manipulation-Medium","date":"2020-05-13T06:29:25.000Z","updated":"2020-05-23T13:56:51.992Z","comments":true,"path":"api/articles/Bit-Manipulation-Medium.json","excerpt":"**Abstract：**位操作 中等难度合集","covers":["image-20200513143056421.png","image-20200517200551507.png","image-20200504020253182.png"],"content":"<link rel=\"stylesheet\" type=\"text/css\" href=\"https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css\"><div class=\".article-gallery\" <p>**Abstract：**位操作 中等难度合集<p></p>\n<a id=\"more\"></a>\n<h1 id=\"29-Divide-Two-Integers\"><a href=\"https://leetcode-cn.com/problems/divide-two-integers/\" target=\"_blank\" rel=\"noopener\">29. Divide Two Integers</a></h1>\n<p><a href=\"Bit-Manipulation-Medium/image-20200513143056421.png\" title=\"image-20200513143056421\" class=\"gallery-item\"><img src=\"image-20200513143056421.png\" alt=\"image-20200513143056421\"></a></p>\n<h2 id=\"解法一：递归\">解法一：递归</h2>\n<p>不会处理溢出，先贴个投机取巧的方法，虽然也是和题解学的/瘫倒/</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    int divide(int dividend, int divisor) {\n        if(dividend == 0) return 0;\n        if(divisor ==  1) return dividend;\n        if(divisor == -1) {\n            return dividend == INT32_MIN ? INT32_MAX : -dividend;\n        }\n        long a = dividend, b = divisor;\n        bool isNeg = (dividend ^ divisor) &gt;&gt; 31;\n        long res = div(abs(a), abs(b));\n        if(res &gt; INT32_MAX) return INT32_MAX;\n        return isNeg ? -res : res;\n    }\n\n    int div(long a, long b) {\n        if (a &lt; b) return 0;\n        long cnt = 1, t = b;\n        while((t &lt;&lt; 1) &lt;= a) {\n            cnt &lt;&lt;= 1;\n            t &lt;&lt;= 1;\n        }\n        return cnt + div(a - t, b);\n    }\n};\n\n</code></pre>\n<h1 id=\"260-Single-Number-III\"><a href=\"https://leetcode-cn.com/problems/single-number-iii/\" target=\"_blank\" rel=\"noopener\">260. Single Number III</a></h1>\n<p><a href=\"Bit-Manipulation-Medium/image-20200517200551507.png\" title=\"image-20200517200551507\" class=\"gallery-item\"><img src=\"image-20200517200551507.png\" alt=\"image-20200517200551507\"></a></p>\n<h2 id=\"解法一：掩码\">解法一：掩码</h2>\n<ul>\n<li>\n<p>先用一个掩码异或所有数组元素，剩下的将会是出现奇数次的数</p>\n</li>\n<li>\n<p>mask &amp; -mask，取得x， y中最右边的1，这个1只能来自x，y其中之一，可以用来筛掉其中一个</p>\n</li>\n<li>\n<p>注意位运算的优先级很低，一定要加括号</p>\n</li>\n</ul>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    vector&lt;int&gt; singleNumber(vector&lt;int&gt;&amp; nums) {\n        int mask = 0;\n        vector&lt;int&gt; res;\n        for(int i : nums) mask ^= i;\n\n        int t = mask &amp; -mask, tmask = 0;\n        for(int i : nums) if((i &amp; t) != 0) tmask ^= i;\n        return {tmask, tmask ^ mask};\n    }\n};\n</code></pre>\n<h1 id=\"137-Single-Number-II\"><a href=\"https://leetcode-cn.com/problems/single-number-ii/\" target=\"_blank\" rel=\"noopener\">137. Single Number II</a></h1>\n<p><a href=\"Bit-Manipulation-Medium/image-20200504020253182.png\" title=\"image-20200504020253182\" class=\"gallery-item\"><img src=\"image-20200504020253182.png\" alt=\"image-20200504020253182\"></a></p>\n<h2 id=\"解法一：unordered-map\">解法一：unordered_map</h2>\n<p>最简单的办法显然是用map统计出现的次数，再找到出现次数不等于3的那个</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    int singleNumber(vector&lt;int&gt;&amp; nums) {\n        unordered_map&lt;int, int&gt; map;\n        for(int i : nums) map[i]++;\n        for(auto i : map)\n            if(i.second != 3) \n                return i.first;\n        return -1;\n    }\n};\n</code></pre>\n<h2 id=\"解法二：逐位计数\">解法二：逐位计数</h2>\n<p>对每一位出现1的次数计数，时间复杂度 $O(32 * n) = O(n)$, 空间复杂度降到了$O(1)$</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    int singleNumber(vector&lt;int&gt;&amp; nums) {\n        int res = 0;\n        for(int i = 0; i &lt; 32; i++) {\n            int idx = 1 &lt;&lt; i, cnt = 0;\n            for(int v : nums) {\n                if((v &amp; idx) != 0)\n                    cnt++;\n            }\n            if(cnt % 3 == 1)\n                res |= idx;\n        }\n        return res;\n    }\n};\n</code></pre>\n<h2 id=\"解法三：有限状态自动机\">解法三：有限状态自动机</h2>\n<p>用两个位来记录出现次数，一共有三种状态也就是</p>\n<table>\n<thead>\n<tr>\n<th>a</th>\n<th>b</th>\n<th>代表出现的次数</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n</tr>\n<tr>\n<td>0</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>1</td>\n<td>1</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>\n<p>当出现次数超过2时，则重新变回1状态</p>\n</li>\n<li>\n<p>如果画出状态转移表</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>a</th>\n<th>b</th>\n<th>c</th>\n<th>目标状态</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>00</td>\n</tr>\n<tr>\n<td>0</td>\n<td>1</td>\n<td>0</td>\n<td>01</td>\n</tr>\n<tr>\n<td>1</td>\n<td>0</td>\n<td>0</td>\n<td>10</td>\n</tr>\n<tr>\n<td>0</td>\n<td>0</td>\n<td>1</td>\n<td>01</td>\n</tr>\n<tr>\n<td>0</td>\n<td>1</td>\n<td>1</td>\n<td>10</td>\n</tr>\n<tr>\n<td>1</td>\n<td>0</td>\n<td>1</td>\n<td>00</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>\n<p>可以得出转移表达式为</p>\n<pre><code class=\"language-cpp\">b = !a &amp; (b ^ c);\na = !b &amp; (a ^ c);\n</code></pre>\n</li>\n<li>\n<p>最后32位二进制数中剩下非0位即为出现次数为 $3n + 1$ 的位</p>\n</li>\n</ul>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    int singleNumber(vector&lt;int&gt;&amp; nums) {\n        int a = 0, b = 0;\n        for(int i : nums) {\n            b = ~a &amp; (i ^ b);\n            a = ~b &amp; (i ^ a);\n        }\n        return b;\n    }\n};\n</code></pre>\n</div><script src=\"https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js\"></script><script>if (typeof lightGallery !== 'undefined') {\n        var options = {\n            selector: '.gallery-item'\n        };\n        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);\n        }</script>","more":"<h1 id=\"29-Divide-Two-Integers\"><a href=\"https://leetcode-cn.com/problems/divide-two-integers/\" target=\"_blank\" rel=\"noopener\">29. Divide Two Integers</a></h1>\n<p><a href=\"Bit-Manipulation-Medium/image-20200513143056421.png\" title=\"image-20200513143056421\" class=\"gallery-item\"><img src=\"image-20200513143056421.png\" alt=\"image-20200513143056421\"></a></p>\n<h2 id=\"解法一：递归\">解法一：递归</h2>\n<p>不会处理溢出，先贴个投机取巧的方法，虽然也是和题解学的/瘫倒/</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    int divide(int dividend, int divisor) {\n        if(dividend == 0) return 0;\n        if(divisor ==  1) return dividend;\n        if(divisor == -1) {\n            return dividend == INT32_MIN ? INT32_MAX : -dividend;\n        }\n        long a = dividend, b = divisor;\n        bool isNeg = (dividend ^ divisor) &gt;&gt; 31;\n        long res = div(abs(a), abs(b));\n        if(res &gt; INT32_MAX) return INT32_MAX;\n        return isNeg ? -res : res;\n    }\n\n    int div(long a, long b) {\n        if (a &lt; b) return 0;\n        long cnt = 1, t = b;\n        while((t &lt;&lt; 1) &lt;= a) {\n            cnt &lt;&lt;= 1;\n            t &lt;&lt;= 1;\n        }\n        return cnt + div(a - t, b);\n    }\n};\n\n</code></pre>\n<h1 id=\"260-Single-Number-III\"><a href=\"https://leetcode-cn.com/problems/single-number-iii/\" target=\"_blank\" rel=\"noopener\">260. Single Number III</a></h1>\n<p><a href=\"Bit-Manipulation-Medium/image-20200517200551507.png\" title=\"image-20200517200551507\" class=\"gallery-item\"><img src=\"image-20200517200551507.png\" alt=\"image-20200517200551507\"></a></p>\n<h2 id=\"解法一：掩码\">解法一：掩码</h2>\n<ul>\n<li>\n<p>先用一个掩码异或所有数组元素，剩下的将会是出现奇数次的数</p>\n</li>\n<li>\n<p>mask &amp; -mask，取得x， y中最右边的1，这个1只能来自x，y其中之一，可以用来筛掉其中一个</p>\n</li>\n<li>\n<p>注意位运算的优先级很低，一定要加括号</p>\n</li>\n</ul>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    vector&lt;int&gt; singleNumber(vector&lt;int&gt;&amp; nums) {\n        int mask = 0;\n        vector&lt;int&gt; res;\n        for(int i : nums) mask ^= i;\n\n        int t = mask &amp; -mask, tmask = 0;\n        for(int i : nums) if((i &amp; t) != 0) tmask ^= i;\n        return {tmask, tmask ^ mask};\n    }\n};\n</code></pre>\n<h1 id=\"137-Single-Number-II\"><a href=\"https://leetcode-cn.com/problems/single-number-ii/\" target=\"_blank\" rel=\"noopener\">137. Single Number II</a></h1>\n<p><a href=\"Bit-Manipulation-Medium/image-20200504020253182.png\" title=\"image-20200504020253182\" class=\"gallery-item\"><img src=\"image-20200504020253182.png\" alt=\"image-20200504020253182\"></a></p>\n<h2 id=\"解法一：unordered-map\">解法一：unordered_map</h2>\n<p>最简单的办法显然是用map统计出现的次数，再找到出现次数不等于3的那个</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    int singleNumber(vector&lt;int&gt;&amp; nums) {\n        unordered_map&lt;int, int&gt; map;\n        for(int i : nums) map[i]++;\n        for(auto i : map)\n            if(i.second != 3) \n                return i.first;\n        return -1;\n    }\n};\n</code></pre>\n<h2 id=\"解法二：逐位计数\">解法二：逐位计数</h2>\n<p>对每一位出现1的次数计数，时间复杂度 $O(32 * n) = O(n)$, 空间复杂度降到了$O(1)$</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    int singleNumber(vector&lt;int&gt;&amp; nums) {\n        int res = 0;\n        for(int i = 0; i &lt; 32; i++) {\n            int idx = 1 &lt;&lt; i, cnt = 0;\n            for(int v : nums) {\n                if((v &amp; idx) != 0)\n                    cnt++;\n            }\n            if(cnt % 3 == 1)\n                res |= idx;\n        }\n        return res;\n    }\n};\n</code></pre>\n<h2 id=\"解法三：有限状态自动机\">解法三：有限状态自动机</h2>\n<p>用两个位来记录出现次数，一共有三种状态也就是</p>\n<table>\n<thead>\n<tr>\n<th>a</th>\n<th>b</th>\n<th>代表出现的次数</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n</tr>\n<tr>\n<td>0</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>1</td>\n<td>1</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>\n<p>当出现次数超过2时，则重新变回1状态</p>\n</li>\n<li>\n<p>如果画出状态转移表</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>a</th>\n<th>b</th>\n<th>c</th>\n<th>目标状态</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>00</td>\n</tr>\n<tr>\n<td>0</td>\n<td>1</td>\n<td>0</td>\n<td>01</td>\n</tr>\n<tr>\n<td>1</td>\n<td>0</td>\n<td>0</td>\n<td>10</td>\n</tr>\n<tr>\n<td>0</td>\n<td>0</td>\n<td>1</td>\n<td>01</td>\n</tr>\n<tr>\n<td>0</td>\n<td>1</td>\n<td>1</td>\n<td>10</td>\n</tr>\n<tr>\n<td>1</td>\n<td>0</td>\n<td>1</td>\n<td>00</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>\n<p>可以得出转移表达式为</p>\n<pre><code class=\"language-cpp\">b = !a &amp; (b ^ c);\na = !b &amp; (a ^ c);\n</code></pre>\n</li>\n<li>\n<p>最后32位二进制数中剩下非0位即为出现次数为 $3n + 1$ 的位</p>\n</li>\n</ul>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    int singleNumber(vector&lt;int&gt;&amp; nums) {\n        int a = 0, b = 0;\n        for(int i : nums) {\n            b = ~a &amp; (i ^ b);\n            a = ~b &amp; (i ^ a);\n        }\n        return b;\n    }\n};\n</code></pre>\n<script src=\"https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js\"></script><script>if (typeof lightGallery !== 'undefined') {\n        var options = {\n            selector: '.gallery-item'\n        };\n        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);\n        }</script>","categories":[{"name":"Algorithm","path":"api/categories/Algorithm.json"}],"tags":[{"name":"Leetcode","path":"api/tags/Leetcode.json"}]}