{"title":"Executor的设计定位是什么? 怎么玩?","slug":"Executor怎么玩","date":"2020-03-12T06:39:07.000Z","updated":"2020-03-13T12:41:26.989Z","comments":true,"path":"api/articles/Executor怎么玩.json","excerpt":"Abstract：浅谈我对Executor体系的一些理解","covers":null,"content":"<link rel=\"stylesheet\" type=\"text/css\" href=\"https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css\"><div class=\".article-gallery\" <p><strong>Abstract</strong>：浅谈我对Executor体系的一些理解<p></p>\n<a id=\"more\"></a>\n<p>今天摸自己的小项目时，从来不写并发的我突然想加入一点异步功能，翻开<a href=\"https://spring.io/guides/gs/async-method/\" target=\"_blank\" rel=\"noopener\">spring 官方教程</a>，发现用到了ThreadPoolTaskExecutor，封装了juc里面的ThreadPoolExecutor，简单使用倒是也没啥问题吧，但是本着钻研精神还是要把整套东西翻出来看看的😿</p>\n<h1 id=\"Executor在j-u-c中的设计定位\">Executor在j.u.c中的设计定位</h1>\n<ul>\n<li>\n<p>在我看来，想了解一个类，最好不要直接莽源码，而是先看看它所在的包，看看它的周边长啥样，然后观察它的设计定位，最后再去读源码，这样有助于理解和对体系产生比较整体直观的认识</p>\n</li>\n<li>\n<p>所以这里我想说的Executor并不只是指那个接口Executor，而是指代Executor的一个<strong>继承体系</strong>，就像TCP/IP指代整个TCP/IP协议族一样</p>\n</li>\n<li>\n<p>所以j.u.c中有哪几套体系？根据<a href=\"https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/package-summary.html\" target=\"_blank\" rel=\"noopener\">API文档</a>，j.u.c大致分为以下几块</p>\n<ul>\n<li>\n<p><mark><strong>Executors：线程池，异步IO，轻量级的任务框架</strong></mark></p>\n</li>\n<li>\n<p><strong>Queues</strong>： <a href=\"https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/util/concurrent/LinkedBlockingQueue.html\" target=\"_blank\" rel=\"noopener\"><code>LinkedBlockingQueue</code></a>, <a href=\"https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/util/concurrent/ArrayBlockingQueue.html\" target=\"_blank\" rel=\"noopener\"><code>ArrayBlockingQueue</code></a>, <a href=\"https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/util/concurrent/SynchronousQueue.html\" target=\"_blank\" rel=\"noopener\"><code>SynchronousQueue</code></a>, <a href=\"https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/util/concurrent/PriorityBlockingQueue.html\" target=\"_blank\" rel=\"noopener\"><code>PriorityBlockingQueue</code></a>, and <a href=\"https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/util/concurrent/DelayQueue.html\" target=\"_blank\" rel=\"noopener\"><code>DelayQueue</code></a></p>\n<p>维护线程池的阻塞队列</p>\n</li>\n<li>\n<p><strong>Timing</strong>: TimeUnit枚举类，提供各种时间单位，用于各种超时判断等</p>\n</li>\n<li>\n<p><strong>Synchronizers</strong>：几个核心类，比较倾向操作系统调度原理的实现</p>\n<ul>\n<li><a href=\"https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/util/concurrent/Semaphore.html\" target=\"_blank\" rel=\"noopener\"><code>Semaphore</code></a> 经典的基于信号量机制的并发类</li>\n<li><a href=\"https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/util/concurrent/CountDownLatch.html\" target=\"_blank\" rel=\"noopener\"><code>CountDownLatch</code></a> 基于信号量机制，配合Semaphore使用</li>\n<li>A <a href=\"https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/util/concurrent/CyclicBarrier.html\" target=\"_blank\" rel=\"noopener\"><code>CyclicBarrier</code></a> is a resettable multiway synchronization point useful in some styles of parallel programming.并行计算用</li>\n<li>A <a href=\"https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/util/concurrent/Phaser.html\" target=\"_blank\" rel=\"noopener\"><code>Phaser</code></a> provides a more flexible form of barrier that may be used to control phased computation among multiple threads.</li>\n<li>An <a href=\"https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/util/concurrent/Exchanger.html\" target=\"_blank\" rel=\"noopener\"><code>Exchanger</code></a> allows two threads to exchange objects at a rendezvous point, and is useful in several pipeline designs 多管道通信相关</li>\n</ul>\n</li>\n<li>\n<p><strong>Concurrent Collections</strong>：并发集合类，不用多说了吧，核心中的核心，非常重要</p>\n</li>\n<li>\n<p><strong>Memory Consistency Properties</strong>：保证可见性和同步（happens-before）</p>\n</li>\n</ul>\n</li>\n<li>\n<p>再结合Executor系列的API可以发现，Executor系列的主要任务就是将并发任务解耦为以下三部分</p>\n<ul>\n<li>线程创建，线程管理，线程复用 ThreadPool</li>\n<li>任务执行 Executor.submit()/execute()</li>\n<li>接收结果集 Future</li>\n</ul>\n<p><strong>相互独立，分工明确，从而形成解耦，可以说是非常的Object Orient啊</strong>☕️</p>\n</li>\n</ul>\n<h1 id=\"Executor内部分层\">Executor内部分层</h1>\n<ul>\n<li>\n<p><strong>Task层</strong>：指定提交的任务，具体来讲就是实现了Callable &amp; Runnable接口的对象</p>\n</li>\n<li>\n<p><strong>ExecutorSerivice层</strong>：生产各种用途不同的线程池，可以通过静态工厂Executors.newXXXXThreaPool(n)拿到（也可以自己定义ThreadPoolExecutor），然后执行提交的任务</p>\n<ul>\n<li>FixedThreadPool，固定大小的线程池</li>\n<li>CacheThreadPool，可扩展能自动回收的线程池</li>\n<li>ScheduleThreadPool，支持周期任务</li>\n<li>WorkStealingPool</li>\n<li>SingleThreadExecutor，只运行单个线程的线程池</li>\n<li>SingleThreadScheduledExecutor，支持周期任务的单线程池</li>\n<li>以及自定义的ThreadPoolExecutor</li>\n</ul>\n</li>\n<li>\n<p><strong>Future层</strong>：接受Executor执行的结果</p>\n</li>\n</ul>\n<p>举个简单的例子就是：创建执行器服务(ExecutorService)-&gt;指定线程池大小-&gt;提交任务-&gt;返回结果</p>\n<pre><code class=\"language-java\">ExecutorService service=Executors.newFixedThreadPool(10);\nString example = service.submit(() -&gt; { //Callable是Functional Interface，可以直接走Lambda表达式\n    System.out.println(&quot;This is a example&quot;);\n    return &quot;Task Over&quot;;\n}).get();\n</code></pre>\n<h1 id=\"和直接走Thread又有什么区别呢？\">和直接走Thread又有什么区别呢？</h1>\n<p>功能上看，似乎没什么大不了的，但是Executor框架做到了以下几件事：</p>\n<ul>\n<li>自动管理线程，最大程度地减小线程创建和销毁所造成的额外开销</li>\n<li>减少线程切换上下文产生的开销</li>\n</ul>\n</div><script src=\"https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js\"></script><script>if (typeof lightGallery !== 'undefined') {\n        var options = {\n            selector: '.gallery-item'\n        };\n        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);\n        }</script>","more":"<p>今天摸自己的小项目时，从来不写并发的我突然想加入一点异步功能，翻开<a href=\"https://spring.io/guides/gs/async-method/\" target=\"_blank\" rel=\"noopener\">spring 官方教程</a>，发现用到了ThreadPoolTaskExecutor，封装了juc里面的ThreadPoolExecutor，简单使用倒是也没啥问题吧，但是本着钻研精神还是要把整套东西翻出来看看的😿</p>\n<h1 id=\"Executor在j-u-c中的设计定位\">Executor在j.u.c中的设计定位</h1>\n<ul>\n<li>\n<p>在我看来，想了解一个类，最好不要直接莽源码，而是先看看它所在的包，看看它的周边长啥样，然后观察它的设计定位，最后再去读源码，这样有助于理解和对体系产生比较整体直观的认识</p>\n</li>\n<li>\n<p>所以这里我想说的Executor并不只是指那个接口Executor，而是指代Executor的一个<strong>继承体系</strong>，就像TCP/IP指代整个TCP/IP协议族一样</p>\n</li>\n<li>\n<p>所以j.u.c中有哪几套体系？根据<a href=\"https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/package-summary.html\" target=\"_blank\" rel=\"noopener\">API文档</a>，j.u.c大致分为以下几块</p>\n<ul>\n<li>\n<p><mark><strong>Executors：线程池，异步IO，轻量级的任务框架</strong></mark></p>\n</li>\n<li>\n<p><strong>Queues</strong>： <a href=\"https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/util/concurrent/LinkedBlockingQueue.html\" target=\"_blank\" rel=\"noopener\"><code>LinkedBlockingQueue</code></a>, <a href=\"https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/util/concurrent/ArrayBlockingQueue.html\" target=\"_blank\" rel=\"noopener\"><code>ArrayBlockingQueue</code></a>, <a href=\"https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/util/concurrent/SynchronousQueue.html\" target=\"_blank\" rel=\"noopener\"><code>SynchronousQueue</code></a>, <a href=\"https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/util/concurrent/PriorityBlockingQueue.html\" target=\"_blank\" rel=\"noopener\"><code>PriorityBlockingQueue</code></a>, and <a href=\"https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/util/concurrent/DelayQueue.html\" target=\"_blank\" rel=\"noopener\"><code>DelayQueue</code></a></p>\n<p>维护线程池的阻塞队列</p>\n</li>\n<li>\n<p><strong>Timing</strong>: TimeUnit枚举类，提供各种时间单位，用于各种超时判断等</p>\n</li>\n<li>\n<p><strong>Synchronizers</strong>：几个核心类，比较倾向操作系统调度原理的实现</p>\n<ul>\n<li><a href=\"https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/util/concurrent/Semaphore.html\" target=\"_blank\" rel=\"noopener\"><code>Semaphore</code></a> 经典的基于信号量机制的并发类</li>\n<li><a href=\"https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/util/concurrent/CountDownLatch.html\" target=\"_blank\" rel=\"noopener\"><code>CountDownLatch</code></a> 基于信号量机制，配合Semaphore使用</li>\n<li>A <a href=\"https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/util/concurrent/CyclicBarrier.html\" target=\"_blank\" rel=\"noopener\"><code>CyclicBarrier</code></a> is a resettable multiway synchronization point useful in some styles of parallel programming.并行计算用</li>\n<li>A <a href=\"https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/util/concurrent/Phaser.html\" target=\"_blank\" rel=\"noopener\"><code>Phaser</code></a> provides a more flexible form of barrier that may be used to control phased computation among multiple threads.</li>\n<li>An <a href=\"https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/util/concurrent/Exchanger.html\" target=\"_blank\" rel=\"noopener\"><code>Exchanger</code></a> allows two threads to exchange objects at a rendezvous point, and is useful in several pipeline designs 多管道通信相关</li>\n</ul>\n</li>\n<li>\n<p><strong>Concurrent Collections</strong>：并发集合类，不用多说了吧，核心中的核心，非常重要</p>\n</li>\n<li>\n<p><strong>Memory Consistency Properties</strong>：保证可见性和同步（happens-before）</p>\n</li>\n</ul>\n</li>\n<li>\n<p>再结合Executor系列的API可以发现，Executor系列的主要任务就是将并发任务解耦为以下三部分</p>\n<ul>\n<li>线程创建，线程管理，线程复用 ThreadPool</li>\n<li>任务执行 Executor.submit()/execute()</li>\n<li>接收结果集 Future</li>\n</ul>\n<p><strong>相互独立，分工明确，从而形成解耦，可以说是非常的Object Orient啊</strong>☕️</p>\n</li>\n</ul>\n<h1 id=\"Executor内部分层\">Executor内部分层</h1>\n<ul>\n<li>\n<p><strong>Task层</strong>：指定提交的任务，具体来讲就是实现了Callable &amp; Runnable接口的对象</p>\n</li>\n<li>\n<p><strong>ExecutorSerivice层</strong>：生产各种用途不同的线程池，可以通过静态工厂Executors.newXXXXThreaPool(n)拿到（也可以自己定义ThreadPoolExecutor），然后执行提交的任务</p>\n<ul>\n<li>FixedThreadPool，固定大小的线程池</li>\n<li>CacheThreadPool，可扩展能自动回收的线程池</li>\n<li>ScheduleThreadPool，支持周期任务</li>\n<li>WorkStealingPool</li>\n<li>SingleThreadExecutor，只运行单个线程的线程池</li>\n<li>SingleThreadScheduledExecutor，支持周期任务的单线程池</li>\n<li>以及自定义的ThreadPoolExecutor</li>\n</ul>\n</li>\n<li>\n<p><strong>Future层</strong>：接受Executor执行的结果</p>\n</li>\n</ul>\n<p>举个简单的例子就是：创建执行器服务(ExecutorService)-&gt;指定线程池大小-&gt;提交任务-&gt;返回结果</p>\n<pre><code class=\"language-java\">ExecutorService service=Executors.newFixedThreadPool(10);\nString example = service.submit(() -&gt; { //Callable是Functional Interface，可以直接走Lambda表达式\n    System.out.println(&quot;This is a example&quot;);\n    return &quot;Task Over&quot;;\n}).get();\n</code></pre>\n<h1 id=\"和直接走Thread又有什么区别呢？\">和直接走Thread又有什么区别呢？</h1>\n<p>功能上看，似乎没什么大不了的，但是Executor框架做到了以下几件事：</p>\n<ul>\n<li>自动管理线程，最大程度地减小线程创建和销毁所造成的额外开销</li>\n<li>减少线程切换上下文产生的开销</li>\n</ul>\n<script src=\"https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js\"></script><script>if (typeof lightGallery !== 'undefined') {\n        var options = {\n            selector: '.gallery-item'\n        };\n        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);\n        }</script>","categories":[{"name":"Java","path":"api/categories/Java.json"}],"tags":[{"name":"concurrency","path":"api/tags/concurrency.json"}]}