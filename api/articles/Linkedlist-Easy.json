{"title":"Linkedlist-Easy","slug":"Linkedlist-Easy","date":"2020-02-26T15:16:23.000Z","updated":"2020-02-27T03:25:46.196Z","comments":true,"path":"api/articles/Linkedlist-Easy.json","excerpt":"Abstract： 更新部分Easy难度 Linkedlist相关题解","covers":["image-20200226234344400.png","image-20200226234447241.png","image-20200226234530100.png","image-20200226234623461.png","image-20200226234948582.png"],"content":"<link rel=\"stylesheet\" type=\"text/css\" href=\"https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css\"><div class=\".article-gallery\" <p><strong>Abstract：</strong> 更新部分<code>Easy</code>难度 <code>Linkedlist</code>相关题解<p></p>\n<a id=\"more\"></a>\n<h1 id=\"21-Merge-Two-Sorted-Lists\"><a href=\"https://leetcode-cn.com/problems/merge-two-sorted-lists/\" target=\"_blank\" rel=\"noopener\">21. Merge Two Sorted Lists</a></h1>\n<p><a href=\"Linkedlist-Easy/image-20200226234344400.png\" title=\"image-20200226234344400\" class=\"gallery-item\"><img src=\"image-20200226234344400.png\" alt=\"image-20200226234344400\"></a></p>\n<h2 id=\"解法一：递归法\">解法一：递归法</h2>\n<p class=\"code-caption\" data-lang=\"java\" data-line_number=\"frontend\" data-trim_indent=\"backend\" data-label_position=\"outer\" data-labels_left=\"Code\" data-labels_right=\":\" data-labels_copy=\"Copy Code\"><span class=\"code-caption-label\"></span></p>\n<pre><code class=\"language-java\">class Solution {\n    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n        if(l1==null)return l2;\n        else if(l2==null)return l1;\n        else if(l1.val&lt;l2.val){\n            l1.next=mergeTwoLists(l1.next,l2);\n            return l1;\n            }\n        else {\n            l2.next=mergeTwoLists(l2.next,l1);\n            return l2;\n        }\n    }\n}\n</code></pre>\n<h2 id=\"解法二：迭代法\">解法二：迭代法</h2>\n<p class=\"code-caption\" data-lang=\"java\" data-line_number=\"frontend\" data-trim_indent=\"backend\" data-label_position=\"outer\" data-labels_left=\"Code\" data-labels_right=\":\" data-labels_copy=\"Copy Code\"><span class=\"code-caption-label\"></span></p>\n<pre><code class=\"language-java\">class Solution {\n    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n        ListNode pre_head=new ListNode(-1);  //合并结果的头结点，pre_head.next开始为答案\n        ListNode curr=pre_head;              //指向当前访问节点\n        while(l1!=null &amp;&amp; l2!=null){\n            if(l1.val&lt;l2.val){               //根据大小判断先放谁\n                curr.next=l1;\n                l1=l1.next;\n            }\n            else {\n                curr.next=l2;\n                l2=l2.next;\n            }\n            curr=curr.next;\n        }\n        curr.next=l1==null?l2:l1;           //当一方为null时，另一方的剩余部分放入解的尾部\n        return pre_head.next;\n    }\n}\n</code></pre>\n<h1 id=\"83-Remove-Duplicates-from-Sorted-List\"><a href=\"https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/\" target=\"_blank\" rel=\"noopener\">83. Remove Duplicates from Sorted List</a></h1>\n<p><a href=\"Linkedlist-Easy/image-20200226234447241.png\" title=\"image-20200226234447241\" class=\"gallery-item\"><img src=\"image-20200226234447241.png\" alt=\"image-20200226234447241\"></a></p>\n<h2 id=\"解法一：迭代法\">解法一：迭代法</h2>\n<p class=\"code-caption\" data-lang=\"java\" data-line_number=\"frontend\" data-trim_indent=\"backend\" data-label_position=\"outer\" data-labels_left=\"Code\" data-labels_right=\":\" data-labels_copy=\"Copy Code\"><span class=\"code-caption-label\"></span></p>\n<pre><code class=\"language-java\">class Solution {\n    public ListNode deleteDuplicates(ListNode head) {\n       if(head==null)return null;\n       ListNode curr=head;\n       while(curr!=null &amp;&amp; curr.next!=null){\n           if(curr.val==curr.next.val)\n               curr.next=curr.next.next;\n           else\n               curr=curr.next;\n       }\n       return head;\n    }\n}\n</code></pre>\n<h1 id=\"206-Reverse-Linked-List\"><a href=\"https://leetcode-cn.com/problems/reverse-linked-list/\" target=\"_blank\" rel=\"noopener\">206. Reverse Linked List</a></h1>\n<p><a href=\"Linkedlist-Easy/image-20200226234530100.png\" title=\"image-20200226234530100\" class=\"gallery-item\"><img src=\"image-20200226234530100.png\" alt=\"image-20200226234530100\"></a></p>\n<h2 id=\"解法一：递归法-v2\">解法一：递归法</h2>\n<p class=\"code-caption\" data-lang=\"java\" data-line_number=\"frontend\" data-trim_indent=\"backend\" data-label_position=\"outer\" data-labels_left=\"Code\" data-labels_right=\":\" data-labels_copy=\"Copy Code\"><span class=\"code-caption-label\"></span></p>\n<pre><code class=\"language-java\">class Solution {\n    public ListNode reverseList(ListNode head) {\n        if(head==null || head.next==null)return head; //递归结束条件\n        \n        ListNode n_head=reverseList(head.next); //next为翻转后部分的头部,即原先的尾部\n        head.next.next=head;                    //翻转后部分的尾部，本来为null，先将它指向head\n        head.next=null;\t\t\t\t\t\t    //将原先的head.next设为null，防止出现循环链表\n        return n_head;                          //返回新的头部\n    }\n}\n</code></pre>\n<h2 id=\"解法二：迭代法-v2\">解法二：迭代法</h2>\n<p class=\"code-caption\" data-lang=\"java\" data-line_number=\"frontend\" data-trim_indent=\"backend\" data-label_position=\"outer\" data-labels_left=\"Code\" data-labels_right=\":\" data-labels_copy=\"Copy Code\"><span class=\"code-caption-label\"></span></p>\n<pre><code class=\"language-java\">class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev=null;          //prev初始为null,所以不必担心出现循环链表\n        ListNode curr=head;\n        while(curr!=null){\n            ListNode next=curr.next; //保存curr.next\n            curr.next=prev;          //翻转\n            prev=curr;\n            curr=next;               //prev,curr向前移动一格\n        }\n        return prev;\n    }\n}\n</code></pre>\n<h1 id=\"160-Intersection-of-Two-Linked-Lists\"><a href=\"https://leetcode-cn.com/problems/intersection-of-two-linked-lists/\" target=\"_blank\" rel=\"noopener\">160. Intersection of Two Linked Lists</a></h1>\n<p><a href=\"Linkedlist-Easy/image-20200226234623461.png\" title=\"image-20200226234623461\" class=\"gallery-item\"><img src=\"image-20200226234623461.png\" alt=\"image-20200226234623461\"></a></p>\n<h2 id=\"解法一：HashSet\">解法一：HashSet</h2>\n<p class=\"code-caption\" data-lang=\"java\" data-line_number=\"frontend\" data-trim_indent=\"backend\" data-label_position=\"outer\" data-labels_left=\"Code\" data-labels_right=\":\" data-labels_copy=\"Copy Code\"><span class=\"code-caption-label\"></span></p>\n<pre><code class=\"language-java\">public class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        Set&lt;ListNode&gt; set=new HashSet&lt;ListNode&gt;();\n        ListNode curr_a=headA;\n        ListNode curr_b=headB;\n        while(curr_a!=null){ //遍历链表A，将所有节点加入HashSet\n            set.add(curr_a);\n            curr_a=curr_a.next;\n        }\n        while(curr_b!=null){ //遍历链表B，看是否有节点在HashSet存在\n            if(set.contains(curr_b))return curr_b;\n            curr_b=curr_b.next;\n        }\n        return null;\n    }\n}\n</code></pre>\n<h2 id=\"解法二：双指针\">解法二：双指针</h2>\n<p><a href=\"https://leetcode-cn.com/problems/intersection-of-two-linked-lists/solution/xiang-jiao-lian-biao-by-leetcode/\" target=\"_blank\" rel=\"noopener\">参考官方题解3：十分巧妙</a></p>\n<p class=\"code-caption\" data-lang=\"java\" data-line_number=\"frontend\" data-trim_indent=\"backend\" data-label_position=\"outer\" data-labels_left=\"Code\" data-labels_right=\":\" data-labels_copy=\"Copy Code\"><span class=\"code-caption-label\"></span></p>\n<pre><code class=\"language-java\">public class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        ListNode curr_a=headA;\n        ListNode curr_b=headB;\n        while(curr_a!=null &amp;&amp; curr_b!=null){\n            if(curr_a==curr_b)return curr_a; //交点\n            curr_a=curr_a.next;\n            curr_b=curr_b.next;\n            if(curr_a==null &amp;&amp; curr_b==null)return null;//到达终点，证明不存在\n            if(curr_a==null)curr_a=headB; //a接入b链\n            if(curr_b==null)curr_b=headA; //b接入a链\n        }\n        return null;\n    }\n}\n</code></pre>\n<h1 id=\"234-Palindrome-Linked-List\"><a href=\"https://leetcode-cn.com/problems/palindrome-linked-list/\" target=\"_blank\" rel=\"noopener\">234. Palindrome Linked List</a></h1>\n<p><a href=\"Linkedlist-Easy/image-20200226234948582.png\" title=\"image-20200226234948582\" class=\"gallery-item\"><img src=\"image-20200226234948582.png\" alt=\"image-20200226234948582\"></a></p>\n<h2 id=\"解法一：栈\">解法一：栈</h2>\n<ul>\n<li>简明，和数组的做法没有区别，但是空间复杂度O(n)</li>\n</ul>\n<p class=\"code-caption\" data-lang=\"java\" data-line_number=\"frontend\" data-trim_indent=\"backend\" data-label_position=\"outer\" data-labels_left=\"Code\" data-labels_right=\":\" data-labels_copy=\"Copy Code\"><span class=\"code-caption-label\"></span></p>\n<pre><code class=\"language-java\">class Solution {\n    public boolean isPalindrome(ListNode head) {\n        Stack&lt;Integer&gt; stack=new Stack&lt;Integer&gt;(); //空间复杂度O(n)\n        ListNode curr=head;\n        while(curr!=null){ //第一次遍历，将所有值压入栈内\n            stack.push(curr.val);\n            curr=curr.next;\n        }\n        while(head!=null){ //第二次遍历，逐一比对\n            if(stack.pop()!=head.val)return false;\n            head=head.next;\n        }\n        \n        return true;\n    }\n}\n</code></pre>\n</div><script src=\"https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js\"></script><script>if (typeof lightGallery !== 'undefined') {\n        var options = {\n            selector: '.gallery-item'\n        };\n        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);\n        }</script>","more":"<h1 id=\"21-Merge-Two-Sorted-Lists\"><a href=\"https://leetcode-cn.com/problems/merge-two-sorted-lists/\" target=\"_blank\" rel=\"noopener\">21. Merge Two Sorted Lists</a></h1>\n<p><a href=\"Linkedlist-Easy/image-20200226234344400.png\" title=\"image-20200226234344400\" class=\"gallery-item\"><img src=\"image-20200226234344400.png\" alt=\"image-20200226234344400\"></a></p>\n<h2 id=\"解法一：递归法\">解法一：递归法</h2>\n<p class=\"code-caption\" data-lang=\"java\" data-line_number=\"frontend\" data-trim_indent=\"backend\" data-label_position=\"outer\" data-labels_left=\"Code\" data-labels_right=\":\" data-labels_copy=\"Copy Code\"><span class=\"code-caption-label\"></span></p>\n<pre><code class=\"language-java\">class Solution {\n    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n        if(l1==null)return l2;\n        else if(l2==null)return l1;\n        else if(l1.val&lt;l2.val){\n            l1.next=mergeTwoLists(l1.next,l2);\n            return l1;\n            }\n        else {\n            l2.next=mergeTwoLists(l2.next,l1);\n            return l2;\n        }\n    }\n}\n</code></pre>\n<h2 id=\"解法二：迭代法\">解法二：迭代法</h2>\n<p class=\"code-caption\" data-lang=\"java\" data-line_number=\"frontend\" data-trim_indent=\"backend\" data-label_position=\"outer\" data-labels_left=\"Code\" data-labels_right=\":\" data-labels_copy=\"Copy Code\"><span class=\"code-caption-label\"></span></p>\n<pre><code class=\"language-java\">class Solution {\n    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n        ListNode pre_head=new ListNode(-1);  //合并结果的头结点，pre_head.next开始为答案\n        ListNode curr=pre_head;              //指向当前访问节点\n        while(l1!=null &amp;&amp; l2!=null){\n            if(l1.val&lt;l2.val){               //根据大小判断先放谁\n                curr.next=l1;\n                l1=l1.next;\n            }\n            else {\n                curr.next=l2;\n                l2=l2.next;\n            }\n            curr=curr.next;\n        }\n        curr.next=l1==null?l2:l1;           //当一方为null时，另一方的剩余部分放入解的尾部\n        return pre_head.next;\n    }\n}\n</code></pre>\n<h1 id=\"83-Remove-Duplicates-from-Sorted-List\"><a href=\"https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/\" target=\"_blank\" rel=\"noopener\">83. Remove Duplicates from Sorted List</a></h1>\n<p><a href=\"Linkedlist-Easy/image-20200226234447241.png\" title=\"image-20200226234447241\" class=\"gallery-item\"><img src=\"image-20200226234447241.png\" alt=\"image-20200226234447241\"></a></p>\n<h2 id=\"解法一：迭代法\">解法一：迭代法</h2>\n<p class=\"code-caption\" data-lang=\"java\" data-line_number=\"frontend\" data-trim_indent=\"backend\" data-label_position=\"outer\" data-labels_left=\"Code\" data-labels_right=\":\" data-labels_copy=\"Copy Code\"><span class=\"code-caption-label\"></span></p>\n<pre><code class=\"language-java\">class Solution {\n    public ListNode deleteDuplicates(ListNode head) {\n       if(head==null)return null;\n       ListNode curr=head;\n       while(curr!=null &amp;&amp; curr.next!=null){\n           if(curr.val==curr.next.val)\n               curr.next=curr.next.next;\n           else\n               curr=curr.next;\n       }\n       return head;\n    }\n}\n</code></pre>\n<h1 id=\"206-Reverse-Linked-List\"><a href=\"https://leetcode-cn.com/problems/reverse-linked-list/\" target=\"_blank\" rel=\"noopener\">206. Reverse Linked List</a></h1>\n<p><a href=\"Linkedlist-Easy/image-20200226234530100.png\" title=\"image-20200226234530100\" class=\"gallery-item\"><img src=\"image-20200226234530100.png\" alt=\"image-20200226234530100\"></a></p>\n<h2 id=\"解法一：递归法-v2\">解法一：递归法</h2>\n<p class=\"code-caption\" data-lang=\"java\" data-line_number=\"frontend\" data-trim_indent=\"backend\" data-label_position=\"outer\" data-labels_left=\"Code\" data-labels_right=\":\" data-labels_copy=\"Copy Code\"><span class=\"code-caption-label\"></span></p>\n<pre><code class=\"language-java\">class Solution {\n    public ListNode reverseList(ListNode head) {\n        if(head==null || head.next==null)return head; //递归结束条件\n        \n        ListNode n_head=reverseList(head.next); //next为翻转后部分的头部,即原先的尾部\n        head.next.next=head;                    //翻转后部分的尾部，本来为null，先将它指向head\n        head.next=null;\t\t\t\t\t\t    //将原先的head.next设为null，防止出现循环链表\n        return n_head;                          //返回新的头部\n    }\n}\n</code></pre>\n<h2 id=\"解法二：迭代法-v2\">解法二：迭代法</h2>\n<p class=\"code-caption\" data-lang=\"java\" data-line_number=\"frontend\" data-trim_indent=\"backend\" data-label_position=\"outer\" data-labels_left=\"Code\" data-labels_right=\":\" data-labels_copy=\"Copy Code\"><span class=\"code-caption-label\"></span></p>\n<pre><code class=\"language-java\">class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev=null;          //prev初始为null,所以不必担心出现循环链表\n        ListNode curr=head;\n        while(curr!=null){\n            ListNode next=curr.next; //保存curr.next\n            curr.next=prev;          //翻转\n            prev=curr;\n            curr=next;               //prev,curr向前移动一格\n        }\n        return prev;\n    }\n}\n</code></pre>\n<h1 id=\"160-Intersection-of-Two-Linked-Lists\"><a href=\"https://leetcode-cn.com/problems/intersection-of-two-linked-lists/\" target=\"_blank\" rel=\"noopener\">160. Intersection of Two Linked Lists</a></h1>\n<p><a href=\"Linkedlist-Easy/image-20200226234623461.png\" title=\"image-20200226234623461\" class=\"gallery-item\"><img src=\"image-20200226234623461.png\" alt=\"image-20200226234623461\"></a></p>\n<h2 id=\"解法一：HashSet\">解法一：HashSet</h2>\n<p class=\"code-caption\" data-lang=\"java\" data-line_number=\"frontend\" data-trim_indent=\"backend\" data-label_position=\"outer\" data-labels_left=\"Code\" data-labels_right=\":\" data-labels_copy=\"Copy Code\"><span class=\"code-caption-label\"></span></p>\n<pre><code class=\"language-java\">public class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        Set&lt;ListNode&gt; set=new HashSet&lt;ListNode&gt;();\n        ListNode curr_a=headA;\n        ListNode curr_b=headB;\n        while(curr_a!=null){ //遍历链表A，将所有节点加入HashSet\n            set.add(curr_a);\n            curr_a=curr_a.next;\n        }\n        while(curr_b!=null){ //遍历链表B，看是否有节点在HashSet存在\n            if(set.contains(curr_b))return curr_b;\n            curr_b=curr_b.next;\n        }\n        return null;\n    }\n}\n</code></pre>\n<h2 id=\"解法二：双指针\">解法二：双指针</h2>\n<p><a href=\"https://leetcode-cn.com/problems/intersection-of-two-linked-lists/solution/xiang-jiao-lian-biao-by-leetcode/\" target=\"_blank\" rel=\"noopener\">参考官方题解3：十分巧妙</a></p>\n<p class=\"code-caption\" data-lang=\"java\" data-line_number=\"frontend\" data-trim_indent=\"backend\" data-label_position=\"outer\" data-labels_left=\"Code\" data-labels_right=\":\" data-labels_copy=\"Copy Code\"><span class=\"code-caption-label\"></span></p>\n<pre><code class=\"language-java\">public class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        ListNode curr_a=headA;\n        ListNode curr_b=headB;\n        while(curr_a!=null &amp;&amp; curr_b!=null){\n            if(curr_a==curr_b)return curr_a; //交点\n            curr_a=curr_a.next;\n            curr_b=curr_b.next;\n            if(curr_a==null &amp;&amp; curr_b==null)return null;//到达终点，证明不存在\n            if(curr_a==null)curr_a=headB; //a接入b链\n            if(curr_b==null)curr_b=headA; //b接入a链\n        }\n        return null;\n    }\n}\n</code></pre>\n<h1 id=\"234-Palindrome-Linked-List\"><a href=\"https://leetcode-cn.com/problems/palindrome-linked-list/\" target=\"_blank\" rel=\"noopener\">234. Palindrome Linked List</a></h1>\n<p><a href=\"Linkedlist-Easy/image-20200226234948582.png\" title=\"image-20200226234948582\" class=\"gallery-item\"><img src=\"image-20200226234948582.png\" alt=\"image-20200226234948582\"></a></p>\n<h2 id=\"解法一：栈\">解法一：栈</h2>\n<ul>\n<li>简明，和数组的做法没有区别，但是空间复杂度O(n)</li>\n</ul>\n<p class=\"code-caption\" data-lang=\"java\" data-line_number=\"frontend\" data-trim_indent=\"backend\" data-label_position=\"outer\" data-labels_left=\"Code\" data-labels_right=\":\" data-labels_copy=\"Copy Code\"><span class=\"code-caption-label\"></span></p>\n<pre><code class=\"language-java\">class Solution {\n    public boolean isPalindrome(ListNode head) {\n        Stack&lt;Integer&gt; stack=new Stack&lt;Integer&gt;(); //空间复杂度O(n)\n        ListNode curr=head;\n        while(curr!=null){ //第一次遍历，将所有值压入栈内\n            stack.push(curr.val);\n            curr=curr.next;\n        }\n        while(head!=null){ //第二次遍历，逐一比对\n            if(stack.pop()!=head.val)return false;\n            head=head.next;\n        }\n        \n        return true;\n    }\n}\n</code></pre>\n<script src=\"https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js\"></script><script>if (typeof lightGallery !== 'undefined') {\n        var options = {\n            selector: '.gallery-item'\n        };\n        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);\n        }</script>","categories":[{"name":"Algorithm","path":"api/categories/Algorithm.json"}],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"}]}