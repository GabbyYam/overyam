{"title":"Tree-Medium","slug":"Tree-Medium","date":"2020-02-26T15:17:10.000Z","updated":"2020-02-26T16:04:38.701Z","comments":true,"path":"api/articles/Tree-Medium.json","excerpt":"Abstract： 更新部分Medium难度 Tree相关题解","covers":["image-20200227000049240.png","image-20200227000119239.png","image-20200227000238249.png","image-20200227000418519.png","image-20200227000435747.png"],"content":"<p><strong>Abstract：</strong> 更新部分<code>Medium</code>难度 <code>Tree</code>相关题解</p>\n<a id=\"more\"></a>\n<h1 id=\"94-Binary-Tree-Inorder-Traversal\"><a href=\"https://leetcode-cn.com/problems/binary-tree-inorder-traversal/\" target=\"_blank\" rel=\"noopener\">94. Binary Tree Inorder Traversal</a></h1>\n<p><img src=\"image-20200227000049240.png\" alt=\"image-20200227000049240\"></p>\n<h2 id=\"解法一：递归法\">解法一：递归法</h2>\n<p>没什么好说的，不会砍手</p>\n<p class=\"code-caption\" data-lang=\"java\" data-line_number=\"frontend\" data-trim_indent=\"backend\" data-label_position=\"outer\" data-labels_left=\"Code\" data-labels_right=\":\" data-labels_copy=\"Copy Code\"><span class=\"code-caption-label\"></span></p>\n<pre><code class=\"language-java\">class Solution {\n    List&lt;Integer&gt; inorder=new ArrayList&lt;Integer&gt;();\n    public List&lt;Integer&gt; inorderTraversal(TreeNode root) {\n        if(root!=null){\n        inorder=inorderTraversal(root.left);\n        inorder.add(root.val);\n        inorder=inorderTraversal(root.right);}\n        \n        return inorder;\n    }\n}\n</code></pre>\n<h2 id=\"解法二：迭代法\">解法二：迭代法</h2>\n<p>比递归法难理解一些，重点是理解好如何回溯</p>\n<p class=\"code-caption\" data-lang=\"java\" data-line_number=\"frontend\" data-trim_indent=\"backend\" data-label_position=\"outer\" data-labels_left=\"Code\" data-labels_right=\":\" data-labels_copy=\"Copy Code\"><span class=\"code-caption-label\"></span></p>\n<pre><code class=\"language-java\">class Solution {\n    List&lt;Integer&gt; inorder=new ArrayList&lt;Integer&gt;();\n    Stack&lt;TreeNode&gt; stack=new Stack&lt;TreeNode&gt;();\n    public List&lt;Integer&gt; inorderTraversal(TreeNode root) {\n        TreeNode curr=root; //辅助接点curr，指向当前访问的TreeNode\n        while(curr!=null || !stack.isEmpty()){ //当前访问的节点不为空或栈不为空，说明还没遍历完\n            while(curr!=null){ //不断压入左节点\n                stack.push(curr);\n                curr=curr.left;\n            }\n            curr=stack.pop(); //**回溯**\n            inorder.add(curr.val); //将当前访问的节点加入\n            curr=curr.right; //如果有右节点则访问右节点，如果没有将在下一轮回溯或者结束\n        }\n        return inorder;\n    }\n}\n</code></pre>\n<h2 id=\"解法三：-莫比斯遍历\">解法三： 莫比斯遍历</h2>\n<p class=\"code-caption\" data-lang=\"java\" data-line_number=\"frontend\" data-trim_indent=\"backend\" data-label_position=\"outer\" data-labels_left=\"Code\" data-labels_right=\":\" data-labels_copy=\"Copy Code\"><span class=\"code-caption-label\"></span></p>\n<pre><code class=\"language-java\">//待补全\n</code></pre>\n<h1 id=\"96-Unique-Binary-Search-Trees\"><a href=\"https://leetcode-cn.com/problems/unique-binary-search-trees/\" target=\"_blank\" rel=\"noopener\">96. Unique Binary Search Trees</a></h1>\n<p><img src=\"image-20200227000119239.png\" alt=\"image-20200227000119239\"></p>\n<h2 id=\"解法一：递归法-v2\">解法一：递归法</h2>\n<ul>\n<li>\n<p>**思路：**分别以1-n的任意整数为根，那么左右子树有哪些值是可以确定的，因此可以递归地来做</p>\n</li>\n<li>\n<p><strong>要点：</strong>{4,5,6,7,8}在此处可以等价于{1,2,3,4,5}，因此可以很方便的进行递归，但是在这里只是个取巧的做法</p>\n</li>\n<li>\n<p>**缺点：**没有保存递归结果，增加了许多重复的操作，下一个解法考虑对结果进行缓存</p>\n</li>\n</ul>\n<p class=\"code-caption\" data-lang=\"java\" data-line_number=\"frontend\" data-trim_indent=\"backend\" data-label_position=\"outer\" data-labels_left=\"Code\" data-labels_right=\":\" data-labels_copy=\"Copy Code\"><span class=\"code-caption-label\"></span></p>\n<pre><code class=\"language-java\">class Solution {\n    public int numTrees(int n) {\n        if(n&lt;=1)return 1; //特殊情况，以及递归的基准\n        int uniqueNum=0;\n        for(int i=1;i&lt;=n;i++){uniqueNum+=numTrees(i-1)*numTrees(n-i);} //递归左右区间的乘积\n        return uniqueNum;\n    }\n}\n</code></pre>\n<h2 id=\"解法二：记忆化递归\">解法二：记忆化递归</h2>\n<p>直接递归的缺点是重复递归很多地方，所以需要剪枝</p>\n<p class=\"code-caption\" data-lang=\"java\" data-line_number=\"frontend\" data-trim_indent=\"backend\" data-label_position=\"outer\" data-labels_left=\"Code\" data-labels_right=\":\" data-labels_copy=\"Copy Code\"><span class=\"code-caption-label\"></span></p>\n<pre><code class=\"language-java\">class Solution {\n    public int numTrees(int n) {\n        int[] dp=new int[n+1];\n        return dynamicNumTrees(n,dp);\n    }\n\n    public int dynamicNumTrees(int n,int[] dp){\n        if(n&lt;=1){return 1;}\n        if(dp[n]!=0){return dp[n];} //加入缓存\n        for(int i=1;i&lt;=n;i++){dp[n]+=dynamicNumTrees(i-1,dp)*dynamicNumTrees(n-i,dp);}\n        return dp[n];\n    }\n}\n</code></pre>\n<h1 id=\"95-Unique-Binary-Search-Trees-II\"><a href=\"https://leetcode-cn.com/problems/unique-binary-search-trees-ii/\" target=\"_blank\" rel=\"noopener\">95. Unique Binary Search Trees II</a></h1>\n<p><img src=\"image-20200227000238249.png\" alt=\"image-20200227000238249\"></p>\n<h2 id=\"解法一：递归法-v3\">解法一：递归法</h2>\n<p>和上题类似的递归思路，不过注意<mark>root的创建时机</mark></p>\n<p class=\"code-caption\" data-lang=\"java\" data-line_number=\"frontend\" data-trim_indent=\"backend\" data-label_position=\"outer\" data-labels_left=\"Code\" data-labels_right=\":\" data-labels_copy=\"Copy Code\"><span class=\"code-caption-label\"></span></p>\n<pre><code class=\"language-java\">class Solution {\n    public List&lt;TreeNode&gt; generateTrees(int n) {\n        if(n==0)return new LinkedList&lt;TreeNode&gt;(); //特殊情况\n        return generate(1,n);\n    }\n\n    public List&lt;TreeNode&gt; generate(int lo,int hi){\n        List&lt;TreeNode&gt; BSTs=new LinkedList&lt;TreeNode&gt;();     //注意ArrayList不能加入null\n        if(lo&gt;hi){BSTs.add(null);return BSTs;}              //加入null\n        if(lo==hi){BSTs.add(new TreeNode(lo));return BSTs;} //递归边界\n        for(int i=lo;i&lt;=hi;i++){\n            List&lt;TreeNode&gt; leftList=generate(lo,i-1);\n            List&lt;TreeNode&gt; rightList=generate(i+1,hi); //分别取得左右子树的递归结果\n            for(TreeNode leftRoot:leftList){\n                for(TreeNode rightRoot:rightList){    \n                    TreeNode root=new TreeNode(i);//root应该在循环体内new，否则会和上一轮的混淆\n                    root.left=leftRoot;\n                    root.right=rightRoot;\n                    BSTs.add(root);\n                }\n            }\n        }\n        return BSTs;\n    }\n}\n</code></pre>\n<h2 id=\"解法二：记忆化递归-v2\">解法二：记忆化递归</h2>\n<p class=\"code-caption\" data-lang=\"java\" data-line_number=\"frontend\" data-trim_indent=\"backend\" data-label_position=\"outer\" data-labels_left=\"Code\" data-labels_right=\":\" data-labels_copy=\"Copy Code\"><span class=\"code-caption-label\"></span></p>\n<pre><code class=\"language-java\">//这是啥?\n</code></pre>\n<h1 id=\"105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal\"><a href=\"https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/\" target=\"_blank\" rel=\"noopener\">105. Construct Binary Tree from Preorder and Inorder Traversal</a></h1>\n<p><img src=\"image-20200227000418519.png\" alt=\"image-20200227000418519\"></p>\n<h2 id=\"解法一：递归法-v4\">解法一：递归法</h2>\n<p>这题的重点是如何分别在inorder和preorder中划分左右子树</p>\n<ul>\n<li><strong>preorder的头部是root</strong></li>\n<li>**inorder如何划分：**在inorder中找到root，那么在此之前的为left，之后的为right</li>\n<li>**preorder如何划分：**inorder中，left-root即为left的长度leftSize，由此推出以下关系</li>\n</ul>\n<p class=\"code-caption\" data-lang=\"java\" data-line_number=\"frontend\" data-trim_indent=\"backend\" data-label_position=\"outer\" data-labels_left=\"Code\" data-labels_right=\":\" data-labels_copy=\"Copy Code\"><span class=\"code-caption-label\"></span></p>\n<pre><code class=\"language-java\">//左子树\nnext_p_lo=p_lo+1;\nnext_p_hi=p_lo+leftSize;\nnext_i_lo=i_lo;\nnext_i_hi=i_lo+leftSize+1;\n//右子树\nnext_p_lo=p_lo+leftSize+1;\nnext_p_hi=p_hi;\nnext_i_lo=i_lo+leftSize+1;\nnext_i_hi=p_hi;\n</code></pre>\n<pre><code class=\"language-java\">class Solution {\n    public TreeNode buildTree(int[] preorder, int[] inorder) {\n        int len=preorder.length-1;\n        return build(preorder,inorder,0,len,0,len);\n    }\n\n    public TreeNode build(int[] preorder,int[] inorder,int p_lo,int p_hi,int i_lo,int i_hi){\n        if(p_lo&gt;p_hi || i_lo&gt;i_hi){return null;} //越界判定 &amp; 递归结束\n        int leftSize=0;\n        for(int i=i_lo;i&lt;=i_hi;i++){ //在inorder中找到root并算出leftSize\n            if(inorder[i]==preorder[p_lo]){leftSize=i-i_lo;}\n        }\n        TreeNode root=new TreeNode(preorder[p_lo]); //依据已有关系，构造根节点和左右子树\n        root.left=build(preorder,inorder,p_lo+1,p_lo+leftSize,i_lo,i_lo+leftSize-1);\n        root.right=build(preorder,inorder,p_lo+leftSize+1,p_hi,i_lo+leftSize+1,i_hi);\n        return root;\n    }\n}\n&lt;p class=&quot;code-caption&quot; data-lang=&quot;&quot; data-line_number=&quot;frontend&quot; data-trim_indent=&quot;backend&quot; data-label_position=&quot;outer&quot; data-labels_left=&quot;Code&quot; data-labels_right=&quot;:&quot; data-labels_copy=&quot;Copy Code&quot;&gt;&lt;span class=&quot;code-caption-label&quot;&gt;&lt;/span&gt;&lt;/p&gt;\n\n</code></pre>\n<h1 id=\"98-Validate-Binary-Search-Tree\"><a href=\"https://leetcode-cn.com/problems/validate-binary-search-tree/\" target=\"_blank\" rel=\"noopener\">98. Validate Binary Search Tree</a></h1>\n<p><img src=\"image-20200227000435747.png\" alt=\"image-20200227000435747\"></p>\n<h2 id=\"解法一：中序遍历\">解法一：中序遍历</h2>\n<p>判断BST，<strong>容易简单认为是</strong>只要左子树比根节点小，右子树比根节点大，以此递归就行</p>\n<p>但是，上述策略忽略了一点：<mark>左子树&lt;右子树</mark></p>\n<p>因此必须保证这一点，考虑到<mark>BST的特性：中序遍历</mark>，得出以下解法</p>\n<pre><code class=\"language-java\">class Solution {\n    List&lt;Integer&gt; inorder=new ArrayList&lt;Integer&gt;();\n    public boolean isValidBST(TreeNode root) {\n        inorder(root);\n        for(int i=1;i&lt;inorder.size();i++){ //检查中序遍历结果是否顺序即可\n            if(inorder.get(i)&lt;=inorder.get(i-1))return false;\n        }\n        return true;\n    }\n\n    public void inorder(TreeNode root){\n        if(root!=null){\n            inorder(root.left);\n            inorder.add(root.val);\n            inorder(root.right);\n        }\n    }\n}\n</code></pre>\n<h2 id=\"解法二：迭代法-v2\">解法二：迭代法</h2>\n<p>边迭代边检查，还可以写成递归法，不过同理就不写了</p>\n<p class=\"code-caption\" data-lang=\"java\" data-line_number=\"frontend\" data-trim_indent=\"backend\" data-label_position=\"outer\" data-labels_left=\"Code\" data-labels_right=\":\" data-labels_copy=\"Copy Code\"><span class=\"code-caption-label\"></span></p>\n<pre><code class=\"language-java\">class Solution {\n    Stack&lt;TreeNode&gt; stack=new Stack&lt;TreeNode&gt;();\n    public boolean isValidBST(TreeNode root) {\n        if(root==null)return true;\n        TreeNode curr=root;\n        Integer val=null; //注意这里要用Integer而不是int，因为可以用null,不然无论设成什么都能被卡掉\n        while(curr!=null || !stack.isEmpty()){\n            while(curr!=null){\n                stack.push(curr);\n                curr=curr.left;\n            }\n            curr=stack.pop();\n            if(val!=null &amp;&amp; curr.val&lt;=val){return false;} //错误判定\n            val=curr.val;\n            curr=curr.right;\n        }\n        return true;\n    }\n}\n</code></pre>\n","more":"<h1 id=\"94-Binary-Tree-Inorder-Traversal\"><a href=\"https://leetcode-cn.com/problems/binary-tree-inorder-traversal/\" target=\"_blank\" rel=\"noopener\">94. Binary Tree Inorder Traversal</a></h1>\n<p><img src=\"image-20200227000049240.png\" alt=\"image-20200227000049240\"></p>\n<h2 id=\"解法一：递归法\">解法一：递归法</h2>\n<p>没什么好说的，不会砍手</p>\n<p class=\"code-caption\" data-lang=\"java\" data-line_number=\"frontend\" data-trim_indent=\"backend\" data-label_position=\"outer\" data-labels_left=\"Code\" data-labels_right=\":\" data-labels_copy=\"Copy Code\"><span class=\"code-caption-label\"></span></p>\n<pre><code class=\"language-java\">class Solution {\n    List&lt;Integer&gt; inorder=new ArrayList&lt;Integer&gt;();\n    public List&lt;Integer&gt; inorderTraversal(TreeNode root) {\n        if(root!=null){\n        inorder=inorderTraversal(root.left);\n        inorder.add(root.val);\n        inorder=inorderTraversal(root.right);}\n        \n        return inorder;\n    }\n}\n</code></pre>\n<h2 id=\"解法二：迭代法\">解法二：迭代法</h2>\n<p>比递归法难理解一些，重点是理解好如何回溯</p>\n<p class=\"code-caption\" data-lang=\"java\" data-line_number=\"frontend\" data-trim_indent=\"backend\" data-label_position=\"outer\" data-labels_left=\"Code\" data-labels_right=\":\" data-labels_copy=\"Copy Code\"><span class=\"code-caption-label\"></span></p>\n<pre><code class=\"language-java\">class Solution {\n    List&lt;Integer&gt; inorder=new ArrayList&lt;Integer&gt;();\n    Stack&lt;TreeNode&gt; stack=new Stack&lt;TreeNode&gt;();\n    public List&lt;Integer&gt; inorderTraversal(TreeNode root) {\n        TreeNode curr=root; //辅助接点curr，指向当前访问的TreeNode\n        while(curr!=null || !stack.isEmpty()){ //当前访问的节点不为空或栈不为空，说明还没遍历完\n            while(curr!=null){ //不断压入左节点\n                stack.push(curr);\n                curr=curr.left;\n            }\n            curr=stack.pop(); //**回溯**\n            inorder.add(curr.val); //将当前访问的节点加入\n            curr=curr.right; //如果有右节点则访问右节点，如果没有将在下一轮回溯或者结束\n        }\n        return inorder;\n    }\n}\n</code></pre>\n<h2 id=\"解法三：-莫比斯遍历\">解法三： 莫比斯遍历</h2>\n<p class=\"code-caption\" data-lang=\"java\" data-line_number=\"frontend\" data-trim_indent=\"backend\" data-label_position=\"outer\" data-labels_left=\"Code\" data-labels_right=\":\" data-labels_copy=\"Copy Code\"><span class=\"code-caption-label\"></span></p>\n<pre><code class=\"language-java\">//待补全\n</code></pre>\n<h1 id=\"96-Unique-Binary-Search-Trees\"><a href=\"https://leetcode-cn.com/problems/unique-binary-search-trees/\" target=\"_blank\" rel=\"noopener\">96. Unique Binary Search Trees</a></h1>\n<p><img src=\"image-20200227000119239.png\" alt=\"image-20200227000119239\"></p>\n<h2 id=\"解法一：递归法-v2\">解法一：递归法</h2>\n<ul>\n<li>\n<p>**思路：**分别以1-n的任意整数为根，那么左右子树有哪些值是可以确定的，因此可以递归地来做</p>\n</li>\n<li>\n<p><strong>要点：</strong>{4,5,6,7,8}在此处可以等价于{1,2,3,4,5}，因此可以很方便的进行递归，但是在这里只是个取巧的做法</p>\n</li>\n<li>\n<p>**缺点：**没有保存递归结果，增加了许多重复的操作，下一个解法考虑对结果进行缓存</p>\n</li>\n</ul>\n<p class=\"code-caption\" data-lang=\"java\" data-line_number=\"frontend\" data-trim_indent=\"backend\" data-label_position=\"outer\" data-labels_left=\"Code\" data-labels_right=\":\" data-labels_copy=\"Copy Code\"><span class=\"code-caption-label\"></span></p>\n<pre><code class=\"language-java\">class Solution {\n    public int numTrees(int n) {\n        if(n&lt;=1)return 1; //特殊情况，以及递归的基准\n        int uniqueNum=0;\n        for(int i=1;i&lt;=n;i++){uniqueNum+=numTrees(i-1)*numTrees(n-i);} //递归左右区间的乘积\n        return uniqueNum;\n    }\n}\n</code></pre>\n<h2 id=\"解法二：记忆化递归\">解法二：记忆化递归</h2>\n<p>直接递归的缺点是重复递归很多地方，所以需要剪枝</p>\n<p class=\"code-caption\" data-lang=\"java\" data-line_number=\"frontend\" data-trim_indent=\"backend\" data-label_position=\"outer\" data-labels_left=\"Code\" data-labels_right=\":\" data-labels_copy=\"Copy Code\"><span class=\"code-caption-label\"></span></p>\n<pre><code class=\"language-java\">class Solution {\n    public int numTrees(int n) {\n        int[] dp=new int[n+1];\n        return dynamicNumTrees(n,dp);\n    }\n\n    public int dynamicNumTrees(int n,int[] dp){\n        if(n&lt;=1){return 1;}\n        if(dp[n]!=0){return dp[n];} //加入缓存\n        for(int i=1;i&lt;=n;i++){dp[n]+=dynamicNumTrees(i-1,dp)*dynamicNumTrees(n-i,dp);}\n        return dp[n];\n    }\n}\n</code></pre>\n<h1 id=\"95-Unique-Binary-Search-Trees-II\"><a href=\"https://leetcode-cn.com/problems/unique-binary-search-trees-ii/\" target=\"_blank\" rel=\"noopener\">95. Unique Binary Search Trees II</a></h1>\n<p><img src=\"image-20200227000238249.png\" alt=\"image-20200227000238249\"></p>\n<h2 id=\"解法一：递归法-v3\">解法一：递归法</h2>\n<p>和上题类似的递归思路，不过注意<mark>root的创建时机</mark></p>\n<p class=\"code-caption\" data-lang=\"java\" data-line_number=\"frontend\" data-trim_indent=\"backend\" data-label_position=\"outer\" data-labels_left=\"Code\" data-labels_right=\":\" data-labels_copy=\"Copy Code\"><span class=\"code-caption-label\"></span></p>\n<pre><code class=\"language-java\">class Solution {\n    public List&lt;TreeNode&gt; generateTrees(int n) {\n        if(n==0)return new LinkedList&lt;TreeNode&gt;(); //特殊情况\n        return generate(1,n);\n    }\n\n    public List&lt;TreeNode&gt; generate(int lo,int hi){\n        List&lt;TreeNode&gt; BSTs=new LinkedList&lt;TreeNode&gt;();     //注意ArrayList不能加入null\n        if(lo&gt;hi){BSTs.add(null);return BSTs;}              //加入null\n        if(lo==hi){BSTs.add(new TreeNode(lo));return BSTs;} //递归边界\n        for(int i=lo;i&lt;=hi;i++){\n            List&lt;TreeNode&gt; leftList=generate(lo,i-1);\n            List&lt;TreeNode&gt; rightList=generate(i+1,hi); //分别取得左右子树的递归结果\n            for(TreeNode leftRoot:leftList){\n                for(TreeNode rightRoot:rightList){    \n                    TreeNode root=new TreeNode(i);//root应该在循环体内new，否则会和上一轮的混淆\n                    root.left=leftRoot;\n                    root.right=rightRoot;\n                    BSTs.add(root);\n                }\n            }\n        }\n        return BSTs;\n    }\n}\n</code></pre>\n<h2 id=\"解法二：记忆化递归-v2\">解法二：记忆化递归</h2>\n<p class=\"code-caption\" data-lang=\"java\" data-line_number=\"frontend\" data-trim_indent=\"backend\" data-label_position=\"outer\" data-labels_left=\"Code\" data-labels_right=\":\" data-labels_copy=\"Copy Code\"><span class=\"code-caption-label\"></span></p>\n<pre><code class=\"language-java\">//这是啥?\n</code></pre>\n<h1 id=\"105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal\"><a href=\"https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/\" target=\"_blank\" rel=\"noopener\">105. Construct Binary Tree from Preorder and Inorder Traversal</a></h1>\n<p><img src=\"image-20200227000418519.png\" alt=\"image-20200227000418519\"></p>\n<h2 id=\"解法一：递归法-v4\">解法一：递归法</h2>\n<p>这题的重点是如何分别在inorder和preorder中划分左右子树</p>\n<ul>\n<li><strong>preorder的头部是root</strong></li>\n<li>**inorder如何划分：**在inorder中找到root，那么在此之前的为left，之后的为right</li>\n<li>**preorder如何划分：**inorder中，left-root即为left的长度leftSize，由此推出以下关系</li>\n</ul>\n<p class=\"code-caption\" data-lang=\"java\" data-line_number=\"frontend\" data-trim_indent=\"backend\" data-label_position=\"outer\" data-labels_left=\"Code\" data-labels_right=\":\" data-labels_copy=\"Copy Code\"><span class=\"code-caption-label\"></span></p>\n<pre><code class=\"language-java\">//左子树\nnext_p_lo=p_lo+1;\nnext_p_hi=p_lo+leftSize;\nnext_i_lo=i_lo;\nnext_i_hi=i_lo+leftSize+1;\n//右子树\nnext_p_lo=p_lo+leftSize+1;\nnext_p_hi=p_hi;\nnext_i_lo=i_lo+leftSize+1;\nnext_i_hi=p_hi;\n</code></pre>\n<pre><code class=\"language-java\">class Solution {\n    public TreeNode buildTree(int[] preorder, int[] inorder) {\n        int len=preorder.length-1;\n        return build(preorder,inorder,0,len,0,len);\n    }\n\n    public TreeNode build(int[] preorder,int[] inorder,int p_lo,int p_hi,int i_lo,int i_hi){\n        if(p_lo&gt;p_hi || i_lo&gt;i_hi){return null;} //越界判定 &amp; 递归结束\n        int leftSize=0;\n        for(int i=i_lo;i&lt;=i_hi;i++){ //在inorder中找到root并算出leftSize\n            if(inorder[i]==preorder[p_lo]){leftSize=i-i_lo;}\n        }\n        TreeNode root=new TreeNode(preorder[p_lo]); //依据已有关系，构造根节点和左右子树\n        root.left=build(preorder,inorder,p_lo+1,p_lo+leftSize,i_lo,i_lo+leftSize-1);\n        root.right=build(preorder,inorder,p_lo+leftSize+1,p_hi,i_lo+leftSize+1,i_hi);\n        return root;\n    }\n}\n&lt;p class=&quot;code-caption&quot; data-lang=&quot;&quot; data-line_number=&quot;frontend&quot; data-trim_indent=&quot;backend&quot; data-label_position=&quot;outer&quot; data-labels_left=&quot;Code&quot; data-labels_right=&quot;:&quot; data-labels_copy=&quot;Copy Code&quot;&gt;&lt;span class=&quot;code-caption-label&quot;&gt;&lt;/span&gt;&lt;/p&gt;\n\n</code></pre>\n<h1 id=\"98-Validate-Binary-Search-Tree\"><a href=\"https://leetcode-cn.com/problems/validate-binary-search-tree/\" target=\"_blank\" rel=\"noopener\">98. Validate Binary Search Tree</a></h1>\n<p><img src=\"image-20200227000435747.png\" alt=\"image-20200227000435747\"></p>\n<h2 id=\"解法一：中序遍历\">解法一：中序遍历</h2>\n<p>判断BST，<strong>容易简单认为是</strong>只要左子树比根节点小，右子树比根节点大，以此递归就行</p>\n<p>但是，上述策略忽略了一点：<mark>左子树&lt;右子树</mark></p>\n<p>因此必须保证这一点，考虑到<mark>BST的特性：中序遍历</mark>，得出以下解法</p>\n<pre><code class=\"language-java\">class Solution {\n    List&lt;Integer&gt; inorder=new ArrayList&lt;Integer&gt;();\n    public boolean isValidBST(TreeNode root) {\n        inorder(root);\n        for(int i=1;i&lt;inorder.size();i++){ //检查中序遍历结果是否顺序即可\n            if(inorder.get(i)&lt;=inorder.get(i-1))return false;\n        }\n        return true;\n    }\n\n    public void inorder(TreeNode root){\n        if(root!=null){\n            inorder(root.left);\n            inorder.add(root.val);\n            inorder(root.right);\n        }\n    }\n}\n</code></pre>\n<h2 id=\"解法二：迭代法-v2\">解法二：迭代法</h2>\n<p>边迭代边检查，还可以写成递归法，不过同理就不写了</p>\n<p class=\"code-caption\" data-lang=\"java\" data-line_number=\"frontend\" data-trim_indent=\"backend\" data-label_position=\"outer\" data-labels_left=\"Code\" data-labels_right=\":\" data-labels_copy=\"Copy Code\"><span class=\"code-caption-label\"></span></p>\n<pre><code class=\"language-java\">class Solution {\n    Stack&lt;TreeNode&gt; stack=new Stack&lt;TreeNode&gt;();\n    public boolean isValidBST(TreeNode root) {\n        if(root==null)return true;\n        TreeNode curr=root;\n        Integer val=null; //注意这里要用Integer而不是int，因为可以用null,不然无论设成什么都能被卡掉\n        while(curr!=null || !stack.isEmpty()){\n            while(curr!=null){\n                stack.push(curr);\n                curr=curr.left;\n            }\n            curr=stack.pop();\n            if(val!=null &amp;&amp; curr.val&lt;=val){return false;} //错误判定\n            val=curr.val;\n            curr=curr.right;\n        }\n        return true;\n    }\n}\n</code></pre>","categories":[{"name":"Algorithm","path":"api/categories/Algorithm.json"}],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"}]}