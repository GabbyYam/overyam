{"title":"Tree-Medium","slug":"Tree-Medium","date":"2020-02-26T15:17:10.000Z","updated":"2020-05-04T18:49:31.768Z","comments":true,"path":"api/articles/Tree-Medium.json","excerpt":"Abstract： 更新部分Medium难度 Tree相关题解","covers":["image-20200227000049240.png","image-20200227000119239.png","image-20200227000238249.png","image-20200227000418519.png","image-20200227000435747.png","image-20200503131307056.png","image-20200503142403228.png","image-20200503143559912.png","image-20200503150648854.png","image-20200504012809929.png","image-20200505024854849.png"],"content":"<link rel=\"stylesheet\" type=\"text/css\" href=\"https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css\"><div class=\".article-gallery\" <p><strong>Abstract：</strong> 更新部分<code>Medium</code>难度 <code>Tree</code>相关题解<p></p>\n<a id=\"more\"></a>\n<h1 id=\"94-Binary-Tree-Inorder-Traversal\"><a href=\"https://leetcode-cn.com/problems/binary-tree-inorder-traversal/\" target=\"_blank\" rel=\"noopener\">94. Binary Tree Inorder Traversal</a></h1>\n<p><a href=\"Tree-Medium/image-20200227000049240.png\" title=\"image-20200227000049240\" class=\"gallery-item\"><img src=\"image-20200227000049240.png\" alt=\"image-20200227000049240\"></a></p>\n<h2 id=\"解法一：递归法\">解法一：递归法</h2>\n<p>没什么好说的，不会砍手</p>\n<pre><code class=\"language-java\">class Solution {\n    List&lt;Integer&gt; inorder=new ArrayList&lt;Integer&gt;();\n    public List&lt;Integer&gt; inorderTraversal(TreeNode root) {\n        if(root!=null){\n        inorder=inorderTraversal(root.left);\n        inorder.add(root.val);\n        inorder=inorderTraversal(root.right);}\n        \n        return inorder;\n    }\n}\n</code></pre>\n<h2 id=\"解法二：迭代法\">解法二：迭代法</h2>\n<p>比递归法难理解一些，重点是理解好如何回溯</p>\n<pre><code class=\"language-java\">class Solution {\n    List&lt;Integer&gt; inorder=new ArrayList&lt;Integer&gt;();\n    Stack&lt;TreeNode&gt; stack=new Stack&lt;TreeNode&gt;();\n    public List&lt;Integer&gt; inorderTraversal(TreeNode root) {\n        TreeNode curr=root; //辅助接点curr，指向当前访问的TreeNode\n        while(curr!=null || !stack.isEmpty()){ //当前访问的节点不为空或栈不为空，说明还没遍历完\n            while(curr!=null){ //不断压入左节点\n                stack.push(curr);\n                curr=curr.left;\n            }\n            curr=stack.pop(); //**回溯**\n            inorder.add(curr.val); //将当前访问的节点加入\n            curr=curr.right; //如果有右节点则访问右节点，如果没有将在下一轮回溯或者结束\n        }\n        return inorder;\n    }\n}\n</code></pre>\n<h2 id=\"解法三：-莫比斯遍历\">解法三： 莫比斯遍历</h2>\n<pre><code class=\"language-java\">//待补全\n</code></pre>\n<h1 id=\"96-Unique-Binary-Search-Trees\"><a href=\"https://leetcode-cn.com/problems/unique-binary-search-trees/\" target=\"_blank\" rel=\"noopener\">96. Unique Binary Search Trees</a></h1>\n<p><a href=\"Tree-Medium/image-20200227000119239.png\" title=\"image-20200227000119239\" class=\"gallery-item\"><img src=\"image-20200227000119239.png\" alt=\"image-20200227000119239\"></a></p>\n<h2 id=\"解法一：递归法-v2\">解法一：递归法</h2>\n<ul>\n<li>\n<p>**思路：**分别以1-n的任意整数为根，那么左右子树有哪些值是可以确定的，因此可以递归地来做</p>\n</li>\n<li>\n<p><strong>要点：</strong>{4,5,6,7,8}在此处可以等价于{1,2,3,4,5}，因此可以很方便的进行递归，但是在这里只是个取巧的做法</p>\n</li>\n<li>\n<p>**缺点：**没有保存递归结果，增加了许多重复的操作，下一个解法考虑对结果进行缓存</p>\n</li>\n</ul>\n<pre><code class=\"language-java\">class Solution {\n    public int numTrees(int n) {\n        if(n&lt;=1)return 1; //特殊情况，以及递归的基准\n        int uniqueNum=0;\n        for(int i=1;i&lt;=n;i++){uniqueNum+=numTrees(i-1)*numTrees(n-i);} //递归左右区间的乘积\n        return uniqueNum;\n    }\n}\n</code></pre>\n<h2 id=\"解法二：记忆化递归\">解法二：记忆化递归</h2>\n<p>直接递归的缺点是重复递归很多地方，所以需要剪枝</p>\n<pre><code class=\"language-java\">class Solution {\n    public int numTrees(int n) {\n        int[] dp=new int[n+1];\n        return dynamicNumTrees(n,dp);\n    }\n\n    public int dynamicNumTrees(int n,int[] dp){\n        if(n&lt;=1){return 1;}\n        if(dp[n]!=0){return dp[n];} //加入缓存\n        for(int i=1;i&lt;=n;i++){dp[n]+=dynamicNumTrees(i-1,dp)*dynamicNumTrees(n-i,dp);}\n        return dp[n];\n    }\n}\n</code></pre>\n<h1 id=\"95-Unique-Binary-Search-Trees-II\"><a href=\"https://leetcode-cn.com/problems/unique-binary-search-trees-ii/\" target=\"_blank\" rel=\"noopener\">95. Unique Binary Search Trees II</a></h1>\n<p><a href=\"Tree-Medium/image-20200227000238249.png\" title=\"image-20200227000238249\" class=\"gallery-item\"><img src=\"image-20200227000238249.png\" alt=\"image-20200227000238249\"></a></p>\n<h2 id=\"解法一：递归法-v3\">解法一：递归法</h2>\n<p>和上题类似的递归思路，不过注意<mark>root的创建时机</mark></p>\n<pre><code class=\"language-java\">class Solution {\n    public List&lt;TreeNode&gt; generateTrees(int n) {\n        if(n==0)return new LinkedList&lt;TreeNode&gt;(); //特殊情况\n        return generate(1,n);\n    }\n\n    public List&lt;TreeNode&gt; generate(int lo,int hi){\n        List&lt;TreeNode&gt; BSTs=new LinkedList&lt;TreeNode&gt;();     //注意ArrayList不能加入null\n        if(lo&gt;hi){BSTs.add(null);return BSTs;}              //加入null\n        if(lo==hi){BSTs.add(new TreeNode(lo));return BSTs;} //递归边界\n        for(int i=lo;i&lt;=hi;i++){\n            List&lt;TreeNode&gt; leftList=generate(lo,i-1);\n            List&lt;TreeNode&gt; rightList=generate(i+1,hi); //分别取得左右子树的递归结果\n            for(TreeNode leftRoot:leftList){\n                for(TreeNode rightRoot:rightList){    \n                    TreeNode root=new TreeNode(i);//root应该在循环体内new，否则会和上一轮的混淆\n                    root.left=leftRoot;\n                    root.right=rightRoot;\n                    BSTs.add(root);\n                }\n            }\n        }\n        return BSTs;\n    }\n}\n</code></pre>\n<h2 id=\"解法二：记忆化递归-v2\">解法二：记忆化递归</h2>\n<pre><code class=\"language-java\">//这是啥?\n</code></pre>\n<h1 id=\"105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal\"><a href=\"https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/\" target=\"_blank\" rel=\"noopener\">105. Construct Binary Tree from Preorder and Inorder Traversal</a></h1>\n<p><a href=\"Tree-Medium/image-20200227000418519.png\" title=\"image-20200227000418519\" class=\"gallery-item\"><img src=\"image-20200227000418519.png\" alt=\"image-20200227000418519\"></a></p>\n<h2 id=\"解法一：递归法-v4\">解法一：递归法</h2>\n<p>这题的重点是如何分别在inorder和preorder中划分左右子树</p>\n<ul>\n<li><strong>preorder的头部是root</strong></li>\n<li>**inorder如何划分：**在inorder中找到root，那么在此之前的为left，之后的为right</li>\n<li>**preorder如何划分：**inorder中，left-root即为left的长度leftSize，由此推出以下关系</li>\n</ul>\n<pre><code class=\"language-java\">//左子树\nnext_p_lo=p_lo+1;\nnext_p_hi=p_lo+leftSize;\nnext_i_lo=i_lo;\nnext_i_hi=i_lo+leftSize+1;\n//右子树\nnext_p_lo=p_lo+leftSize+1;\nnext_p_hi=p_hi;\nnext_i_lo=i_lo+leftSize+1;\nnext_i_hi=p_hi;\n</code></pre>\n<pre><code class=\"language-java\">class Solution {\n    public TreeNode buildTree(int[] preorder, int[] inorder) {\n        int len=preorder.length-1;\n        return build(preorder,inorder,0,len,0,len);\n    }\n\n    public TreeNode build(int[] preorder,int[] inorder,int p_lo,int p_hi,int i_lo,int i_hi){\n        if(p_lo&gt;p_hi || i_lo&gt;i_hi){return null;} //越界判定 &amp; 递归结束\n        int leftSize=0;\n        for(int i=i_lo;i&lt;=i_hi;i++){ //在inorder中找到root并算出leftSize\n            if(inorder[i]==preorder[p_lo]){leftSize=i-i_lo;}\n        }\n        TreeNode root=new TreeNode(preorder[p_lo]); //依据已有关系，构造根节点和左右子树\n        root.left=build(preorder,inorder,p_lo+1,p_lo+leftSize,i_lo,i_lo+leftSize-1);\n        root.right=build(preorder,inorder,p_lo+leftSize+1,p_hi,i_lo+leftSize+1,i_hi);\n        return root;\n    }\n}\n</code></pre>\n<h1 id=\"98-Validate-Binary-Search-Tree\"><a href=\"https://leetcode-cn.com/problems/validate-binary-search-tree/\" target=\"_blank\" rel=\"noopener\">98. Validate Binary Search Tree</a></h1>\n<p><a href=\"Tree-Medium/image-20200227000435747.png\" title=\"image-20200227000435747\" class=\"gallery-item\"><img src=\"image-20200227000435747.png\" alt=\"image-20200227000435747\"></a></p>\n<h2 id=\"解法一：中序遍历\">解法一：中序遍历</h2>\n<p>判断BST，<strong>容易简单认为是</strong>只要左子树比根节点小，右子树比根节点大，以此递归就行</p>\n<p>但是，上述策略忽略了一点：<mark>左子树&lt;右子树</mark></p>\n<p>因此必须保证这一点，考虑到<mark>BST的特性：中序遍历</mark>，得出以下解法</p>\n<pre><code class=\"language-java\">class Solution {\n    List&lt;Integer&gt; inorder=new ArrayList&lt;Integer&gt;();\n    public boolean isValidBST(TreeNode root) {\n        inorder(root);\n        for(int i=1;i&lt;inorder.size();i++){ //检查中序遍历结果是否顺序即可\n            if(inorder.get(i)&lt;=inorder.get(i-1))return false;\n        }\n        return true;\n    }\n\n    public void inorder(TreeNode root){\n        if(root!=null){\n            inorder(root.left);\n            inorder.add(root.val);\n            inorder(root.right);\n        }\n    }\n}\n</code></pre>\n<h2 id=\"解法二：迭代法-v2\">解法二：迭代法</h2>\n<p>边迭代边检查，还可以写成递归法，不过同理就不写了</p>\n<pre><code class=\"language-java\">class Solution {\n    Stack&lt;TreeNode&gt; stack=new Stack&lt;TreeNode&gt;();\n    public boolean isValidBST(TreeNode root) {\n        if(root==null)return true;\n        TreeNode curr=root;\n        Integer val=null; //注意这里要用Integer而不是int，因为可以用null,不然无论设成什么都能被卡掉\n        while(curr!=null || !stack.isEmpty()){\n            while(curr!=null){\n                stack.push(curr);\n                curr=curr.left;\n            }\n            curr=stack.pop();\n            if(val!=null &amp;&amp; curr.val&lt;=val){return false;} //错误判定\n            val=curr.val;\n            curr=curr.right;\n        }\n        return true;\n    }\n}\n</code></pre>\n<h1 id=\"102-Binary-Tree-Level-Order-Traversal\"><a href=\"https://leetcode-cn.com/problems/binary-tree-level-order-traversal/\" target=\"_blank\" rel=\"noopener\">102. Binary Tree Level Order Traversal</a></h1>\n<p><a href=\"Tree-Medium/image-20200503131307056.png\" title=\"image-20200503131307056\" class=\"gallery-item\"><img src=\"image-20200503131307056.png\" alt=\"image-20200503131307056\"></a></p>\n<h2 id=\"解法一：队列\">解法一：队列</h2>\n<p>标准层次遍历</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) {\n        if(root == NULL) return {};\n        std::queue&lt;TreeNode*&gt; q;\n        q.push(root);\n        vector&lt;int&gt; tmp;\n        vector&lt;vector&lt;int&gt;&gt; res;\n        while(!q.empty()){\n            int len = q.size();\n            for(int i = 0; i &lt; len; i++){\n                TreeNode* curr = q.front(); q.pop();\n                tmp.push_back(curr-&gt;val);\n                if(curr-&gt;left)  q.push(curr-&gt;left);\n                if(curr-&gt;right) q.push(curr-&gt;right);\n            }\n            res.push_back(tmp);\n            tmp.clear();\n        }\n        return res;\n    }\n};\n</code></pre>\n<h1 id=\"103-Binary-Tree-Zigzag-Level-Order-Traversal\"><a href=\"https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/\" target=\"_blank\" rel=\"noopener\">103. Binary Tree Zigzag Level Order Traversal</a></h1>\n<p><a href=\"Tree-Medium/image-20200503142403228.png\" title=\"image-20200503142403228\" class=\"gallery-item\"><img src=\"image-20200503142403228.png\" alt=\"image-20200503142403228\"></a></p>\n<h2 id=\"解法一：队列-v2\">解法一：队列</h2>\n<p>同上题，但是要求每一层反转顺序，因此</p>\n<ul>\n<li>如果从左往右，那么同上题</li>\n<li>如果从右往左，从队列尾端取节点，并且对应子节点逆序送入队首</li>\n</ul>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    vector&lt;vector&lt;int&gt;&gt; zigzagLevelOrder(TreeNode* root) {\n        if(root == NULL) return {};\n        deque&lt;TreeNode*&gt; q; q.push_back(root);\n        vector&lt;int&gt; tmp; vector&lt;vector&lt;int&gt;&gt; res;\n        bool left = true;\n        while(!q.empty()){\n            int len = q.size();\n            for(int i = 0; i &lt; len; i++){\n                TreeNode* curr;\n                if(left) {\n                    curr = q.front(); q.pop_front();\n                    if(curr-&gt;left)  q.push_back(curr-&gt;left);\n                    if(curr-&gt;right) q.push_back(curr-&gt;right);\n                }\n                else {\n                    curr = q.back(); q.pop_back();\n                    if(curr-&gt;right) q.push_front(curr-&gt;right);\n                    if(curr-&gt;left)  q.push_front(curr-&gt;left);\n                }\n                tmp.push_back(curr-&gt;val);\n            }\n            res.push_back(tmp);\n            tmp.clear();\n            left = !left;\n        }\n        return res;\n    }\n};\n</code></pre>\n<h1 id=\"113-Path-Sum-II\"><a href=\"https://leetcode-cn.com/problems/path-sum-ii/\" target=\"_blank\" rel=\"noopener\">113. Path Sum II</a></h1>\n<p><a href=\"Tree-Medium/image-20200503143559912.png\" title=\"image-20200503143559912\" class=\"gallery-item\"><img src=\"image-20200503143559912.png\" alt=\"image-20200503143559912\"></a></p>\n<h2 id=\"解法一：递归法-v5\">解法一：递归法</h2>\n<p>递归就完了，和Ⅰ完全一样</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    vector&lt;vector&lt;int&gt;&gt; res;\n    vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int sum) {\n        vector&lt;int&gt; tmp;\n        findSum(root, sum, tmp);\n        return res;\n    }\n\n    void findSum(TreeNode* root, int sum, vector&lt;int&gt; tmp){\n        if(root == NULL) return;\n        sum -= root-&gt;val;\n        tmp.push_back(root-&gt;val);\n        if(sum == 0 &amp;&amp; !root-&gt;left &amp;&amp; !root-&gt;right){\n            res.push_back(tmp);\n            return;\n        }\n        findSum(root-&gt;left, sum, tmp);\n        findSum(root-&gt;right, sum, tmp);\n        return;\n    }\n};\n</code></pre>\n<h1 id=\"114-Flatten-Binary-Tree-to-Linked-List\"><a href=\"https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/\" target=\"_blank\" rel=\"noopener\">114. Flatten Binary Tree to Linked List</a></h1>\n<p><a href=\"Tree-Medium/image-20200503150648854.png\" title=\"image-20200503150648854\" class=\"gallery-item\"><img src=\"image-20200503150648854.png\" alt=\"image-20200503150648854\"></a></p>\n<h2 id=\"解法一：递归法-v6\">解法一：递归法</h2>\n<p>基本原则就是，把左子树删除，并接到右子树，而原来的右子树再接到新的右子树的最右处，递归展开左右子树</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    void flatten(TreeNode* root) {\n        if(root == NULL || (!root-&gt;left &amp;&amp; !root-&gt;right)) return;\n        TreeNode* left = root-&gt;left, * right = root-&gt;right, * curr = root;\n        flatten(left);\n        flatten(right);\n        curr-&gt;left  = NULL;\n        curr-&gt;right = left;\n        while(curr-&gt;right) curr = curr-&gt;right;\n        curr-&gt;right = right;\n        return;\n    }\n};\n</code></pre>\n<h1 id=\"129-Sum-Root-to-Leaf-Numbers\"><a href=\"https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/\" target=\"_blank\" rel=\"noopener\">129. Sum Root to Leaf Numbers</a></h1>\n<p><a href=\"Tree-Medium/image-20200504012809929.png\" title=\"image-20200504012809929\" class=\"gallery-item\"><img src=\"image-20200504012809929.png\" alt=\"image-20200504012809929\"></a></p>\n<h2 id=\"解法一：递归法-v7\">解法一：递归法</h2>\n<p>同pathSum系列，先把所有pathSum算出来存到一个vector，最后再累加</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    vector&lt;int&gt; vals;\n    int sumNumbers(TreeNode* root) {\n        getSum(root, 0);\n        int sum = 0;\n        for(int i : vals)\n            sum += i;\n        return sum;\n    }\n\n    void getSum(TreeNode* root, int sum){\n        if(root == NULL) return;\n        sum = sum * 10 + root-&gt;val;\n        if(root-&gt;left == NULL &amp;&amp; root-&gt;right == NULL)\n            vals.push_back(sum);\n        getSum(root-&gt;left , sum);\n        getSum(root-&gt;right, sum);\n    }\n};\n</code></pre>\n<h1 id=\"116-Populating-Next-Right-Pointers-in-Each-Node\"><a href=\"https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/\" target=\"_blank\" rel=\"noopener\">116. Populating Next Right Pointers in Each Node</a></h1>\n<p><a href=\"Tree-Medium/image-20200505024854849.png\" title=\"image-20200505024854849\" class=\"gallery-item\"><img src=\"image-20200505024854849.png\" alt=\"image-20200505024854849\"></a></p>\n<h2 id=\"解法一：层序遍历\">解法一：层序遍历</h2>\n<p>第一想法应该就是这个了吧</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    Node* connect(Node* root) {\n        if(root == NULL) return NULL;\n        queue&lt;Node*&gt; q;\n        q.push(root);\n        while(q.size()){\n            int len = q.size();;\n            for(int i = 0; i &lt; len; i++) {\n                Node* curr = q.front(); q.pop();\n                if(i != len - 1) curr-&gt;next = q.front();\n                if(curr-&gt;left  != NULL)  q.push(curr-&gt;left);\n                if(curr-&gt;right != NULL)  q.push(curr-&gt;right);\n            }\n        }\n        return root;\n    }\n};\n</code></pre>\n</div><script src=\"https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js\"></script><script>if (typeof lightGallery !== 'undefined') {\n        var options = {\n            selector: '.gallery-item'\n        };\n        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);\n        }</script>","more":"<h1 id=\"94-Binary-Tree-Inorder-Traversal\"><a href=\"https://leetcode-cn.com/problems/binary-tree-inorder-traversal/\" target=\"_blank\" rel=\"noopener\">94. Binary Tree Inorder Traversal</a></h1>\n<p><a href=\"Tree-Medium/image-20200227000049240.png\" title=\"image-20200227000049240\" class=\"gallery-item\"><img src=\"image-20200227000049240.png\" alt=\"image-20200227000049240\"></a></p>\n<h2 id=\"解法一：递归法\">解法一：递归法</h2>\n<p>没什么好说的，不会砍手</p>\n<pre><code class=\"language-java\">class Solution {\n    List&lt;Integer&gt; inorder=new ArrayList&lt;Integer&gt;();\n    public List&lt;Integer&gt; inorderTraversal(TreeNode root) {\n        if(root!=null){\n        inorder=inorderTraversal(root.left);\n        inorder.add(root.val);\n        inorder=inorderTraversal(root.right);}\n        \n        return inorder;\n    }\n}\n</code></pre>\n<h2 id=\"解法二：迭代法\">解法二：迭代法</h2>\n<p>比递归法难理解一些，重点是理解好如何回溯</p>\n<pre><code class=\"language-java\">class Solution {\n    List&lt;Integer&gt; inorder=new ArrayList&lt;Integer&gt;();\n    Stack&lt;TreeNode&gt; stack=new Stack&lt;TreeNode&gt;();\n    public List&lt;Integer&gt; inorderTraversal(TreeNode root) {\n        TreeNode curr=root; //辅助接点curr，指向当前访问的TreeNode\n        while(curr!=null || !stack.isEmpty()){ //当前访问的节点不为空或栈不为空，说明还没遍历完\n            while(curr!=null){ //不断压入左节点\n                stack.push(curr);\n                curr=curr.left;\n            }\n            curr=stack.pop(); //**回溯**\n            inorder.add(curr.val); //将当前访问的节点加入\n            curr=curr.right; //如果有右节点则访问右节点，如果没有将在下一轮回溯或者结束\n        }\n        return inorder;\n    }\n}\n</code></pre>\n<h2 id=\"解法三：-莫比斯遍历\">解法三： 莫比斯遍历</h2>\n<pre><code class=\"language-java\">//待补全\n</code></pre>\n<h1 id=\"96-Unique-Binary-Search-Trees\"><a href=\"https://leetcode-cn.com/problems/unique-binary-search-trees/\" target=\"_blank\" rel=\"noopener\">96. Unique Binary Search Trees</a></h1>\n<p><a href=\"Tree-Medium/image-20200227000119239.png\" title=\"image-20200227000119239\" class=\"gallery-item\"><img src=\"image-20200227000119239.png\" alt=\"image-20200227000119239\"></a></p>\n<h2 id=\"解法一：递归法-v2\">解法一：递归法</h2>\n<ul>\n<li>\n<p>**思路：**分别以1-n的任意整数为根，那么左右子树有哪些值是可以确定的，因此可以递归地来做</p>\n</li>\n<li>\n<p><strong>要点：</strong>{4,5,6,7,8}在此处可以等价于{1,2,3,4,5}，因此可以很方便的进行递归，但是在这里只是个取巧的做法</p>\n</li>\n<li>\n<p>**缺点：**没有保存递归结果，增加了许多重复的操作，下一个解法考虑对结果进行缓存</p>\n</li>\n</ul>\n<pre><code class=\"language-java\">class Solution {\n    public int numTrees(int n) {\n        if(n&lt;=1)return 1; //特殊情况，以及递归的基准\n        int uniqueNum=0;\n        for(int i=1;i&lt;=n;i++){uniqueNum+=numTrees(i-1)*numTrees(n-i);} //递归左右区间的乘积\n        return uniqueNum;\n    }\n}\n</code></pre>\n<h2 id=\"解法二：记忆化递归\">解法二：记忆化递归</h2>\n<p>直接递归的缺点是重复递归很多地方，所以需要剪枝</p>\n<pre><code class=\"language-java\">class Solution {\n    public int numTrees(int n) {\n        int[] dp=new int[n+1];\n        return dynamicNumTrees(n,dp);\n    }\n\n    public int dynamicNumTrees(int n,int[] dp){\n        if(n&lt;=1){return 1;}\n        if(dp[n]!=0){return dp[n];} //加入缓存\n        for(int i=1;i&lt;=n;i++){dp[n]+=dynamicNumTrees(i-1,dp)*dynamicNumTrees(n-i,dp);}\n        return dp[n];\n    }\n}\n</code></pre>\n<h1 id=\"95-Unique-Binary-Search-Trees-II\"><a href=\"https://leetcode-cn.com/problems/unique-binary-search-trees-ii/\" target=\"_blank\" rel=\"noopener\">95. Unique Binary Search Trees II</a></h1>\n<p><a href=\"Tree-Medium/image-20200227000238249.png\" title=\"image-20200227000238249\" class=\"gallery-item\"><img src=\"image-20200227000238249.png\" alt=\"image-20200227000238249\"></a></p>\n<h2 id=\"解法一：递归法-v3\">解法一：递归法</h2>\n<p>和上题类似的递归思路，不过注意<mark>root的创建时机</mark></p>\n<pre><code class=\"language-java\">class Solution {\n    public List&lt;TreeNode&gt; generateTrees(int n) {\n        if(n==0)return new LinkedList&lt;TreeNode&gt;(); //特殊情况\n        return generate(1,n);\n    }\n\n    public List&lt;TreeNode&gt; generate(int lo,int hi){\n        List&lt;TreeNode&gt; BSTs=new LinkedList&lt;TreeNode&gt;();     //注意ArrayList不能加入null\n        if(lo&gt;hi){BSTs.add(null);return BSTs;}              //加入null\n        if(lo==hi){BSTs.add(new TreeNode(lo));return BSTs;} //递归边界\n        for(int i=lo;i&lt;=hi;i++){\n            List&lt;TreeNode&gt; leftList=generate(lo,i-1);\n            List&lt;TreeNode&gt; rightList=generate(i+1,hi); //分别取得左右子树的递归结果\n            for(TreeNode leftRoot:leftList){\n                for(TreeNode rightRoot:rightList){    \n                    TreeNode root=new TreeNode(i);//root应该在循环体内new，否则会和上一轮的混淆\n                    root.left=leftRoot;\n                    root.right=rightRoot;\n                    BSTs.add(root);\n                }\n            }\n        }\n        return BSTs;\n    }\n}\n</code></pre>\n<h2 id=\"解法二：记忆化递归-v2\">解法二：记忆化递归</h2>\n<pre><code class=\"language-java\">//这是啥?\n</code></pre>\n<h1 id=\"105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal\"><a href=\"https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/\" target=\"_blank\" rel=\"noopener\">105. Construct Binary Tree from Preorder and Inorder Traversal</a></h1>\n<p><a href=\"Tree-Medium/image-20200227000418519.png\" title=\"image-20200227000418519\" class=\"gallery-item\"><img src=\"image-20200227000418519.png\" alt=\"image-20200227000418519\"></a></p>\n<h2 id=\"解法一：递归法-v4\">解法一：递归法</h2>\n<p>这题的重点是如何分别在inorder和preorder中划分左右子树</p>\n<ul>\n<li><strong>preorder的头部是root</strong></li>\n<li>**inorder如何划分：**在inorder中找到root，那么在此之前的为left，之后的为right</li>\n<li>**preorder如何划分：**inorder中，left-root即为left的长度leftSize，由此推出以下关系</li>\n</ul>\n<pre><code class=\"language-java\">//左子树\nnext_p_lo=p_lo+1;\nnext_p_hi=p_lo+leftSize;\nnext_i_lo=i_lo;\nnext_i_hi=i_lo+leftSize+1;\n//右子树\nnext_p_lo=p_lo+leftSize+1;\nnext_p_hi=p_hi;\nnext_i_lo=i_lo+leftSize+1;\nnext_i_hi=p_hi;\n</code></pre>\n<pre><code class=\"language-java\">class Solution {\n    public TreeNode buildTree(int[] preorder, int[] inorder) {\n        int len=preorder.length-1;\n        return build(preorder,inorder,0,len,0,len);\n    }\n\n    public TreeNode build(int[] preorder,int[] inorder,int p_lo,int p_hi,int i_lo,int i_hi){\n        if(p_lo&gt;p_hi || i_lo&gt;i_hi){return null;} //越界判定 &amp; 递归结束\n        int leftSize=0;\n        for(int i=i_lo;i&lt;=i_hi;i++){ //在inorder中找到root并算出leftSize\n            if(inorder[i]==preorder[p_lo]){leftSize=i-i_lo;}\n        }\n        TreeNode root=new TreeNode(preorder[p_lo]); //依据已有关系，构造根节点和左右子树\n        root.left=build(preorder,inorder,p_lo+1,p_lo+leftSize,i_lo,i_lo+leftSize-1);\n        root.right=build(preorder,inorder,p_lo+leftSize+1,p_hi,i_lo+leftSize+1,i_hi);\n        return root;\n    }\n}\n</code></pre>\n<h1 id=\"98-Validate-Binary-Search-Tree\"><a href=\"https://leetcode-cn.com/problems/validate-binary-search-tree/\" target=\"_blank\" rel=\"noopener\">98. Validate Binary Search Tree</a></h1>\n<p><a href=\"Tree-Medium/image-20200227000435747.png\" title=\"image-20200227000435747\" class=\"gallery-item\"><img src=\"image-20200227000435747.png\" alt=\"image-20200227000435747\"></a></p>\n<h2 id=\"解法一：中序遍历\">解法一：中序遍历</h2>\n<p>判断BST，<strong>容易简单认为是</strong>只要左子树比根节点小，右子树比根节点大，以此递归就行</p>\n<p>但是，上述策略忽略了一点：<mark>左子树&lt;右子树</mark></p>\n<p>因此必须保证这一点，考虑到<mark>BST的特性：中序遍历</mark>，得出以下解法</p>\n<pre><code class=\"language-java\">class Solution {\n    List&lt;Integer&gt; inorder=new ArrayList&lt;Integer&gt;();\n    public boolean isValidBST(TreeNode root) {\n        inorder(root);\n        for(int i=1;i&lt;inorder.size();i++){ //检查中序遍历结果是否顺序即可\n            if(inorder.get(i)&lt;=inorder.get(i-1))return false;\n        }\n        return true;\n    }\n\n    public void inorder(TreeNode root){\n        if(root!=null){\n            inorder(root.left);\n            inorder.add(root.val);\n            inorder(root.right);\n        }\n    }\n}\n</code></pre>\n<h2 id=\"解法二：迭代法-v2\">解法二：迭代法</h2>\n<p>边迭代边检查，还可以写成递归法，不过同理就不写了</p>\n<pre><code class=\"language-java\">class Solution {\n    Stack&lt;TreeNode&gt; stack=new Stack&lt;TreeNode&gt;();\n    public boolean isValidBST(TreeNode root) {\n        if(root==null)return true;\n        TreeNode curr=root;\n        Integer val=null; //注意这里要用Integer而不是int，因为可以用null,不然无论设成什么都能被卡掉\n        while(curr!=null || !stack.isEmpty()){\n            while(curr!=null){\n                stack.push(curr);\n                curr=curr.left;\n            }\n            curr=stack.pop();\n            if(val!=null &amp;&amp; curr.val&lt;=val){return false;} //错误判定\n            val=curr.val;\n            curr=curr.right;\n        }\n        return true;\n    }\n}\n</code></pre>\n<h1 id=\"102-Binary-Tree-Level-Order-Traversal\"><a href=\"https://leetcode-cn.com/problems/binary-tree-level-order-traversal/\" target=\"_blank\" rel=\"noopener\">102. Binary Tree Level Order Traversal</a></h1>\n<p><a href=\"Tree-Medium/image-20200503131307056.png\" title=\"image-20200503131307056\" class=\"gallery-item\"><img src=\"image-20200503131307056.png\" alt=\"image-20200503131307056\"></a></p>\n<h2 id=\"解法一：队列\">解法一：队列</h2>\n<p>标准层次遍历</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) {\n        if(root == NULL) return {};\n        std::queue&lt;TreeNode*&gt; q;\n        q.push(root);\n        vector&lt;int&gt; tmp;\n        vector&lt;vector&lt;int&gt;&gt; res;\n        while(!q.empty()){\n            int len = q.size();\n            for(int i = 0; i &lt; len; i++){\n                TreeNode* curr = q.front(); q.pop();\n                tmp.push_back(curr-&gt;val);\n                if(curr-&gt;left)  q.push(curr-&gt;left);\n                if(curr-&gt;right) q.push(curr-&gt;right);\n            }\n            res.push_back(tmp);\n            tmp.clear();\n        }\n        return res;\n    }\n};\n</code></pre>\n<h1 id=\"103-Binary-Tree-Zigzag-Level-Order-Traversal\"><a href=\"https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/\" target=\"_blank\" rel=\"noopener\">103. Binary Tree Zigzag Level Order Traversal</a></h1>\n<p><a href=\"Tree-Medium/image-20200503142403228.png\" title=\"image-20200503142403228\" class=\"gallery-item\"><img src=\"image-20200503142403228.png\" alt=\"image-20200503142403228\"></a></p>\n<h2 id=\"解法一：队列-v2\">解法一：队列</h2>\n<p>同上题，但是要求每一层反转顺序，因此</p>\n<ul>\n<li>如果从左往右，那么同上题</li>\n<li>如果从右往左，从队列尾端取节点，并且对应子节点逆序送入队首</li>\n</ul>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    vector&lt;vector&lt;int&gt;&gt; zigzagLevelOrder(TreeNode* root) {\n        if(root == NULL) return {};\n        deque&lt;TreeNode*&gt; q; q.push_back(root);\n        vector&lt;int&gt; tmp; vector&lt;vector&lt;int&gt;&gt; res;\n        bool left = true;\n        while(!q.empty()){\n            int len = q.size();\n            for(int i = 0; i &lt; len; i++){\n                TreeNode* curr;\n                if(left) {\n                    curr = q.front(); q.pop_front();\n                    if(curr-&gt;left)  q.push_back(curr-&gt;left);\n                    if(curr-&gt;right) q.push_back(curr-&gt;right);\n                }\n                else {\n                    curr = q.back(); q.pop_back();\n                    if(curr-&gt;right) q.push_front(curr-&gt;right);\n                    if(curr-&gt;left)  q.push_front(curr-&gt;left);\n                }\n                tmp.push_back(curr-&gt;val);\n            }\n            res.push_back(tmp);\n            tmp.clear();\n            left = !left;\n        }\n        return res;\n    }\n};\n</code></pre>\n<h1 id=\"113-Path-Sum-II\"><a href=\"https://leetcode-cn.com/problems/path-sum-ii/\" target=\"_blank\" rel=\"noopener\">113. Path Sum II</a></h1>\n<p><a href=\"Tree-Medium/image-20200503143559912.png\" title=\"image-20200503143559912\" class=\"gallery-item\"><img src=\"image-20200503143559912.png\" alt=\"image-20200503143559912\"></a></p>\n<h2 id=\"解法一：递归法-v5\">解法一：递归法</h2>\n<p>递归就完了，和Ⅰ完全一样</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    vector&lt;vector&lt;int&gt;&gt; res;\n    vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int sum) {\n        vector&lt;int&gt; tmp;\n        findSum(root, sum, tmp);\n        return res;\n    }\n\n    void findSum(TreeNode* root, int sum, vector&lt;int&gt; tmp){\n        if(root == NULL) return;\n        sum -= root-&gt;val;\n        tmp.push_back(root-&gt;val);\n        if(sum == 0 &amp;&amp; !root-&gt;left &amp;&amp; !root-&gt;right){\n            res.push_back(tmp);\n            return;\n        }\n        findSum(root-&gt;left, sum, tmp);\n        findSum(root-&gt;right, sum, tmp);\n        return;\n    }\n};\n</code></pre>\n<h1 id=\"114-Flatten-Binary-Tree-to-Linked-List\"><a href=\"https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/\" target=\"_blank\" rel=\"noopener\">114. Flatten Binary Tree to Linked List</a></h1>\n<p><a href=\"Tree-Medium/image-20200503150648854.png\" title=\"image-20200503150648854\" class=\"gallery-item\"><img src=\"image-20200503150648854.png\" alt=\"image-20200503150648854\"></a></p>\n<h2 id=\"解法一：递归法-v6\">解法一：递归法</h2>\n<p>基本原则就是，把左子树删除，并接到右子树，而原来的右子树再接到新的右子树的最右处，递归展开左右子树</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    void flatten(TreeNode* root) {\n        if(root == NULL || (!root-&gt;left &amp;&amp; !root-&gt;right)) return;\n        TreeNode* left = root-&gt;left, * right = root-&gt;right, * curr = root;\n        flatten(left);\n        flatten(right);\n        curr-&gt;left  = NULL;\n        curr-&gt;right = left;\n        while(curr-&gt;right) curr = curr-&gt;right;\n        curr-&gt;right = right;\n        return;\n    }\n};\n</code></pre>\n<h1 id=\"129-Sum-Root-to-Leaf-Numbers\"><a href=\"https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/\" target=\"_blank\" rel=\"noopener\">129. Sum Root to Leaf Numbers</a></h1>\n<p><a href=\"Tree-Medium/image-20200504012809929.png\" title=\"image-20200504012809929\" class=\"gallery-item\"><img src=\"image-20200504012809929.png\" alt=\"image-20200504012809929\"></a></p>\n<h2 id=\"解法一：递归法-v7\">解法一：递归法</h2>\n<p>同pathSum系列，先把所有pathSum算出来存到一个vector，最后再累加</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    vector&lt;int&gt; vals;\n    int sumNumbers(TreeNode* root) {\n        getSum(root, 0);\n        int sum = 0;\n        for(int i : vals)\n            sum += i;\n        return sum;\n    }\n\n    void getSum(TreeNode* root, int sum){\n        if(root == NULL) return;\n        sum = sum * 10 + root-&gt;val;\n        if(root-&gt;left == NULL &amp;&amp; root-&gt;right == NULL)\n            vals.push_back(sum);\n        getSum(root-&gt;left , sum);\n        getSum(root-&gt;right, sum);\n    }\n};\n</code></pre>\n<h1 id=\"116-Populating-Next-Right-Pointers-in-Each-Node\"><a href=\"https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/\" target=\"_blank\" rel=\"noopener\">116. Populating Next Right Pointers in Each Node</a></h1>\n<p><a href=\"Tree-Medium/image-20200505024854849.png\" title=\"image-20200505024854849\" class=\"gallery-item\"><img src=\"image-20200505024854849.png\" alt=\"image-20200505024854849\"></a></p>\n<h2 id=\"解法一：层序遍历\">解法一：层序遍历</h2>\n<p>第一想法应该就是这个了吧</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    Node* connect(Node* root) {\n        if(root == NULL) return NULL;\n        queue&lt;Node*&gt; q;\n        q.push(root);\n        while(q.size()){\n            int len = q.size();;\n            for(int i = 0; i &lt; len; i++) {\n                Node* curr = q.front(); q.pop();\n                if(i != len - 1) curr-&gt;next = q.front();\n                if(curr-&gt;left  != NULL)  q.push(curr-&gt;left);\n                if(curr-&gt;right != NULL)  q.push(curr-&gt;right);\n            }\n        }\n        return root;\n    }\n};\n</code></pre>\n<script src=\"https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js\"></script><script>if (typeof lightGallery !== 'undefined') {\n        var options = {\n            selector: '.gallery-item'\n        };\n        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);\n        }</script>","categories":[{"name":"Algorithm","path":"api/categories/Algorithm.json"}],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"}]}