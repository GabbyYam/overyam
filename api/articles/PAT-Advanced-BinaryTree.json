{"title":"PAT-Advanced BinaryTree","slug":"PAT-Advanced-BinaryTree","date":"2020-04-09T11:06:54.000Z","updated":"2020-04-19T09:10:44.571Z","comments":true,"path":"api/articles/PAT-Advanced-BinaryTree.json","excerpt":"Abstract：都挺简单，就是读取输入就占了一大半内容","covers":["image-20200409191044003.png","image-20200410204712369.png","image-20200411002910741.png","image-20200411002922767.png","image-20200411012519511.png","image-20200411012534482.png","image-20200411153127602.png","image-20200417230626586.png","image-20200419164928677.png"],"content":"<link rel=\"stylesheet\" type=\"text/css\" href=\"https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css\"><div class=\".article-gallery\" <p><strong>Abstract</strong>：都挺简单，就是读取输入就占了一大半内容<p></p>\n<a id=\"more\"></a>\n<h1 id=\"1115-Counting-Nodes-in-a-BST-30分\"><a href=\"https://pintia.cn/problem-sets/994805342720868352/problems/994805355987451904\" target=\"_blank\" rel=\"noopener\">1115 Counting Nodes in a BST (30分)</a></h1>\n<p><a href=\"PAT-Advanced-BinaryTree/image-20200409191044003.png\" title=\"image-20200409191044003\" class=\"gallery-item\"><img src=\"image-20200409191044003.png\" alt=\"image-20200409191044003\"></a></p>\n<h2 id=\"解法一\">解法一</h2>\n<p>觉得应该有更快更方便的方法，但是暂时没想到</p>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\n#include&lt;algorithm&gt;\n\nstruct TreeNode {\n\tint val;\n\tTreeNode* left, * right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {} \n} * bst;\n\nint num, val, n1 = 0, n2 = 0;\n\nvoid insert(TreeNode* curr, TreeNode* node) {\n\tif (!curr) return;\n\tif (node-&gt;val &lt;= curr-&gt;val) {\n\t\tif (!curr-&gt;left) curr-&gt;left = node;\n\t\telse insert(curr-&gt;left, node);\n\t}\n\telse {\n\t\tif (!curr-&gt;right) curr-&gt;right = node;\n\t\telse insert(curr-&gt;right, node);\n\t}\n}\n\nvoid parseInput() {\n\tstd::cin &gt;&gt; num;\n\tstd::cin &gt;&gt; val;\n\tbst = new TreeNode(val);\n\tfor (int i = 1; i &lt; num; i++) {\n\t\tstd::cin &gt;&gt; val;\n\t\tTreeNode* node = new TreeNode(val);\n\t\tinsert(bst, node);\n\t}\n}\n\nint maxDepth(TreeNode* root, int depth, int maxdepth) { // 获取最大深度，才能知道哪层是最后一层和倒数第二层\n\tif (!root) return maxdepth;\n\tint left = maxDepth(root-&gt;left, depth+1, maxdepth);\n\tint right = maxDepth(root-&gt;right, depth+1, maxdepth);\n\tint maxchild = std::max(left, right);\n\tmaxdepth = std::max(maxchild, depth);\n\treturn maxdepth;\n}\n\t\nvoid countLastTwoRow(TreeNode* root, int depth, int maxdepth) { // 计数\n\tif (root == NULL) return;\n\tcountLastTwoRow(root-&gt;left, depth+1, maxdepth);\n\tif (depth == maxdepth) n1++;\n\tif (depth == maxdepth - 1) n2++;\n\tcountLastTwoRow(root-&gt;right, depth+1, maxdepth);\n}\n\nint main() {\n\tparseInput();\n\tint maxdepth = maxDepth(bst, 0, 0);\n\t// std::cout &lt;&lt; maxdepth &lt;&lt; std::endl;\n\tcountLastTwoRow(bst, 0, maxdepth);\n\tstd::cout &lt;&lt; n1 &lt;&lt; &quot; + &quot; &lt;&lt; n2 &lt;&lt; &quot; = &quot; &lt;&lt; n1 + n2;\n}\n</code></pre>\n<h1 id=\"1020-Tree-Traversals-25分\"><a href=\"https://pintia.cn/problem-sets/994805342720868352/problems/994805485033603072\" target=\"_blank\" rel=\"noopener\">1020 Tree Traversals (25分)</a></h1>\n<p><a href=\"PAT-Advanced-BinaryTree/image-20200410204712369.png\" title=\"image-20200410204712369\" class=\"gallery-item\"><img src=\"image-20200410204712369.png\" alt=\"image-20200410204712369\"></a></p>\n<h2 id=\"解法一：常规方法\">解法一：常规方法</h2>\n<p>先由中后序遍历生成树，再层序遍历</p>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\n#include&lt;vector&gt;\n#include&lt;queue&gt;\n\nstruct TreeNode {\n\tint val;\n\tTreeNode* left, * right;\n\tTreeNode(int x) :val(x), left(NULL), right(NULL) {}\n} *root;\n\nint num;\nstd::vector&lt;int&gt; postorder, inorder;\n\nvoid parseInput() {\n\tstd::cin &gt;&gt; num;\n\tpostorder = std::vector&lt;int&gt;(num);\n\tinorder = std::vector&lt;int&gt;(num);\n\tfor (int i = 0; i &lt; num; i++) std::cin &gt;&gt; postorder[i];\n\tfor (int i = 0; i &lt; num; i++) std::cin &gt;&gt; inorder[i];\n}\n\nTreeNode* genBinaryTree(int p_lo, int p_hi, int i_lo, int i_hi) {\n\tif (p_lo &gt; p_hi || i_lo &gt; i_hi) return NULL;    //越界判定 &amp; 递归结束\n\tint left_size = 0;\n\tfor (int i = i_lo; i &lt;= i_hi; i++)              //在inorder中找到root并算出left_size\n\t\tif (inorder[i] == postorder[p_hi]) left_size = i - i_lo;\n\n\tTreeNode* root = new TreeNode(postorder[p_hi]); //依据已有关系，构造根节点和左右子树\n\troot-&gt;left = genBinaryTree(p_lo, p_lo + left_size - 1, i_lo, i_lo + left_size - 1);\n\troot-&gt;right = genBinaryTree(p_lo + left_size, p_hi - 1, i_lo + left_size + 1, i_hi);\n\treturn root;\n}\n\nvoid levelOrder(TreeNode* root) {\n\tif (root == NULL) return;\n\tstd::queue&lt;TreeNode&gt; q = std::queue&lt;TreeNode&gt;();\n\tq.push(*root);\n\twhile (!q.empty()) {\n\t\tTreeNode curr = q.front(); q.pop();\n\t\tif (curr.left != NULL) q.push(*curr.left);\n\t\tif (curr.right != NULL) q.push(*curr.right);\n\t\tif (!q.empty()) std::cout &lt;&lt; curr.val &lt;&lt; &quot; &quot;;\n\t\telse std::cout &lt;&lt; curr.val; // 左右子树都为空且队列为空，说明是最后一个节点了\n\t}\n}\n\nint main() {\n\tparseInput();\n\troot = genBinaryTree(0, num - 1, 0, num - 1);\n\tlevelOrder(root);\n}\n</code></pre>\n<h2 id=\"解法二：静态树\">解法二：静态树</h2>\n<p>不构造树，而是用一个超大数组来对应树的节点，也就是树的顺序存储，当然，是稀疏的</p>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\n#include&lt;vector&gt;\n\nint num;\nstd::vector&lt;int&gt; postorder, inorder, levelorder;\n\nvoid parseInput() {\n\tstd::cin &gt;&gt; num;\n\tpostorder = std::vector&lt;int&gt;(num);\n\tinorder = std::vector&lt;int&gt;(num);\n\tlevelorder = std::vector&lt;int&gt;(100000, -1);\n\tfor (int i = 0; i &lt; num; i++) std::cin &gt;&gt; postorder[i];\n\tfor (int i = 0; i &lt; num; i++) std::cin &gt;&gt; inorder[i];\n}\n\nvoid levelOrder(int root, int lo, int hi, int idx) {\n\tif (lo &gt; hi) return;\n\tint i = lo;\n\tfor (i; i &lt; hi &amp;&amp; inorder[i] != postorder[root]; i++); // 定位到root\n\tlevelorder[idx] = postorder[root];\n\tlevelOrder(root - 1 - hi + i, lo, i - 1, 2 * idx + 1); // 2*idx+1是假设是满二叉树的清况\n\tlevelOrder(root - 1, i + 1, hi, 2 * idx + 2);\n}\n\nint main() {\n\tparseInput();\n\tlevelOrder(num - 1, 0, num - 1, 0);\n\tfor (int i = 0, idx = 0; i &lt; levelorder.size(); i++) {\n\t\tif (levelorder[i] != -1 &amp;&amp; idx != num - 1) { std::cout &lt;&lt; levelorder[i] &lt;&lt; &quot; &quot;; idx++; }\n\t\telse if (levelorder[i] != -1) { std::cout &lt;&lt; levelorder[i]; break; }\n\t}\n}\n</code></pre>\n<h1 id=\"1043-Is-It-a-Binary-Search-Tree-25分\"><a href=\"https://pintia.cn/problem-sets/994805342720868352/problems/994805440976633856\" target=\"_blank\" rel=\"noopener\">1043 Is It a Binary Search Tree (25分)</a></h1>\n<p><a href=\"PAT-Advanced-BinaryTree/image-20200411002910741.png\" title=\"image-20200411002910741\" class=\"gallery-item\"><img src=\"image-20200411002910741.png\" alt=\"image-20200411002910741\"></a></p>\n<p><a href=\"PAT-Advanced-BinaryTree/image-20200411002922767.png\" title=\"image-20200411002922767\" class=\"gallery-item\"><img src=\"image-20200411002922767.png\" alt=\"image-20200411002922767\"></a></p>\n<h2 id=\"解法一-v2\">解法一</h2>\n<ul>\n<li>先判断出是升序树还是降序树，然后生成对应的BST</li>\n<li>inorder判断是否有序</li>\n<li>最后根据是否有序输出对应的结果</li>\n</ul>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\n#include&lt;vector&gt;\nstruct TreeNode {\n\tint val;\n\tTreeNode* left, * right;\n\tTreeNode(int x) :val(x), left(NULL), right(NULL) {}\n};\n\nint num, mode = 0;\nstd::vector&lt;int&gt; preorder, inorder, postorder;\n\nvoid parseInput() {\n\tstd::cin &gt;&gt; num;\n\tpreorder = std::vector&lt;int&gt;(num);\n\tfor (int i = 0; i &lt; num; i++)std::cin &gt;&gt; preorder[i];\n\tint i = 1; for (i; i &lt; num &amp;&amp; preorder[0] == preorder[i]; i++);\n\tmode = preorder[0] &lt; preorder[i] ? 1 : 0; // 找到第一个与根不等的节点进行比较，判断升序还是降序\n}\n\nbool compare(int a, int b, int mode) {\n\treturn mode == 1 ? a &gt;= b : a &lt;= b;\n}\n\nTreeNode* genBST(int lo, int hi) {\n\tif (lo &gt; hi)return NULL;\n\tint right = lo;\n\tfor (right; right &lt;= hi &amp;&amp; compare(preorder[right], preorder[lo], mode); right++); // 定位到右子树\n\tTreeNode* root = new TreeNode(preorder[lo]);\n\troot-&gt;left = genBST(lo + 1, right - 1);\n\troot-&gt;right = genBST(right, hi);\n\treturn root;\n}\n\nvoid genInOrder(TreeNode* root) {\n\tif (root == NULL) return;\n\tgenInOrder(root-&gt;left);\n\tinorder.push_back(root-&gt;val);\n\tgenInOrder(root-&gt;right);\n}\n\nvoid genPostOrder(TreeNode* root) {\n\tif (root == NULL) return;\n\tgenPostOrder(root-&gt;left);\n\tgenPostOrder(root-&gt;right);\n\tpostorder.push_back(root-&gt;val);\n}\n\nint main() {\n\tparseInput();\n\tTreeNode* root = genBST(0, num - 1);\n\tgenInOrder(root);\n\tbool res = true; // \n\tfor (int i = 1; i &lt; num; i++) if (!compare(inorder[i - 1], inorder[i], mode)) res = false;\n\t//for (int i : inorder)std::cout &lt;&lt; i &lt;&lt; &quot; &quot;;\n\tif (res == false) std::cout &lt;&lt; &quot;NO&quot;;\n\telse {\n\t\tgenPostOrder(root);\n\t\tstd::cout &lt;&lt; &quot;YES&quot; &lt;&lt; std::endl;\n\t\tfor (int i = 0; i &lt; num; i++) {\n\t\t\tif (i == num - 1)std::cout &lt;&lt; postorder[i];\n\t\t\telse std::cout &lt;&lt; postorder[i] &lt;&lt; &quot; &quot;;\n\t\t}\n\t}\n}\n</code></pre>\n<h1 id=\"1099-Build-A-Binary-Search-Tree-30分\"><a href=\"https://pintia.cn/problem-sets/994805342720868352/problems/994805367987355648\" target=\"_blank\" rel=\"noopener\">1099 Build A Binary Search Tree (30分)</a></h1>\n<p><a href=\"PAT-Advanced-BinaryTree/image-20200411012519511.png\" title=\"image-20200411012519511\" class=\"gallery-item\"><img src=\"image-20200411012519511.png\" alt=\"image-20200411012519511\"></a></p>\n<p><a href=\"PAT-Advanced-BinaryTree/image-20200411012534482.png\" title=\"image-20200411012534482\" class=\"gallery-item\"><img src=\"image-20200411012534482.png\" alt=\"image-20200411012534482\"></a></p>\n<h2 id=\"解法一：std-sort\">解法一：std::sort()</h2>\n<p>我知道这很无耻，但是爽啊！</p>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\n#include&lt;vector&gt;\n#include&lt;queue&gt;\n#include&lt;algorithm&gt;\n\nstruct TreeNode {\n\tint val, left, right;\n} tree[101];\n\nint num, left, right, index = 0;\nstd::vector&lt;int&gt; inorder;\n\nvoid parseInput() {\n\tstd::cin &gt;&gt; num;\n\tinorder = std::vector&lt;int&gt;(num);\n\tfor (int i = 0; i &lt; num; i++) {\n\t\tstd::cin &gt;&gt; left &gt;&gt; right;\n\t\ttree[i] = { -1,left,right };\n\t}\n\tfor (int i = 0; i &lt; num; i++) std::cin &gt;&gt; inorder[i];\n\tstd::sort(inorder.begin(), inorder.end());\n}\n\nvoid levelOrder(int root) {\n\tif (root == -1) return;\n\tstd::queue&lt;int&gt; q = std::queue&lt;int&gt;();\n\tq.push(root);\n\twhile (!q.empty()) {\n\t\tint curr = q.front(); q.pop();\n\t\tif (tree[curr].left != -1) q.push(tree[curr].left);\n\t\tif (tree[curr].right != -1) q.push(tree[curr].right);\n\t\tif (q.empty())std::cout &lt;&lt; tree[curr].val;\n\t\telse std::cout &lt;&lt; tree[curr].val &lt;&lt; &quot; &quot;;\n\t}\n}\n\nvoid fillBST(int root) {\n\tif (root == -1) return;\n\tfillBST(tree[root].left);\n\ttree[root].val = inorder[index++];\n\tfillBST(tree[root].right);\n}\n\nint main() {\n\tparseInput();\n\tfillBST(0);\n\tlevelOrder(0);\n}\n</code></pre>\n<h3 id=\"简化版\">简化版</h3>\n<pre><code class=\"language-cpp\">\n</code></pre>\n<h1 id=\"1138-Postorder-Traversal-25分\"><a href=\"https://pintia.cn/problem-sets/994805342720868352/problems/994805345078067200\" target=\"_blank\" rel=\"noopener\">1138 Postorder Traversal (25分)</a></h1>\n<p><a href=\"PAT-Advanced-BinaryTree/image-20200411153127602.png\" title=\"image-20200411153127602\" class=\"gallery-item\"><img src=\"image-20200411153127602.png\" alt=\"image-20200411153127602\"></a></p>\n<h2 id=\"解法一-v3\">解法一</h2>\n<p>这题看起来很简单，就是个穷人版的生成后序遍历，但是实际上时间卡得非常死</p>\n<ul>\n<li>直接使用 std::cin &amp; std::cout</li>\n<li>递归没有提前结束</li>\n<li>root没有缓存而是每次都线性遍历子树部分</li>\n</ul>\n<p>以上三者任意一者均可以使部分测试点超时</p>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\n#include&lt;vector&gt;\n#include&lt;unordered_map&gt;\n\nint num, ans = 0;\nstd::vector&lt;int&gt; preorder, inorder;\nstd::unordered_map&lt;int, int&gt; map = std::unordered_map&lt;int,int&gt;();\n\nvoid parseInput() {\n\tstd::ios::sync_with_stdio(false); std::cin.tie(0);\n\tstd::cin &gt;&gt; num;\n\tpreorder = std::vector&lt;int&gt;(num);\n\tinorder = std::vector&lt;int&gt;(num);\n\tfor (int i = 0; i &lt; num; i++)std::cin &gt;&gt; preorder[i];\n\tfor (int i = 0; i &lt; num; i++) {\n\t\tstd::cin &gt;&gt; inorder[i];\n\t\tmap[inorder[i]] = i;                                // 将inorder的值索引缓存\n\t}\n}\n\nvoid genPostOrder(int p_lo, int p_hi, int i_lo, int i_hi) {\n\tif (p_lo &gt; p_hi || i_lo &gt; i_hi || ans != 0) return;\n\tint root = preorder[p_lo]; int left = map[root] - i_lo; // 直接hash取得index计算左区间\n\tgenPostOrder(p_lo + 1, p_lo + left, i_lo, i_lo + left - 1);\n\tgenPostOrder(p_lo + left + 1, p_hi, i_lo + left + 1, i_hi);\n\tif (ans == 0) { std::cout &lt;&lt; root; ans = root; }\n}\n\nint main() {\n\tparseInput();\n\tgenPostOrder(0, num - 1, 0, num - 1);\n}\n</code></pre>\n<h1 id=\"1127-ZigZagging-on-a-Tree-30分\"><a href=\"https://pintia.cn/problem-sets/994805342720868352/problems/994805349394006016\" target=\"_blank\" rel=\"noopener\">1127 ZigZagging on a Tree (30分)</a></h1>\n<p><a href=\"PAT-Advanced-BinaryTree/image-20200417230626586.png\" title=\"image-20200417230626586\" class=\"gallery-item\"><img src=\"image-20200417230626586.png\" alt=\"image-20200417230626586\"></a></p>\n<h2 id=\"解法一：BFS\">解法一：BFS</h2>\n<p>中序后序建树就不说了，基本功</p>\n<p>类似于标准的level order traversal， 中间插入NULL来区分层级，每过一层，转换一次输出顺序</p>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\n#include&lt;vector&gt;\n#include&lt;queue&gt;\n\nstruct TreeNode {\n\tint val;\n\tTreeNode* left, * right;\n\tTreeNode(int x) :val(x), left(NULL), right(NULL) {}\n};\n\nint num;\nstd::vector&lt;int&gt; inorder, postorder, zigzag;\nbool isleft = false;\n\nvoid parseInput() {\n\tstd::cin &gt;&gt; num;\n\tinorder = std::vector&lt;int&gt;(num);\n\tpostorder = std::vector&lt;int&gt;(num);\n\tfor (int i = 0; i &lt; num; i++)\n\t\tstd::cin &gt;&gt; inorder[i];\n\tfor (int i = 0; i &lt; num; i++)\n\t\tstd::cin &gt;&gt; postorder[i];\n}\n\nTreeNode* genBinaryTree(int i_lo, int i_hi, int p_lo, int p_hi) {\n\tif (i_lo &gt; i_hi || p_lo &gt; p_hi) return NULL;\n\n\tint r = postorder[p_hi], left = 0;\n\tfor (int i = i_lo; i &lt;= i_hi; i++)\n\t\tif (inorder[i] == r) left = i - i_lo;\n\n\tTreeNode* root = new TreeNode(r);\n\troot-&gt;left = genBinaryTree(i_lo, i_lo + left - 1, p_lo, p_lo + left - 1);\n\troot-&gt;right = genBinaryTree(i_lo + left + 1, i_hi, p_lo + left, p_hi - 1);\n\treturn root;\n}\n\nvoid zigZag(TreeNode* root) {\n\tstd::deque&lt;TreeNode*&gt; q;\n\tq.push_back(root);\n\tq.push_back(NULL);\n\tstd::vector&lt;std::deque&lt;TreeNode*&gt;&gt; res;\n\tstd::deque&lt;TreeNode*&gt; list;\n\twhile (!q.empty()) {\n\t\tTreeNode* curr = q.front(); q.pop_front();\n\t\tif (curr) {\n\n\t\t\tif (isleft)\n\t\t\t\tlist.push_back(curr);\n\t\t\telse\n\t\t\t\tlist.push_front(curr);\n\t\t\tif (curr-&gt;left) q.push_back(curr-&gt;left);\n\t\t\tif (curr-&gt;right) q.push_back(curr-&gt;right);\n\t\t}\n\t\telse {\n\t\t\tres.push_back(list);\n\t\t\tlist.clear();\n\t\t\tif (!q.empty())\n\t\t\t\tq.push_back(NULL);\n\t\t\tisleft = !isleft;\n\t\t}\n\t}\n\tfor (int i = 0; i &lt; res.size(); i++) {\n\t\tfor (int j = 0; j &lt; res[i].size(); j++) {\n\t\t\tif (i == res.size() - 1 &amp;&amp; j == res[i].size() - 1)\n\t\t\t\tstd::cout &lt;&lt; res[i][j]-&gt;val;\n\t\t\telse\n\t\t\t\tstd::cout &lt;&lt; res[i][j]-&gt;val &lt;&lt; &quot; &quot;;\n\t\t}\n\t}\n\n}\n\nint main() {\n\tparseInput();\n\tTreeNode* root = genBinaryTree(0, num - 1, 0, num - 1);\n\tzigZag(root);\n}\n</code></pre>\n<h1 id=\"1004-Counting-Leaves-30分\"><a href=\"https://pintia.cn/problem-sets/994805342720868352/problems/994805521431773184\" target=\"_blank\" rel=\"noopener\">1004 Counting Leaves (30分)</a></h1>\n<p><a href=\"PAT-Advanced-BinaryTree/image-20200419164928677.png\" title=\"image-20200419164928677\" class=\"gallery-item\"><img src=\"image-20200419164928677.png\" alt=\"image-20200419164928677\"></a></p>\n<h2 id=\"解法一-v4\">解法一</h2>\n<p>虽然不是二叉树，但还是放这好了/懒，作为一道30分的题有点太简单了</p>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\n#include&lt;vector&gt;\n\nint num, m, id, k, child_id;\nstd::vector&lt;int&gt; childs, res;\n\nstruct TreeNode {\n\tstd::vector&lt;int&gt; childs;\n} node[100];\n\nvoid parseInput() {\n\tstd::cin &gt;&gt; num &gt;&gt; m;\n\tfor (int i = 0; i &lt; m; i++) {\n\t\tstd::cin &gt;&gt; id &gt;&gt; k;\n\t\tfor (int i = 0; i &lt; k; i++) {\n\t\t\tstd::cin &gt;&gt; child_id;\n\t\t\tchilds.push_back(child_id);\n\t\t}\n\t\tnode[id] = { childs };\n\t\tchilds.clear();\n\t}\n}\n\nvoid tranversal(int id, int depth) {\n\twhile (depth &gt;= res.size()) res.push_back(0);\n\tif (node[id].childs.empty()) {\n\t\tres[depth]++;\n\t\treturn;\n\t}\n\tfor (int i : node[id].childs) tranversal(i, depth + 1);\n}\n\nint main() {\n\tparseInput();\n\ttranversal(01, 0);\n\tfor (int i = 0; i &lt; res.size(); i++) {\n\t\tif (i == res.size() - 1) \n\t\t\tstd::cout &lt;&lt; res[i];\n\t\telse \n\t\t\tstd::cout &lt;&lt; res[i] &lt;&lt; &quot; &quot;;\n\t}\n}\n</code></pre>\n</div><script src=\"https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js\"></script><script>if (typeof lightGallery !== 'undefined') {\n        var options = {\n            selector: '.gallery-item'\n        };\n        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);\n        }</script>","more":"<h1 id=\"1115-Counting-Nodes-in-a-BST-30分\"><a href=\"https://pintia.cn/problem-sets/994805342720868352/problems/994805355987451904\" target=\"_blank\" rel=\"noopener\">1115 Counting Nodes in a BST (30分)</a></h1>\n<p><a href=\"PAT-Advanced-BinaryTree/image-20200409191044003.png\" title=\"image-20200409191044003\" class=\"gallery-item\"><img src=\"image-20200409191044003.png\" alt=\"image-20200409191044003\"></a></p>\n<h2 id=\"解法一\">解法一</h2>\n<p>觉得应该有更快更方便的方法，但是暂时没想到</p>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\n#include&lt;algorithm&gt;\n\nstruct TreeNode {\n\tint val;\n\tTreeNode* left, * right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {} \n} * bst;\n\nint num, val, n1 = 0, n2 = 0;\n\nvoid insert(TreeNode* curr, TreeNode* node) {\n\tif (!curr) return;\n\tif (node-&gt;val &lt;= curr-&gt;val) {\n\t\tif (!curr-&gt;left) curr-&gt;left = node;\n\t\telse insert(curr-&gt;left, node);\n\t}\n\telse {\n\t\tif (!curr-&gt;right) curr-&gt;right = node;\n\t\telse insert(curr-&gt;right, node);\n\t}\n}\n\nvoid parseInput() {\n\tstd::cin &gt;&gt; num;\n\tstd::cin &gt;&gt; val;\n\tbst = new TreeNode(val);\n\tfor (int i = 1; i &lt; num; i++) {\n\t\tstd::cin &gt;&gt; val;\n\t\tTreeNode* node = new TreeNode(val);\n\t\tinsert(bst, node);\n\t}\n}\n\nint maxDepth(TreeNode* root, int depth, int maxdepth) { // 获取最大深度，才能知道哪层是最后一层和倒数第二层\n\tif (!root) return maxdepth;\n\tint left = maxDepth(root-&gt;left, depth+1, maxdepth);\n\tint right = maxDepth(root-&gt;right, depth+1, maxdepth);\n\tint maxchild = std::max(left, right);\n\tmaxdepth = std::max(maxchild, depth);\n\treturn maxdepth;\n}\n\t\nvoid countLastTwoRow(TreeNode* root, int depth, int maxdepth) { // 计数\n\tif (root == NULL) return;\n\tcountLastTwoRow(root-&gt;left, depth+1, maxdepth);\n\tif (depth == maxdepth) n1++;\n\tif (depth == maxdepth - 1) n2++;\n\tcountLastTwoRow(root-&gt;right, depth+1, maxdepth);\n}\n\nint main() {\n\tparseInput();\n\tint maxdepth = maxDepth(bst, 0, 0);\n\t// std::cout &lt;&lt; maxdepth &lt;&lt; std::endl;\n\tcountLastTwoRow(bst, 0, maxdepth);\n\tstd::cout &lt;&lt; n1 &lt;&lt; &quot; + &quot; &lt;&lt; n2 &lt;&lt; &quot; = &quot; &lt;&lt; n1 + n2;\n}\n</code></pre>\n<h1 id=\"1020-Tree-Traversals-25分\"><a href=\"https://pintia.cn/problem-sets/994805342720868352/problems/994805485033603072\" target=\"_blank\" rel=\"noopener\">1020 Tree Traversals (25分)</a></h1>\n<p><a href=\"PAT-Advanced-BinaryTree/image-20200410204712369.png\" title=\"image-20200410204712369\" class=\"gallery-item\"><img src=\"image-20200410204712369.png\" alt=\"image-20200410204712369\"></a></p>\n<h2 id=\"解法一：常规方法\">解法一：常规方法</h2>\n<p>先由中后序遍历生成树，再层序遍历</p>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\n#include&lt;vector&gt;\n#include&lt;queue&gt;\n\nstruct TreeNode {\n\tint val;\n\tTreeNode* left, * right;\n\tTreeNode(int x) :val(x), left(NULL), right(NULL) {}\n} *root;\n\nint num;\nstd::vector&lt;int&gt; postorder, inorder;\n\nvoid parseInput() {\n\tstd::cin &gt;&gt; num;\n\tpostorder = std::vector&lt;int&gt;(num);\n\tinorder = std::vector&lt;int&gt;(num);\n\tfor (int i = 0; i &lt; num; i++) std::cin &gt;&gt; postorder[i];\n\tfor (int i = 0; i &lt; num; i++) std::cin &gt;&gt; inorder[i];\n}\n\nTreeNode* genBinaryTree(int p_lo, int p_hi, int i_lo, int i_hi) {\n\tif (p_lo &gt; p_hi || i_lo &gt; i_hi) return NULL;    //越界判定 &amp; 递归结束\n\tint left_size = 0;\n\tfor (int i = i_lo; i &lt;= i_hi; i++)              //在inorder中找到root并算出left_size\n\t\tif (inorder[i] == postorder[p_hi]) left_size = i - i_lo;\n\n\tTreeNode* root = new TreeNode(postorder[p_hi]); //依据已有关系，构造根节点和左右子树\n\troot-&gt;left = genBinaryTree(p_lo, p_lo + left_size - 1, i_lo, i_lo + left_size - 1);\n\troot-&gt;right = genBinaryTree(p_lo + left_size, p_hi - 1, i_lo + left_size + 1, i_hi);\n\treturn root;\n}\n\nvoid levelOrder(TreeNode* root) {\n\tif (root == NULL) return;\n\tstd::queue&lt;TreeNode&gt; q = std::queue&lt;TreeNode&gt;();\n\tq.push(*root);\n\twhile (!q.empty()) {\n\t\tTreeNode curr = q.front(); q.pop();\n\t\tif (curr.left != NULL) q.push(*curr.left);\n\t\tif (curr.right != NULL) q.push(*curr.right);\n\t\tif (!q.empty()) std::cout &lt;&lt; curr.val &lt;&lt; &quot; &quot;;\n\t\telse std::cout &lt;&lt; curr.val; // 左右子树都为空且队列为空，说明是最后一个节点了\n\t}\n}\n\nint main() {\n\tparseInput();\n\troot = genBinaryTree(0, num - 1, 0, num - 1);\n\tlevelOrder(root);\n}\n</code></pre>\n<h2 id=\"解法二：静态树\">解法二：静态树</h2>\n<p>不构造树，而是用一个超大数组来对应树的节点，也就是树的顺序存储，当然，是稀疏的</p>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\n#include&lt;vector&gt;\n\nint num;\nstd::vector&lt;int&gt; postorder, inorder, levelorder;\n\nvoid parseInput() {\n\tstd::cin &gt;&gt; num;\n\tpostorder = std::vector&lt;int&gt;(num);\n\tinorder = std::vector&lt;int&gt;(num);\n\tlevelorder = std::vector&lt;int&gt;(100000, -1);\n\tfor (int i = 0; i &lt; num; i++) std::cin &gt;&gt; postorder[i];\n\tfor (int i = 0; i &lt; num; i++) std::cin &gt;&gt; inorder[i];\n}\n\nvoid levelOrder(int root, int lo, int hi, int idx) {\n\tif (lo &gt; hi) return;\n\tint i = lo;\n\tfor (i; i &lt; hi &amp;&amp; inorder[i] != postorder[root]; i++); // 定位到root\n\tlevelorder[idx] = postorder[root];\n\tlevelOrder(root - 1 - hi + i, lo, i - 1, 2 * idx + 1); // 2*idx+1是假设是满二叉树的清况\n\tlevelOrder(root - 1, i + 1, hi, 2 * idx + 2);\n}\n\nint main() {\n\tparseInput();\n\tlevelOrder(num - 1, 0, num - 1, 0);\n\tfor (int i = 0, idx = 0; i &lt; levelorder.size(); i++) {\n\t\tif (levelorder[i] != -1 &amp;&amp; idx != num - 1) { std::cout &lt;&lt; levelorder[i] &lt;&lt; &quot; &quot;; idx++; }\n\t\telse if (levelorder[i] != -1) { std::cout &lt;&lt; levelorder[i]; break; }\n\t}\n}\n</code></pre>\n<h1 id=\"1043-Is-It-a-Binary-Search-Tree-25分\"><a href=\"https://pintia.cn/problem-sets/994805342720868352/problems/994805440976633856\" target=\"_blank\" rel=\"noopener\">1043 Is It a Binary Search Tree (25分)</a></h1>\n<p><a href=\"PAT-Advanced-BinaryTree/image-20200411002910741.png\" title=\"image-20200411002910741\" class=\"gallery-item\"><img src=\"image-20200411002910741.png\" alt=\"image-20200411002910741\"></a></p>\n<p><a href=\"PAT-Advanced-BinaryTree/image-20200411002922767.png\" title=\"image-20200411002922767\" class=\"gallery-item\"><img src=\"image-20200411002922767.png\" alt=\"image-20200411002922767\"></a></p>\n<h2 id=\"解法一-v2\">解法一</h2>\n<ul>\n<li>先判断出是升序树还是降序树，然后生成对应的BST</li>\n<li>inorder判断是否有序</li>\n<li>最后根据是否有序输出对应的结果</li>\n</ul>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\n#include&lt;vector&gt;\nstruct TreeNode {\n\tint val;\n\tTreeNode* left, * right;\n\tTreeNode(int x) :val(x), left(NULL), right(NULL) {}\n};\n\nint num, mode = 0;\nstd::vector&lt;int&gt; preorder, inorder, postorder;\n\nvoid parseInput() {\n\tstd::cin &gt;&gt; num;\n\tpreorder = std::vector&lt;int&gt;(num);\n\tfor (int i = 0; i &lt; num; i++)std::cin &gt;&gt; preorder[i];\n\tint i = 1; for (i; i &lt; num &amp;&amp; preorder[0] == preorder[i]; i++);\n\tmode = preorder[0] &lt; preorder[i] ? 1 : 0; // 找到第一个与根不等的节点进行比较，判断升序还是降序\n}\n\nbool compare(int a, int b, int mode) {\n\treturn mode == 1 ? a &gt;= b : a &lt;= b;\n}\n\nTreeNode* genBST(int lo, int hi) {\n\tif (lo &gt; hi)return NULL;\n\tint right = lo;\n\tfor (right; right &lt;= hi &amp;&amp; compare(preorder[right], preorder[lo], mode); right++); // 定位到右子树\n\tTreeNode* root = new TreeNode(preorder[lo]);\n\troot-&gt;left = genBST(lo + 1, right - 1);\n\troot-&gt;right = genBST(right, hi);\n\treturn root;\n}\n\nvoid genInOrder(TreeNode* root) {\n\tif (root == NULL) return;\n\tgenInOrder(root-&gt;left);\n\tinorder.push_back(root-&gt;val);\n\tgenInOrder(root-&gt;right);\n}\n\nvoid genPostOrder(TreeNode* root) {\n\tif (root == NULL) return;\n\tgenPostOrder(root-&gt;left);\n\tgenPostOrder(root-&gt;right);\n\tpostorder.push_back(root-&gt;val);\n}\n\nint main() {\n\tparseInput();\n\tTreeNode* root = genBST(0, num - 1);\n\tgenInOrder(root);\n\tbool res = true; // \n\tfor (int i = 1; i &lt; num; i++) if (!compare(inorder[i - 1], inorder[i], mode)) res = false;\n\t//for (int i : inorder)std::cout &lt;&lt; i &lt;&lt; &quot; &quot;;\n\tif (res == false) std::cout &lt;&lt; &quot;NO&quot;;\n\telse {\n\t\tgenPostOrder(root);\n\t\tstd::cout &lt;&lt; &quot;YES&quot; &lt;&lt; std::endl;\n\t\tfor (int i = 0; i &lt; num; i++) {\n\t\t\tif (i == num - 1)std::cout &lt;&lt; postorder[i];\n\t\t\telse std::cout &lt;&lt; postorder[i] &lt;&lt; &quot; &quot;;\n\t\t}\n\t}\n}\n</code></pre>\n<h1 id=\"1099-Build-A-Binary-Search-Tree-30分\"><a href=\"https://pintia.cn/problem-sets/994805342720868352/problems/994805367987355648\" target=\"_blank\" rel=\"noopener\">1099 Build A Binary Search Tree (30分)</a></h1>\n<p><a href=\"PAT-Advanced-BinaryTree/image-20200411012519511.png\" title=\"image-20200411012519511\" class=\"gallery-item\"><img src=\"image-20200411012519511.png\" alt=\"image-20200411012519511\"></a></p>\n<p><a href=\"PAT-Advanced-BinaryTree/image-20200411012534482.png\" title=\"image-20200411012534482\" class=\"gallery-item\"><img src=\"image-20200411012534482.png\" alt=\"image-20200411012534482\"></a></p>\n<h2 id=\"解法一：std-sort\">解法一：std::sort()</h2>\n<p>我知道这很无耻，但是爽啊！</p>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\n#include&lt;vector&gt;\n#include&lt;queue&gt;\n#include&lt;algorithm&gt;\n\nstruct TreeNode {\n\tint val, left, right;\n} tree[101];\n\nint num, left, right, index = 0;\nstd::vector&lt;int&gt; inorder;\n\nvoid parseInput() {\n\tstd::cin &gt;&gt; num;\n\tinorder = std::vector&lt;int&gt;(num);\n\tfor (int i = 0; i &lt; num; i++) {\n\t\tstd::cin &gt;&gt; left &gt;&gt; right;\n\t\ttree[i] = { -1,left,right };\n\t}\n\tfor (int i = 0; i &lt; num; i++) std::cin &gt;&gt; inorder[i];\n\tstd::sort(inorder.begin(), inorder.end());\n}\n\nvoid levelOrder(int root) {\n\tif (root == -1) return;\n\tstd::queue&lt;int&gt; q = std::queue&lt;int&gt;();\n\tq.push(root);\n\twhile (!q.empty()) {\n\t\tint curr = q.front(); q.pop();\n\t\tif (tree[curr].left != -1) q.push(tree[curr].left);\n\t\tif (tree[curr].right != -1) q.push(tree[curr].right);\n\t\tif (q.empty())std::cout &lt;&lt; tree[curr].val;\n\t\telse std::cout &lt;&lt; tree[curr].val &lt;&lt; &quot; &quot;;\n\t}\n}\n\nvoid fillBST(int root) {\n\tif (root == -1) return;\n\tfillBST(tree[root].left);\n\ttree[root].val = inorder[index++];\n\tfillBST(tree[root].right);\n}\n\nint main() {\n\tparseInput();\n\tfillBST(0);\n\tlevelOrder(0);\n}\n</code></pre>\n<h3 id=\"简化版\">简化版</h3>\n<pre><code class=\"language-cpp\">\n</code></pre>\n<h1 id=\"1138-Postorder-Traversal-25分\"><a href=\"https://pintia.cn/problem-sets/994805342720868352/problems/994805345078067200\" target=\"_blank\" rel=\"noopener\">1138 Postorder Traversal (25分)</a></h1>\n<p><a href=\"PAT-Advanced-BinaryTree/image-20200411153127602.png\" title=\"image-20200411153127602\" class=\"gallery-item\"><img src=\"image-20200411153127602.png\" alt=\"image-20200411153127602\"></a></p>\n<h2 id=\"解法一-v3\">解法一</h2>\n<p>这题看起来很简单，就是个穷人版的生成后序遍历，但是实际上时间卡得非常死</p>\n<ul>\n<li>直接使用 std::cin &amp; std::cout</li>\n<li>递归没有提前结束</li>\n<li>root没有缓存而是每次都线性遍历子树部分</li>\n</ul>\n<p>以上三者任意一者均可以使部分测试点超时</p>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\n#include&lt;vector&gt;\n#include&lt;unordered_map&gt;\n\nint num, ans = 0;\nstd::vector&lt;int&gt; preorder, inorder;\nstd::unordered_map&lt;int, int&gt; map = std::unordered_map&lt;int,int&gt;();\n\nvoid parseInput() {\n\tstd::ios::sync_with_stdio(false); std::cin.tie(0);\n\tstd::cin &gt;&gt; num;\n\tpreorder = std::vector&lt;int&gt;(num);\n\tinorder = std::vector&lt;int&gt;(num);\n\tfor (int i = 0; i &lt; num; i++)std::cin &gt;&gt; preorder[i];\n\tfor (int i = 0; i &lt; num; i++) {\n\t\tstd::cin &gt;&gt; inorder[i];\n\t\tmap[inorder[i]] = i;                                // 将inorder的值索引缓存\n\t}\n}\n\nvoid genPostOrder(int p_lo, int p_hi, int i_lo, int i_hi) {\n\tif (p_lo &gt; p_hi || i_lo &gt; i_hi || ans != 0) return;\n\tint root = preorder[p_lo]; int left = map[root] - i_lo; // 直接hash取得index计算左区间\n\tgenPostOrder(p_lo + 1, p_lo + left, i_lo, i_lo + left - 1);\n\tgenPostOrder(p_lo + left + 1, p_hi, i_lo + left + 1, i_hi);\n\tif (ans == 0) { std::cout &lt;&lt; root; ans = root; }\n}\n\nint main() {\n\tparseInput();\n\tgenPostOrder(0, num - 1, 0, num - 1);\n}\n</code></pre>\n<h1 id=\"1127-ZigZagging-on-a-Tree-30分\"><a href=\"https://pintia.cn/problem-sets/994805342720868352/problems/994805349394006016\" target=\"_blank\" rel=\"noopener\">1127 ZigZagging on a Tree (30分)</a></h1>\n<p><a href=\"PAT-Advanced-BinaryTree/image-20200417230626586.png\" title=\"image-20200417230626586\" class=\"gallery-item\"><img src=\"image-20200417230626586.png\" alt=\"image-20200417230626586\"></a></p>\n<h2 id=\"解法一：BFS\">解法一：BFS</h2>\n<p>中序后序建树就不说了，基本功</p>\n<p>类似于标准的level order traversal， 中间插入NULL来区分层级，每过一层，转换一次输出顺序</p>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\n#include&lt;vector&gt;\n#include&lt;queue&gt;\n\nstruct TreeNode {\n\tint val;\n\tTreeNode* left, * right;\n\tTreeNode(int x) :val(x), left(NULL), right(NULL) {}\n};\n\nint num;\nstd::vector&lt;int&gt; inorder, postorder, zigzag;\nbool isleft = false;\n\nvoid parseInput() {\n\tstd::cin &gt;&gt; num;\n\tinorder = std::vector&lt;int&gt;(num);\n\tpostorder = std::vector&lt;int&gt;(num);\n\tfor (int i = 0; i &lt; num; i++)\n\t\tstd::cin &gt;&gt; inorder[i];\n\tfor (int i = 0; i &lt; num; i++)\n\t\tstd::cin &gt;&gt; postorder[i];\n}\n\nTreeNode* genBinaryTree(int i_lo, int i_hi, int p_lo, int p_hi) {\n\tif (i_lo &gt; i_hi || p_lo &gt; p_hi) return NULL;\n\n\tint r = postorder[p_hi], left = 0;\n\tfor (int i = i_lo; i &lt;= i_hi; i++)\n\t\tif (inorder[i] == r) left = i - i_lo;\n\n\tTreeNode* root = new TreeNode(r);\n\troot-&gt;left = genBinaryTree(i_lo, i_lo + left - 1, p_lo, p_lo + left - 1);\n\troot-&gt;right = genBinaryTree(i_lo + left + 1, i_hi, p_lo + left, p_hi - 1);\n\treturn root;\n}\n\nvoid zigZag(TreeNode* root) {\n\tstd::deque&lt;TreeNode*&gt; q;\n\tq.push_back(root);\n\tq.push_back(NULL);\n\tstd::vector&lt;std::deque&lt;TreeNode*&gt;&gt; res;\n\tstd::deque&lt;TreeNode*&gt; list;\n\twhile (!q.empty()) {\n\t\tTreeNode* curr = q.front(); q.pop_front();\n\t\tif (curr) {\n\n\t\t\tif (isleft)\n\t\t\t\tlist.push_back(curr);\n\t\t\telse\n\t\t\t\tlist.push_front(curr);\n\t\t\tif (curr-&gt;left) q.push_back(curr-&gt;left);\n\t\t\tif (curr-&gt;right) q.push_back(curr-&gt;right);\n\t\t}\n\t\telse {\n\t\t\tres.push_back(list);\n\t\t\tlist.clear();\n\t\t\tif (!q.empty())\n\t\t\t\tq.push_back(NULL);\n\t\t\tisleft = !isleft;\n\t\t}\n\t}\n\tfor (int i = 0; i &lt; res.size(); i++) {\n\t\tfor (int j = 0; j &lt; res[i].size(); j++) {\n\t\t\tif (i == res.size() - 1 &amp;&amp; j == res[i].size() - 1)\n\t\t\t\tstd::cout &lt;&lt; res[i][j]-&gt;val;\n\t\t\telse\n\t\t\t\tstd::cout &lt;&lt; res[i][j]-&gt;val &lt;&lt; &quot; &quot;;\n\t\t}\n\t}\n\n}\n\nint main() {\n\tparseInput();\n\tTreeNode* root = genBinaryTree(0, num - 1, 0, num - 1);\n\tzigZag(root);\n}\n</code></pre>\n<h1 id=\"1004-Counting-Leaves-30分\"><a href=\"https://pintia.cn/problem-sets/994805342720868352/problems/994805521431773184\" target=\"_blank\" rel=\"noopener\">1004 Counting Leaves (30分)</a></h1>\n<p><a href=\"PAT-Advanced-BinaryTree/image-20200419164928677.png\" title=\"image-20200419164928677\" class=\"gallery-item\"><img src=\"image-20200419164928677.png\" alt=\"image-20200419164928677\"></a></p>\n<h2 id=\"解法一-v4\">解法一</h2>\n<p>虽然不是二叉树，但还是放这好了/懒，作为一道30分的题有点太简单了</p>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\n#include&lt;vector&gt;\n\nint num, m, id, k, child_id;\nstd::vector&lt;int&gt; childs, res;\n\nstruct TreeNode {\n\tstd::vector&lt;int&gt; childs;\n} node[100];\n\nvoid parseInput() {\n\tstd::cin &gt;&gt; num &gt;&gt; m;\n\tfor (int i = 0; i &lt; m; i++) {\n\t\tstd::cin &gt;&gt; id &gt;&gt; k;\n\t\tfor (int i = 0; i &lt; k; i++) {\n\t\t\tstd::cin &gt;&gt; child_id;\n\t\t\tchilds.push_back(child_id);\n\t\t}\n\t\tnode[id] = { childs };\n\t\tchilds.clear();\n\t}\n}\n\nvoid tranversal(int id, int depth) {\n\twhile (depth &gt;= res.size()) res.push_back(0);\n\tif (node[id].childs.empty()) {\n\t\tres[depth]++;\n\t\treturn;\n\t}\n\tfor (int i : node[id].childs) tranversal(i, depth + 1);\n}\n\nint main() {\n\tparseInput();\n\ttranversal(01, 0);\n\tfor (int i = 0; i &lt; res.size(); i++) {\n\t\tif (i == res.size() - 1) \n\t\t\tstd::cout &lt;&lt; res[i];\n\t\telse \n\t\t\tstd::cout &lt;&lt; res[i] &lt;&lt; &quot; &quot;;\n\t}\n}\n</code></pre>\n<script src=\"https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js\"></script><script>if (typeof lightGallery !== 'undefined') {\n        var options = {\n            selector: '.gallery-item'\n        };\n        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);\n        }</script>","categories":[{"name":"Algorithm","path":"api/categories/Algorithm.json"}],"tags":[{"name":"PAT-A","path":"api/tags/PAT-A.json"}]}