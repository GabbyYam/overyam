{"title":"Array-Easy","slug":"Array-Easy","date":"2020-02-26T05:48:50.000Z","updated":"2020-02-27T03:25:46.190Z","comments":true,"path":"api/articles/Array-Easy.json","excerpt":"Abstract： 更新部分Easy难度 Array相关题解","covers":["image-20200226115823526.png","image-20200226144922682.png","image-20200226145029241.png","image-20200226145151262.png","image-20200226145315266.png"],"content":"<link rel=\"stylesheet\" type=\"text/css\" href=\"https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css\"><div class=\".article-gallery\" <p><strong>Abstract：</strong> 更新部分<code>Easy</code>难度 <code>Array</code>相关题解<p></p>\n<a id=\"more\"></a>\n<h1 id=\"1-Two-Sum\"><a href=\"https://leetcode-cn.com/problems/two-sum/\" target=\"_blank\" rel=\"noopener\">1. Two Sum</a></h1>\n<p><a href=\"Array-Easy/image-20200226115823526.png\" title=\"image-20200226115823526\" class=\"gallery-item\"><img src=\"image-20200226115823526.png\" alt=\"image-20200226115823526\"></a></p>\n<h2 id=\"解法一：暴力法\">解法一：暴力法</h2>\n<p>冒泡排序，送死写法，就不多说了</p>\n<h2 id=\"解法二：哈希表\">解法二：哈希表</h2>\n<p>为了最快得到target的index，HashMap是个好方法，$Time:O(n^2)  Space:O(n^2)$</p>\n<p class=\"code-caption\" data-lang=\"java\" data-line_number=\"frontend\" data-trim_indent=\"backend\" data-label_position=\"outer\" data-labels_left=\"Code\" data-labels_right=\":\" data-labels_copy=\"Copy Code\"><span class=\"code-caption-label\"></span></p>\n<pre><code class=\"language-java\">//原始版本为两遍Hash表，但是发现可以合写在一起\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map&lt;Integer,Integer&gt; map=new HashMap&lt;Integer,Integer&gt;();\n        for (int i=0;i&lt;nums.length;i++){\n            if (map.containsKey(nums[i])&amp;&amp;map.get(nums[i])!=i)\n                return new int[] {i,map.get(nums[i])//此值的index及其对应满足条件的index\n                };\n            map.put(target-nums[i],i);//不满足的话存入Map准备下一次搜索\n        }\n        throw new IllegalArgumentException(&quot;no such answer!&quot;);\n    }\n}\n</code></pre>\n<h1 id=\"83-Remove-Duplicates-from-Sorted-List\"><a href=\"https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/\" target=\"_blank\" rel=\"noopener\">83. Remove Duplicates from Sorted List</a></h1>\n<p><a href=\"Array-Easy/image-20200226144922682.png\" title=\"image-20200226144922682\" class=\"gallery-item\"><img src=\"image-20200226144922682.png\" alt=\"image-20200226144922682\"></a></p>\n<h2 id=\"解法一：双指针\">解法一：双指针</h2>\n<p class=\"code-caption\" data-lang=\"java\" data-line_number=\"frontend\" data-trim_indent=\"backend\" data-label_position=\"outer\" data-labels_left=\"Code\" data-labels_right=\":\" data-labels_copy=\"Copy Code\"><span class=\"code-caption-label\"></span></p>\n<pre><code class=\"language-java\">class Solution {\n    public int removeDuplicates(int[] nums) {\n        if(nums.length&lt;=1)return 1;//1的情况\n        int len=1;//因为第一个必定是nums[0],所以从1开始\n        for(int i=0;i&lt;nums.length-1;i++){\n            if (nums[i]!=nums[i+1]){\n                nums[len]=nums[i+1];//每找到一个新的值，放到前面对应的位置\n                len++;//更新最新前面的指针\n            }\n        }\n        return len;\n    }\n}\n</code></pre>\n<h1 id=\"27-Remove-Element\"><a href=\"https://leetcode-cn.com/problems/remove-element/\" target=\"_blank\" rel=\"noopener\">27. Remove Element</a></h1>\n<p><a href=\"Array-Easy/image-20200226145029241.png\" title=\"image-20200226145029241\" class=\"gallery-item\"><img src=\"image-20200226145029241.png\" alt=\"image-20200226145029241\"></a></p>\n<h2 id=\"解法一：我的双指针\">解法一：我的双指针</h2>\n<p>第一想到的虽然是覆盖，但还是鬼使神差得选择了交换</p>\n<ol>\n<li>从后往前找一个非val的值</li>\n<li>从前往后找一个等于val的值</li>\n<li>二者交换（交换的方法很蠢，浪费时间和空间，不如直接覆盖）</li>\n</ol>\n<p>缺点：需要考虑很多边界情况，而且还麻烦</p>\n<p class=\"code-caption\" data-lang=\"java\" data-line_number=\"frontend\" data-trim_indent=\"backend\" data-label_position=\"outer\" data-labels_left=\"Code\" data-labels_right=\":\" data-labels_copy=\"Copy Code\"><span class=\"code-caption-label\"></span></p>\n<pre><code class=\"language-java\">class Solution {\n    public int removeElement(int[] nums, int val) {\n        //考虑特殊情况，0，1,2,空\n        if(nums.length==1){\n            if(nums[0]==val)return 0;\n            else return 1;\n        }\n        int lo=0,hi=nums.length-1,count=0;\n        while(lo&lt;hi){\n            //从后往前找\n            while(nums[hi] == val){\n                hi--;\n                count++;  //目标值++\n                if(hi&lt;0){return nums.length-count;} \n                //注意如果已经找到最前面了就不要再找了，直接返回目前的结果\n            }\n            //从后往前找\n            while(lo&lt;hi &amp;&amp; nums[lo]!=val){ //注意必须满足lo&lt;hi\n                lo++;\n            }\n            //交换\n            int temp=nums[lo];\n            nums[lo]=nums[hi];\n            nums[hi]=temp;\n        }\n        return nums.length-count;\n    }\n}\n</code></pre>\n<h2 id=\"解法二：官方双指针-改\">解法二：<mark>官方双指针</mark><strong>[改]</strong></h2>\n<p>直接覆盖的方法，简单优雅</p>\n<ol>\n<li>从前往后找一个等于val的值</li>\n<li>用后排的一个值直接覆盖</li>\n</ol>\n<p class=\"code-caption\" data-lang=\"java\" data-line_number=\"frontend\" data-trim_indent=\"backend\" data-label_position=\"outer\" data-labels_left=\"Code\" data-labels_right=\":\" data-labels_copy=\"Copy Code\"><span class=\"code-caption-label\"></span></p>\n<pre><code class=\"language-java\">class Solution {\n    public int removeElement(int[] nums, int val) {\n        int lo=0,hi=nums.length;\n        while(lo&lt;hi){\n            if(nums[lo]==val){nums[lo]=nums[--hi];}//如果是val就用后面的值覆盖\n            //就算后面的值也是val也没关系，因为下一轮覆盖还是会把它覆盖掉\n            else lo++;\n        }\n        return hi;//最后返回最后一次覆盖的位置，即为删除后的长度\n    }\n}\n</code></pre>\n<h1 id=\"35-Search-Insert-Position\"><a href=\"https://leetcode-cn.com/problems/search-insert-position/\" target=\"_blank\" rel=\"noopener\">35. Search Insert Position</a></h1>\n<p><a href=\"Array-Easy/image-20200226145151262.png\" title=\"image-20200226145151262\" class=\"gallery-item\"><img src=\"image-20200226145151262.png\" alt=\"image-20200226145151262\"></a></p>\n<h2 id=\"解法一：二分查找（虽然思想简单，但是边界问题搞人）\">解法一：二分查找（虽然思想简单，但是<mark>边界问题搞人</mark>）</h2>\n<p class=\"code-caption\" data-lang=\"java\" data-line_number=\"frontend\" data-trim_indent=\"backend\" data-label_position=\"outer\" data-labels_left=\"Code\" data-labels_right=\":\" data-labels_copy=\"Copy Code\"><span class=\"code-caption-label\"></span></p>\n<pre><code class=\"language-java\">class Solution {\n    public int searchInsert(int[] nums, int target) {\n        int lo=0,hi=nums.length-1,mi=0;\n        if(target&lt;=nums[lo]){return 0;}  //小于最小值按0处理\n        if(target&gt;nums[hi]){return hi+1;} //大于最大值按length处理\n        while(lo&lt;=hi){ //注意必须是 &lt;= 否则会错过一次循环判定\n            mi=(lo+hi)/2;\n            if(target==nums[mi]){return mi;} //如果刚好相等，那返回该处索引\n            else if(target&lt;nums[mi]){hi=mi-1;} //二分查找模板\n            else if(target&gt;nums[mi]){lo=mi+1;}\n        }\n        //如果没有刚好相等的，要进行最后一轮判定\n        if(nums[mi]&lt;target)return mi+1; //小于target，要+1\n        else return mi;\n    }\n}\n</code></pre>\n<h1 id=\"53-Maximum-Subarray\"><a href=\"https://leetcode-cn.com/problems/maximum-subarray/\" target=\"_blank\" rel=\"noopener\">53. Maximum Subarray</a></h1>\n<p><a href=\"Array-Easy/image-20200226145315266.png\" title=\"image-20200226145315266\" class=\"gallery-item\"><img src=\"image-20200226145315266.png\" alt=\"image-20200226145315266\"></a></p>\n<h2 id=\"解法一：经典分治法\">解法一：经典<mark>分治法</mark></h2>\n<ol>\n<li>最大和序列可能的情况：左边界序列，右边界序列，中间序列</li>\n<li>因此先计算左右边界序列的最大值，再递归地比较中间序列，就能找到最大的子序列和</li>\n<li>时间复杂度：</li>\n</ol>\n<p class=\"code-caption\" data-lang=\"java\" data-line_number=\"frontend\" data-trim_indent=\"backend\" data-label_position=\"outer\" data-labels_left=\"Code\" data-labels_right=\":\" data-labels_copy=\"Copy Code\"><span class=\"code-caption-label\"></span></p>\n<pre><code class=\"language-java\">class Solution {\n    public int maxSubArray(int[] nums) {\n        return maxSub(nums,0,nums.length-1);\n    }\n\n    public int maxSub(int[] nums,int lo,int hi){\n        if(hi&lt;lo){return Integer.MIN_VALUE;//注意越界后要返回一个最小的值，否则无法通过负数的情况\n                 }// lo必须小于等于hi\n        \n        int maxLeft=nums[lo],maxRight=nums[hi],sumLeft=0,sumRight=0;//一些待用变量\n        \n        for(int i=lo;i&lt;=hi;i++){//找到左边界的最大和序列\n            sumLeft+=nums[i];\n            maxLeft=Math.max(sumLeft,maxLeft);\n            //if(sumLeft&gt;maxLeft){\n            //    maxLeft=sumLeft;\n            //    indexLeft=i;\n            //}\n        }\n        for(int i=hi;i&gt;=lo;i--){//找到右边界的最大和序列\n            sumRight+=nums[i];\n            maxRight=Math.max(sumRight,maxRight);\n            //if(sumRight&gt;maxRight){\n            //    maxRight=sumRight;\n            //    indexRight=i;\n            //}\n        }\n        int maxSide=Math.max(maxLeft,maxRight);\n        return Math.max(maxSide,maxSub(nums,lo+1,hi-1)); //左右边界最大和序列 与 中间和序列 比较\n    }\n}\n</code></pre>\n<h2 id=\"解法二：线性扫描\">解法二：线性扫描</h2>\n<ol>\n<li>\n<p>计算当前的和</p>\n</li>\n<li>\n<p>比较最大值</p>\n</li>\n<li>\n<p>如果当前和 小于等于0，那么和直接归零，因为前面的结果不能让后面更大了，因此也没有继续加和的必要了</p>\n</li>\n<li>\n<p>时间复杂度：$O(N)$</p>\n</li>\n</ol>\n<p class=\"code-caption\" data-lang=\"java\" data-line_number=\"frontend\" data-trim_indent=\"backend\" data-label_position=\"outer\" data-labels_left=\"Code\" data-labels_right=\":\" data-labels_copy=\"Copy Code\"><span class=\"code-caption-label\"></span></p>\n<pre><code class=\"language-java\">class Solution {\n    public int maxSubArray(int[] nums) {\n        int sum=0,max=nums[0];\n        for(int i=0;i&lt;nums.length;i++){\n            sum+=nums[i];          //计算当前和\n            max=Math.max(sum,max); //注意要先比较max，不然会导致sum=0和全负数的情况比较，结果错误\n            if(sum&lt;=0){sum=0;}     //小于0就可以滚蛋了，因为肯定没有后面的和大\n        }\n        return max;\n    }\n}\n</code></pre>\n</div><script src=\"https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js\"></script><script>if (typeof lightGallery !== 'undefined') {\n        var options = {\n            selector: '.gallery-item'\n        };\n        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);\n        }</script>","more":"<h1 id=\"1-Two-Sum\"><a href=\"https://leetcode-cn.com/problems/two-sum/\" target=\"_blank\" rel=\"noopener\">1. Two Sum</a></h1>\n<p><a href=\"Array-Easy/image-20200226115823526.png\" title=\"image-20200226115823526\" class=\"gallery-item\"><img src=\"image-20200226115823526.png\" alt=\"image-20200226115823526\"></a></p>\n<h2 id=\"解法一：暴力法\">解法一：暴力法</h2>\n<p>冒泡排序，送死写法，就不多说了</p>\n<h2 id=\"解法二：哈希表\">解法二：哈希表</h2>\n<p>为了最快得到target的index，HashMap是个好方法，$Time:O(n^2)  Space:O(n^2)$</p>\n<p class=\"code-caption\" data-lang=\"java\" data-line_number=\"frontend\" data-trim_indent=\"backend\" data-label_position=\"outer\" data-labels_left=\"Code\" data-labels_right=\":\" data-labels_copy=\"Copy Code\"><span class=\"code-caption-label\"></span></p>\n<pre><code class=\"language-java\">//原始版本为两遍Hash表，但是发现可以合写在一起\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map&lt;Integer,Integer&gt; map=new HashMap&lt;Integer,Integer&gt;();\n        for (int i=0;i&lt;nums.length;i++){\n            if (map.containsKey(nums[i])&amp;&amp;map.get(nums[i])!=i)\n                return new int[] {i,map.get(nums[i])//此值的index及其对应满足条件的index\n                };\n            map.put(target-nums[i],i);//不满足的话存入Map准备下一次搜索\n        }\n        throw new IllegalArgumentException(&quot;no such answer!&quot;);\n    }\n}\n</code></pre>\n<h1 id=\"83-Remove-Duplicates-from-Sorted-List\"><a href=\"https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/\" target=\"_blank\" rel=\"noopener\">83. Remove Duplicates from Sorted List</a></h1>\n<p><a href=\"Array-Easy/image-20200226144922682.png\" title=\"image-20200226144922682\" class=\"gallery-item\"><img src=\"image-20200226144922682.png\" alt=\"image-20200226144922682\"></a></p>\n<h2 id=\"解法一：双指针\">解法一：双指针</h2>\n<p class=\"code-caption\" data-lang=\"java\" data-line_number=\"frontend\" data-trim_indent=\"backend\" data-label_position=\"outer\" data-labels_left=\"Code\" data-labels_right=\":\" data-labels_copy=\"Copy Code\"><span class=\"code-caption-label\"></span></p>\n<pre><code class=\"language-java\">class Solution {\n    public int removeDuplicates(int[] nums) {\n        if(nums.length&lt;=1)return 1;//1的情况\n        int len=1;//因为第一个必定是nums[0],所以从1开始\n        for(int i=0;i&lt;nums.length-1;i++){\n            if (nums[i]!=nums[i+1]){\n                nums[len]=nums[i+1];//每找到一个新的值，放到前面对应的位置\n                len++;//更新最新前面的指针\n            }\n        }\n        return len;\n    }\n}\n</code></pre>\n<h1 id=\"27-Remove-Element\"><a href=\"https://leetcode-cn.com/problems/remove-element/\" target=\"_blank\" rel=\"noopener\">27. Remove Element</a></h1>\n<p><a href=\"Array-Easy/image-20200226145029241.png\" title=\"image-20200226145029241\" class=\"gallery-item\"><img src=\"image-20200226145029241.png\" alt=\"image-20200226145029241\"></a></p>\n<h2 id=\"解法一：我的双指针\">解法一：我的双指针</h2>\n<p>第一想到的虽然是覆盖，但还是鬼使神差得选择了交换</p>\n<ol>\n<li>从后往前找一个非val的值</li>\n<li>从前往后找一个等于val的值</li>\n<li>二者交换（交换的方法很蠢，浪费时间和空间，不如直接覆盖）</li>\n</ol>\n<p>缺点：需要考虑很多边界情况，而且还麻烦</p>\n<p class=\"code-caption\" data-lang=\"java\" data-line_number=\"frontend\" data-trim_indent=\"backend\" data-label_position=\"outer\" data-labels_left=\"Code\" data-labels_right=\":\" data-labels_copy=\"Copy Code\"><span class=\"code-caption-label\"></span></p>\n<pre><code class=\"language-java\">class Solution {\n    public int removeElement(int[] nums, int val) {\n        //考虑特殊情况，0，1,2,空\n        if(nums.length==1){\n            if(nums[0]==val)return 0;\n            else return 1;\n        }\n        int lo=0,hi=nums.length-1,count=0;\n        while(lo&lt;hi){\n            //从后往前找\n            while(nums[hi] == val){\n                hi--;\n                count++;  //目标值++\n                if(hi&lt;0){return nums.length-count;} \n                //注意如果已经找到最前面了就不要再找了，直接返回目前的结果\n            }\n            //从后往前找\n            while(lo&lt;hi &amp;&amp; nums[lo]!=val){ //注意必须满足lo&lt;hi\n                lo++;\n            }\n            //交换\n            int temp=nums[lo];\n            nums[lo]=nums[hi];\n            nums[hi]=temp;\n        }\n        return nums.length-count;\n    }\n}\n</code></pre>\n<h2 id=\"解法二：官方双指针-改\">解法二：<mark>官方双指针</mark><strong>[改]</strong></h2>\n<p>直接覆盖的方法，简单优雅</p>\n<ol>\n<li>从前往后找一个等于val的值</li>\n<li>用后排的一个值直接覆盖</li>\n</ol>\n<p class=\"code-caption\" data-lang=\"java\" data-line_number=\"frontend\" data-trim_indent=\"backend\" data-label_position=\"outer\" data-labels_left=\"Code\" data-labels_right=\":\" data-labels_copy=\"Copy Code\"><span class=\"code-caption-label\"></span></p>\n<pre><code class=\"language-java\">class Solution {\n    public int removeElement(int[] nums, int val) {\n        int lo=0,hi=nums.length;\n        while(lo&lt;hi){\n            if(nums[lo]==val){nums[lo]=nums[--hi];}//如果是val就用后面的值覆盖\n            //就算后面的值也是val也没关系，因为下一轮覆盖还是会把它覆盖掉\n            else lo++;\n        }\n        return hi;//最后返回最后一次覆盖的位置，即为删除后的长度\n    }\n}\n</code></pre>\n<h1 id=\"35-Search-Insert-Position\"><a href=\"https://leetcode-cn.com/problems/search-insert-position/\" target=\"_blank\" rel=\"noopener\">35. Search Insert Position</a></h1>\n<p><a href=\"Array-Easy/image-20200226145151262.png\" title=\"image-20200226145151262\" class=\"gallery-item\"><img src=\"image-20200226145151262.png\" alt=\"image-20200226145151262\"></a></p>\n<h2 id=\"解法一：二分查找（虽然思想简单，但是边界问题搞人）\">解法一：二分查找（虽然思想简单，但是<mark>边界问题搞人</mark>）</h2>\n<p class=\"code-caption\" data-lang=\"java\" data-line_number=\"frontend\" data-trim_indent=\"backend\" data-label_position=\"outer\" data-labels_left=\"Code\" data-labels_right=\":\" data-labels_copy=\"Copy Code\"><span class=\"code-caption-label\"></span></p>\n<pre><code class=\"language-java\">class Solution {\n    public int searchInsert(int[] nums, int target) {\n        int lo=0,hi=nums.length-1,mi=0;\n        if(target&lt;=nums[lo]){return 0;}  //小于最小值按0处理\n        if(target&gt;nums[hi]){return hi+1;} //大于最大值按length处理\n        while(lo&lt;=hi){ //注意必须是 &lt;= 否则会错过一次循环判定\n            mi=(lo+hi)/2;\n            if(target==nums[mi]){return mi;} //如果刚好相等，那返回该处索引\n            else if(target&lt;nums[mi]){hi=mi-1;} //二分查找模板\n            else if(target&gt;nums[mi]){lo=mi+1;}\n        }\n        //如果没有刚好相等的，要进行最后一轮判定\n        if(nums[mi]&lt;target)return mi+1; //小于target，要+1\n        else return mi;\n    }\n}\n</code></pre>\n<h1 id=\"53-Maximum-Subarray\"><a href=\"https://leetcode-cn.com/problems/maximum-subarray/\" target=\"_blank\" rel=\"noopener\">53. Maximum Subarray</a></h1>\n<p><a href=\"Array-Easy/image-20200226145315266.png\" title=\"image-20200226145315266\" class=\"gallery-item\"><img src=\"image-20200226145315266.png\" alt=\"image-20200226145315266\"></a></p>\n<h2 id=\"解法一：经典分治法\">解法一：经典<mark>分治法</mark></h2>\n<ol>\n<li>最大和序列可能的情况：左边界序列，右边界序列，中间序列</li>\n<li>因此先计算左右边界序列的最大值，再递归地比较中间序列，就能找到最大的子序列和</li>\n<li>时间复杂度：</li>\n</ol>\n<p class=\"code-caption\" data-lang=\"java\" data-line_number=\"frontend\" data-trim_indent=\"backend\" data-label_position=\"outer\" data-labels_left=\"Code\" data-labels_right=\":\" data-labels_copy=\"Copy Code\"><span class=\"code-caption-label\"></span></p>\n<pre><code class=\"language-java\">class Solution {\n    public int maxSubArray(int[] nums) {\n        return maxSub(nums,0,nums.length-1);\n    }\n\n    public int maxSub(int[] nums,int lo,int hi){\n        if(hi&lt;lo){return Integer.MIN_VALUE;//注意越界后要返回一个最小的值，否则无法通过负数的情况\n                 }// lo必须小于等于hi\n        \n        int maxLeft=nums[lo],maxRight=nums[hi],sumLeft=0,sumRight=0;//一些待用变量\n        \n        for(int i=lo;i&lt;=hi;i++){//找到左边界的最大和序列\n            sumLeft+=nums[i];\n            maxLeft=Math.max(sumLeft,maxLeft);\n            //if(sumLeft&gt;maxLeft){\n            //    maxLeft=sumLeft;\n            //    indexLeft=i;\n            //}\n        }\n        for(int i=hi;i&gt;=lo;i--){//找到右边界的最大和序列\n            sumRight+=nums[i];\n            maxRight=Math.max(sumRight,maxRight);\n            //if(sumRight&gt;maxRight){\n            //    maxRight=sumRight;\n            //    indexRight=i;\n            //}\n        }\n        int maxSide=Math.max(maxLeft,maxRight);\n        return Math.max(maxSide,maxSub(nums,lo+1,hi-1)); //左右边界最大和序列 与 中间和序列 比较\n    }\n}\n</code></pre>\n<h2 id=\"解法二：线性扫描\">解法二：线性扫描</h2>\n<ol>\n<li>\n<p>计算当前的和</p>\n</li>\n<li>\n<p>比较最大值</p>\n</li>\n<li>\n<p>如果当前和 小于等于0，那么和直接归零，因为前面的结果不能让后面更大了，因此也没有继续加和的必要了</p>\n</li>\n<li>\n<p>时间复杂度：$O(N)$</p>\n</li>\n</ol>\n<p class=\"code-caption\" data-lang=\"java\" data-line_number=\"frontend\" data-trim_indent=\"backend\" data-label_position=\"outer\" data-labels_left=\"Code\" data-labels_right=\":\" data-labels_copy=\"Copy Code\"><span class=\"code-caption-label\"></span></p>\n<pre><code class=\"language-java\">class Solution {\n    public int maxSubArray(int[] nums) {\n        int sum=0,max=nums[0];\n        for(int i=0;i&lt;nums.length;i++){\n            sum+=nums[i];          //计算当前和\n            max=Math.max(sum,max); //注意要先比较max，不然会导致sum=0和全负数的情况比较，结果错误\n            if(sum&lt;=0){sum=0;}     //小于0就可以滚蛋了，因为肯定没有后面的和大\n        }\n        return max;\n    }\n}\n</code></pre>\n<script src=\"https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js\"></script><script>if (typeof lightGallery !== 'undefined') {\n        var options = {\n            selector: '.gallery-item'\n        };\n        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);\n        }</script>","categories":[{"name":"Algorithm","path":"api/categories/Algorithm.json"}],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"}]}