{"title":"Array-Easy","slug":"Array-Easy","date":"2020-02-26T05:48:50.000Z","updated":"2020-09-26T14:36:52.782Z","comments":true,"path":"api/articles/Array-Easy.json","excerpt":"Abstract： 更新部分Easy难度 Array相关题解","covers":["image-20200226115823526.png","image-20200226144922682.png","image-20200226145029241.png","image-20200226145151262.png","image-20200226145315266.png","image-20200302231613636.png","image-20200303001955825.png","image-20200505193321501.png","image-20200517204110963.png","image-20200926221245248.png","image-20200926222308447.png"],"content":"<link rel=\"stylesheet\" type=\"text/css\" href=\"https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css\"><div class=\".article-gallery\" <p><strong>Abstract：</strong> 更新部分<code>Easy</code>难度 <code>Array</code>相关题解<p></p>\n<a id=\"more\"></a>\n<h1 id=\"1-Two-Sum\"><a href=\"https://leetcode-cn.com/problems/two-sum/\" target=\"_blank\" rel=\"noopener\">1. Two Sum</a></h1>\n<p><a href=\"Array-Easy/image-20200226115823526.png\" title=\"image-20200226115823526\" class=\"gallery-item\"><img src=\"image-20200226115823526.png\" alt=\"image-20200226115823526\"></a></p>\n<h2 id=\"解法一：暴力法\">解法一：暴力法</h2>\n<p>冒泡排序，送死写法，就不多说了</p>\n<h2 id=\"解法二：哈希表\">解法二：哈希表</h2>\n<p>为了最快得到target的index，HashMap是个好方法，$Time:O(n^2)  Space:O(n^2)$</p>\n<pre><code class=\"language-Java\">//原始版本为两遍Hash表，但是发现可以合写在一起\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map&lt;Integer,Integer&gt; map=new HashMap&lt;Integer,Integer&gt;();\n        for (int i=0;i&lt;nums.length;i++){\n            if (map.containsKey(nums[i])&amp;&amp;map.get(nums[i])!=i)\n                return new int[] {i,map.get(nums[i])//此值的index及其对应满足条件的index\n                };\n            map.put(target-nums[i],i);//不满足的话存入Map准备下一次搜索\n        }\n        throw new IllegalArgumentException(&quot;no such answer!&quot;);\n    }\n}\n</code></pre>\n<h1 id=\"83-Remove-Duplicates-from-Sorted-List\"><a href=\"https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/\" target=\"_blank\" rel=\"noopener\">83. Remove Duplicates from Sorted List</a></h1>\n<p><a href=\"Array-Easy/image-20200226144922682.png\" title=\"image-20200226144922682\" class=\"gallery-item\"><img src=\"image-20200226144922682.png\" alt=\"image-20200226144922682\"></a></p>\n<h2 id=\"解法一：双指针\">解法一：双指针</h2>\n<pre><code class=\"language-java\">class Solution {\n    public int removeDuplicates(int[] nums) {\n        if(nums.length&lt;=1)return 1;//1的情况\n        int len=1;//因为第一个必定是nums[0],所以从1开始\n        for(int i=0;i&lt;nums.length-1;i++){\n            if (nums[i]!=nums[i+1]){\n                nums[len]=nums[i+1];//每找到一个新的值，放到前面对应的位置\n                len++;//更新最新前面的指针\n            }\n        }\n        return len;\n    }\n}\n</code></pre>\n<h1 id=\"27-Remove-Element\"><a href=\"https://leetcode-cn.com/problems/remove-element/\" target=\"_blank\" rel=\"noopener\">27. Remove Element</a></h1>\n<p><a href=\"Array-Easy/image-20200226145029241.png\" title=\"image-20200226145029241\" class=\"gallery-item\"><img src=\"image-20200226145029241.png\" alt=\"image-20200226145029241\"></a></p>\n<h2 id=\"解法一：我的双指针\">解法一：我的双指针</h2>\n<p>第一想到的虽然是覆盖，但还是鬼使神差得选择了交换</p>\n<ol>\n<li>从后往前找一个非val的值</li>\n<li>从前往后找一个等于val的值</li>\n<li>二者交换（交换的方法很蠢，浪费时间和空间，不如直接覆盖）</li>\n</ol>\n<p>缺点：需要考虑很多边界情况，而且还麻烦</p>\n<pre><code class=\"language-Java\">class Solution {\n    public int removeElement(int[] nums, int val) {\n        //考虑特殊情况，0，1,2,空\n        if(nums.length==1){\n            if(nums[0]==val)return 0;\n            else return 1;\n        }\n        int lo=0,hi=nums.length-1,count=0;\n        while(lo&lt;hi){\n            //从后往前找\n            while(nums[hi] == val){\n                hi--;\n                count++;  //目标值++\n                if(hi&lt;0){return nums.length-count;} \n                //注意如果已经找到最前面了就不要再找了，直接返回目前的结果\n            }\n            //从后往前找\n            while(lo&lt;hi &amp;&amp; nums[lo]!=val){ //注意必须满足lo&lt;hi\n                lo++;\n            }\n            //交换\n            int temp=nums[lo];\n            nums[lo]=nums[hi];\n            nums[hi]=temp;\n        }\n        return nums.length-count;\n    }\n}\n</code></pre>\n<h2 id=\"解法二：官方双指针-改\">解法二：<mark>官方双指针</mark><strong>[改]</strong></h2>\n<p>直接覆盖的方法，简单优雅</p>\n<ol>\n<li>从前往后找一个等于val的值</li>\n<li>用后排的一个值直接覆盖</li>\n</ol>\n<pre><code class=\"language-Java\">class Solution {\n    public int removeElement(int[] nums, int val) {\n        int lo=0,hi=nums.length;\n        while(lo&lt;hi){\n            if(nums[lo]==val){nums[lo]=nums[--hi];}//如果是val就用后面的值覆盖\n            //就算后面的值也是val也没关系，因为下一轮覆盖还是会把它覆盖掉\n            else lo++;\n        }\n        return hi;//最后返回最后一次覆盖的位置，即为删除后的长度\n    }\n}\n</code></pre>\n<h1 id=\"35-Search-Insert-Position\"><a href=\"https://leetcode-cn.com/problems/search-insert-position/\" target=\"_blank\" rel=\"noopener\">35. Search Insert Position</a></h1>\n<p><a href=\"Array-Easy/image-20200226145151262.png\" title=\"image-20200226145151262\" class=\"gallery-item\"><img src=\"image-20200226145151262.png\" alt=\"image-20200226145151262\"></a></p>\n<h2 id=\"解法一：二分查找（虽然思想简单，但是边界问题搞人）\">解法一：二分查找（虽然思想简单，但是<mark>边界问题搞人</mark>）</h2>\n<pre><code class=\"language-java\">class Solution {\n    public int searchInsert(int[] nums, int target) {\n        int lo=0,hi=nums.length-1,mi=0;\n        if(target&lt;=nums[lo]){return 0;}  //小于最小值按0处理\n        if(target&gt;nums[hi]){return hi+1;} //大于最大值按length处理\n        while(lo&lt;=hi){ //注意必须是 &lt;= 否则会错过一次循环判定\n            mi=(lo+hi)/2;\n            if(target==nums[mi]){return mi;} //如果刚好相等，那返回该处索引\n            else if(target&lt;nums[mi]){hi=mi-1;} //二分查找模板\n            else if(target&gt;nums[mi]){lo=mi+1;}\n        }\n        //如果没有刚好相等的，要进行最后一轮判定\n        if(nums[mi]&lt;target)return mi+1; //小于target，要+1\n        else return mi;\n    }\n}\n</code></pre>\n<h1 id=\"53-Maximum-Subarray\"><a href=\"https://leetcode-cn.com/problems/maximum-subarray/\" target=\"_blank\" rel=\"noopener\">53. Maximum Subarray</a></h1>\n<p><a href=\"Array-Easy/image-20200226145315266.png\" title=\"image-20200226145315266\" class=\"gallery-item\"><img src=\"image-20200226145315266.png\" alt=\"image-20200226145315266\"></a></p>\n<h2 id=\"解法一：分治\">解法一：分治</h2>\n<ol>\n<li>最大和序列可能的情况：左边界序列，右边界序列，中间序列</li>\n<li>因此先计算左右边界序列的最大值，再递归地比较中间序列，就能找到最大的子序列和</li>\n</ol>\n<pre><code class=\"language-java\">class Solution {\n    public int maxSubArray(int[] nums) {\n        return maxSub(nums,0,nums.length-1);\n    }\n\n    public int maxSub(int[] nums,int lo,int hi){\n        if(hi&lt;lo){return Integer.MIN_VALUE;//注意越界后要返回一个最小的值，否则无法通过负数的情况\n                 }// lo必须小于等于hi\n        \n        int maxLeft=nums[lo],maxRight=nums[hi],sumLeft=0,sumRight=0;//一些待用变量\n        \n        for(int i=lo;i&lt;=hi;i++){//找到左边界的最大和序列\n            sumLeft+=nums[i];\n            maxLeft=Math.max(sumLeft,maxLeft);\n            //if(sumLeft&gt;maxLeft){\n            //    maxLeft=sumLeft;\n            //    indexLeft=i;\n            //}\n        }\n        for(int i=hi;i&gt;=lo;i--){//找到右边界的最大和序列\n            sumRight+=nums[i];\n            maxRight=Math.max(sumRight,maxRight);\n            //if(sumRight&gt;maxRight){\n            //    maxRight=sumRight;\n            //    indexRight=i;\n            //}\n        }\n        int maxSide=Math.max(maxLeft,maxRight);\n        return Math.max(maxSide,maxSub(nums,lo+1,hi-1)); //左右边界最大和序列 与 中间和序列 比较\n    }\n}\n</code></pre>\n<h2 id=\"解法二：线性扫描\">解法二：线性扫描</h2>\n<ol>\n<li>\n<p>计算当前的和</p>\n</li>\n<li>\n<p>比较最大值</p>\n</li>\n<li>\n<p>如果当前和 小于等于0，那么和直接归零，因为前面的结果不能让后面更大了，因此也没有继续加和的必要了</p>\n</li>\n<li>\n<p>时间复杂度：$O(N)$</p>\n</li>\n</ol>\n<pre><code class=\"language-java\">class Solution {\n    public int maxSubArray(int[] nums) {\n        int sum=0,max=nums[0];\n        for(int i=0;i&lt;nums.length;i++){\n            sum+=nums[i];          //计算当前和\n            max=Math.max(sum,max); //注意要先比较max，不然会导致sum=0和全负数的情况比较，结果错误\n            if(sum&lt;=0){sum=0;}     //小于0就可以滚蛋了，因为肯定没有后面的和大\n        }\n        return max;\n    }\n}\n</code></pre>\n<h1 id=\"88-Merge-Sorted-Array\"><a href=\"https://leetcode-cn.com/problems/merge-sorted-array/\" target=\"_blank\" rel=\"noopener\">88. Merge Sorted Array</a></h1>\n<p><a href=\"Array-Easy/image-20200302231613636.png\" title=\"image-20200302231613636\" class=\"gallery-item\"><img src=\"image-20200302231613636.png\" alt=\"image-20200302231613636\"></a></p>\n<h2 id=\"解法一：排序\">解法一：排序</h2>\n<p>复制数组，然后排序就行了，简单粗暴</p>\n<pre><code class=\"language-java\">class Solution {\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\n        System.arraycopy(nums2, 0, nums1, m, n);\n        Arrays.sort(nums1);\n    }\n}\n</code></pre>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) {\n        int len = m + n;\n        for(int i = m; i &lt; len; i++) \n            nums1[i] = nums2[i - m];\n        std::sort(nums1.begin(), nums1.end());\n    }\n};\n</code></pre>\n<h2 id=\"解法二：双指针\">解法二：双指针</h2>\n<p>要点是从后往前填</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) {\n        int len = m + n, p1 = m - 1, p2 = n - 1;\n        for(int i = len - 1; i &gt; -1; i--) {\n            if(p1 &lt; 0) nums1[i] = nums2[p2--];\n            else if(p2 &lt; 0) nums1[i] = nums1[p1--];\n            else if(nums1[p1] &lt; nums2[p2])\n                nums1[i] = nums2[p2--];\n            else\n                nums1[i] = nums1[p1--];\n        }\n        \n    }\n};\n</code></pre>\n<h1 id=\"169-Majority-Element\"><a href=\"https://leetcode-cn.com/problems/majority-element/\" target=\"_blank\" rel=\"noopener\">169. Majority Element</a></h1>\n<p><a href=\"Array-Easy/image-20200303001955825.png\" title=\"image-20200303001955825\" class=\"gallery-item\"><img src=\"image-20200303001955825.png\" alt=\"image-20200303001955825\"></a></p>\n<h2 id=\"解法一：排序-v2\">解法一：排序</h2>\n<p>排序之后，相同的数将会连续排列，就能方便地进行统计了</p>\n<pre><code class=\"language-java\">class Solution {\n    public int majorityElement(int[] nums) {\n        if(nums.length==1)return nums[0];\n        Arrays.sort(nums);\n        int num=1;\n        for(int i=1;i&lt;nums.length;i++){\n            if(nums[i]==nums[i-1]){\n                if(++num&gt;nums.length/2)return nums[i];\n            }\n            else num=1;\n        }\n        return -1;\n    }\n}\n</code></pre>\n<h2 id=\"解法二：投票法\">解法二：投票法</h2>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    int majorityElement(vector&lt;int&gt;&amp; nums) {\n        int curr = -1, curr_val = 0;\n        for(int i : nums){\n            if(curr_val &lt;= 0) curr = i;\n            if(i == curr) \n                curr_val++;\n            else \n                curr_val--;\n        }\n        return curr;\n    }\n};\n</code></pre>\n<h1 id=\"189-Rotate-Array\"><a href=\"https://leetcode-cn.com/problems/rotate-array/\" target=\"_blank\" rel=\"noopener\">189. Rotate Array</a></h1>\n<p><a href=\"Array-Easy/image-20200505193321501.png\" title=\"image-20200505193321501\" class=\"gallery-item\"><img src=\"image-20200505193321501.png\" alt=\"image-20200505193321501\"></a></p>\n<h2 id=\"解法一：暴力模拟\">解法一：暴力模拟</h2>\n<p>用类似冒泡法的方法每轮从末尾移动到第一个，一共n轮，由于数据规模达到20000，超时</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    void rotate(vector&lt;int&gt;&amp; nums, int k) {\n        k = k % nums.size();\n        for(int i = 0; i &lt; k; i++){\n            for(int j = nums.size() - 1; j &gt; 0; j--){\n                int tmp = nums[j];\n                nums[j] = nums[j - 1];\n                nums[j - 1] = tmp; \n            }\n        }\n    }\n};\n</code></pre>\n<h2 id=\"解法二：辅助空间\">解法二：辅助空间</h2>\n<p>后k个移到辅助数组的前k个，剩余移到后面，再把辅助数组移回原数组</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    void rotate(vector&lt;int&gt;&amp; nums, int k) {\n        k = k % nums.size();\n        vector&lt;int&gt; helper = vector&lt;int&gt;(nums.size());\n        for(int i = 0; i &lt; k; i++)\n            helper[i] = nums[nums.size() - k + i];\n        for(int i = k; i &lt; nums.size(); i++)\n            helper[i] = nums[i - k];\n        for(int i = 0; i &lt; nums.size(); i++)\n            nums[i] = helper[i];\n    }\n};\n</code></pre>\n<h1 id=\"283-Move-Zeroes\"><a href=\"https://leetcode-cn.com/problems/move-zeroes/\" target=\"_blank\" rel=\"noopener\">283. Move Zeroes</a></h1>\n<p><a href=\"Array-Easy/image-20200517204110963.png\" title=\"image-20200517204110963\" class=\"gallery-item\"><img src=\"image-20200517204110963.png\" alt=\"image-20200517204110963\"></a></p>\n<h2 id=\"解法一：冒泡\">解法一：冒泡</h2>\n<p>两两交换，一直换到末尾</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    void moveZeroes(vector&lt;int&gt;&amp; nums) {\n        int start = 0, end = nums.size() - 1;\n        while(start &lt; end) {\n            if(nums[start] == 0) {\n                for(int i = start; i &lt; nums.size() - 1; i++)\n                    ::swap(nums[i], nums[i + 1]);\n                end--;\n            }\n            else start++;\n        }\n    }\n};\n</code></pre>\n<h2 id=\"解法二：双指针-v2\">解法二：双指针</h2>\n<p>按顺序先把k个非零元素放在前k位，再把后k位置零，但还是多遍历了 len - k - 1次</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    void moveZeroes(vector&lt;int&gt;&amp; nums) {\n        int idx = -1;\n        for(int i = 0; i &lt; nums.size(); i++) {\n            if(nums[i] != 0) nums[++idx] = nums[i];\n        }\n        for(int i = idx + 1; i &lt; nums.size(); i++)\n            nums[i] = 0;\n    }\n};\n</code></pre>\n<h3 id=\"再优化\">再优化</h3>\n<p>只需要一次遍历</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    void moveZeroes(vector&lt;int&gt;&amp; nums) {\n        int idx = -1;\n        for(int i = 0; i &lt; nums.size(); i++) {\n            if(nums[i] != 0) ::swap(nums[++idx], nums[i]);\n        }\n    }\n};\n</code></pre>\n<h1 id=\"448-Find-All-Numbers-Disappeared-in-an-Array\"><a href=\"https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/\" target=\"_blank\" rel=\"noopener\">448. Find All Numbers Disappeared in an Array</a></h1>\n<p><a href=\"Array-Easy/image-20200926221245248.png\" title=\"image-20200926221245248\" class=\"gallery-item\"><img src=\"image-20200926221245248.png\" alt=\"image-20200926221245248\"></a></p>\n<h2 id=\"Solution-1\">Solution-1</h2>\n<p>Because of the val range’s specialty (<code>1 &lt;= a[i] &lt;= n</code>), the trick of it is convert positive val’s corresponding postion to negative one, marking the val which you have check</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    vector&lt;int&gt; findDisappearedNumbers(vector&lt;int&gt;&amp; nums) {\n        vector&lt;int&gt; res;\n        // convert cooresponding pos to negative form\n        for(int i = 0; i &lt; nums.size(); ++i) \n            nums[abs(nums[i]) - 1] = -abs(nums[abs(nums[i]) - 1]);\n        // remaining postive pos show the \n        for(int i = 0; i &lt; nums.size(); ++i) \n            if(nums[i] &gt; 0) res.push_back(i + 1);\n        return res;\n    }\n};\n</code></pre>\n<h1 id=\"581-Shortest-Unsorted-Continuous-Subarray\"><a href=\"https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray/\" target=\"_blank\" rel=\"noopener\">581. Shortest Unsorted Continuous Subarray</a></h1>\n<p><a href=\"Array-Easy/image-20200926222308447.png\" title=\"image-20200926222308447\" class=\"gallery-item\"><img src=\"image-20200926222308447.png\" alt=\"image-20200926222308447\"></a></p>\n<h2 id=\"Solution-1-v2\">Solution-1</h2>\n<p>Sort the array and check same postion of left side and rigth side, <code>r - l + 1</code> show the answer</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    int findUnsortedSubarray(vector&lt;int&gt;&amp; nums) {\n        vector&lt;int&gt; t = nums;\n        std::sort(nums.begin(), nums.end());\n        int l = 0, r = nums.size() - 1;\n        while(l &lt;= r &amp;&amp; nums[l] == t[l]) ++l;\n        while(l &lt;= r &amp;&amp; nums[r] == t[r]) --r;\n        return r - l + 1;\n    }\n};\n</code></pre>\n<h2 id=\"Solution-2\">Solution-2</h2>\n<ul>\n<li>find the last position which didn’t incresing</li>\n<li>find the firts position which didn’t declinling</li>\n<li><code>r - l + 1</code> show the ans of the problem, expect for case of  <code>l == r</code>  which show origin array is ascending array</li>\n</ul>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    int findUnsortedSubarray(vector&lt;int&gt;&amp; nums) {\n        int len = nums.size(), l = 0, r = 0;\n        for(int i = 1, max = nums[0]; i &lt; len; ++i) {\n            if(nums[i] &lt; max) r = i;\n            max = std::max(max, nums[i]);\n        }\n        for(int i = len - 2, min = nums[len - 1]; i &gt; -1; --i) {\n            if(nums[i] &gt; min) l = i;\n            min = std::min(min, nums[i]);\n        }\n        return r == l ? 0 : r - l + 1;\n    }\n};\n</code></pre>\n</div><script src=\"https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js\"></script><script>if (typeof lightGallery !== 'undefined') {\n        var options = {\n            selector: '.gallery-item'\n        };\n        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);\n        }</script>","more":"<h1 id=\"1-Two-Sum\"><a href=\"https://leetcode-cn.com/problems/two-sum/\" target=\"_blank\" rel=\"noopener\">1. Two Sum</a></h1>\n<p><a href=\"Array-Easy/image-20200226115823526.png\" title=\"image-20200226115823526\" class=\"gallery-item\"><img src=\"image-20200226115823526.png\" alt=\"image-20200226115823526\"></a></p>\n<h2 id=\"解法一：暴力法\">解法一：暴力法</h2>\n<p>冒泡排序，送死写法，就不多说了</p>\n<h2 id=\"解法二：哈希表\">解法二：哈希表</h2>\n<p>为了最快得到target的index，HashMap是个好方法，$Time:O(n^2)  Space:O(n^2)$</p>\n<pre><code class=\"language-Java\">//原始版本为两遍Hash表，但是发现可以合写在一起\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map&lt;Integer,Integer&gt; map=new HashMap&lt;Integer,Integer&gt;();\n        for (int i=0;i&lt;nums.length;i++){\n            if (map.containsKey(nums[i])&amp;&amp;map.get(nums[i])!=i)\n                return new int[] {i,map.get(nums[i])//此值的index及其对应满足条件的index\n                };\n            map.put(target-nums[i],i);//不满足的话存入Map准备下一次搜索\n        }\n        throw new IllegalArgumentException(&quot;no such answer!&quot;);\n    }\n}\n</code></pre>\n<h1 id=\"83-Remove-Duplicates-from-Sorted-List\"><a href=\"https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/\" target=\"_blank\" rel=\"noopener\">83. Remove Duplicates from Sorted List</a></h1>\n<p><a href=\"Array-Easy/image-20200226144922682.png\" title=\"image-20200226144922682\" class=\"gallery-item\"><img src=\"image-20200226144922682.png\" alt=\"image-20200226144922682\"></a></p>\n<h2 id=\"解法一：双指针\">解法一：双指针</h2>\n<pre><code class=\"language-java\">class Solution {\n    public int removeDuplicates(int[] nums) {\n        if(nums.length&lt;=1)return 1;//1的情况\n        int len=1;//因为第一个必定是nums[0],所以从1开始\n        for(int i=0;i&lt;nums.length-1;i++){\n            if (nums[i]!=nums[i+1]){\n                nums[len]=nums[i+1];//每找到一个新的值，放到前面对应的位置\n                len++;//更新最新前面的指针\n            }\n        }\n        return len;\n    }\n}\n</code></pre>\n<h1 id=\"27-Remove-Element\"><a href=\"https://leetcode-cn.com/problems/remove-element/\" target=\"_blank\" rel=\"noopener\">27. Remove Element</a></h1>\n<p><a href=\"Array-Easy/image-20200226145029241.png\" title=\"image-20200226145029241\" class=\"gallery-item\"><img src=\"image-20200226145029241.png\" alt=\"image-20200226145029241\"></a></p>\n<h2 id=\"解法一：我的双指针\">解法一：我的双指针</h2>\n<p>第一想到的虽然是覆盖，但还是鬼使神差得选择了交换</p>\n<ol>\n<li>从后往前找一个非val的值</li>\n<li>从前往后找一个等于val的值</li>\n<li>二者交换（交换的方法很蠢，浪费时间和空间，不如直接覆盖）</li>\n</ol>\n<p>缺点：需要考虑很多边界情况，而且还麻烦</p>\n<pre><code class=\"language-Java\">class Solution {\n    public int removeElement(int[] nums, int val) {\n        //考虑特殊情况，0，1,2,空\n        if(nums.length==1){\n            if(nums[0]==val)return 0;\n            else return 1;\n        }\n        int lo=0,hi=nums.length-1,count=0;\n        while(lo&lt;hi){\n            //从后往前找\n            while(nums[hi] == val){\n                hi--;\n                count++;  //目标值++\n                if(hi&lt;0){return nums.length-count;} \n                //注意如果已经找到最前面了就不要再找了，直接返回目前的结果\n            }\n            //从后往前找\n            while(lo&lt;hi &amp;&amp; nums[lo]!=val){ //注意必须满足lo&lt;hi\n                lo++;\n            }\n            //交换\n            int temp=nums[lo];\n            nums[lo]=nums[hi];\n            nums[hi]=temp;\n        }\n        return nums.length-count;\n    }\n}\n</code></pre>\n<h2 id=\"解法二：官方双指针-改\">解法二：<mark>官方双指针</mark><strong>[改]</strong></h2>\n<p>直接覆盖的方法，简单优雅</p>\n<ol>\n<li>从前往后找一个等于val的值</li>\n<li>用后排的一个值直接覆盖</li>\n</ol>\n<pre><code class=\"language-Java\">class Solution {\n    public int removeElement(int[] nums, int val) {\n        int lo=0,hi=nums.length;\n        while(lo&lt;hi){\n            if(nums[lo]==val){nums[lo]=nums[--hi];}//如果是val就用后面的值覆盖\n            //就算后面的值也是val也没关系，因为下一轮覆盖还是会把它覆盖掉\n            else lo++;\n        }\n        return hi;//最后返回最后一次覆盖的位置，即为删除后的长度\n    }\n}\n</code></pre>\n<h1 id=\"35-Search-Insert-Position\"><a href=\"https://leetcode-cn.com/problems/search-insert-position/\" target=\"_blank\" rel=\"noopener\">35. Search Insert Position</a></h1>\n<p><a href=\"Array-Easy/image-20200226145151262.png\" title=\"image-20200226145151262\" class=\"gallery-item\"><img src=\"image-20200226145151262.png\" alt=\"image-20200226145151262\"></a></p>\n<h2 id=\"解法一：二分查找（虽然思想简单，但是边界问题搞人）\">解法一：二分查找（虽然思想简单，但是<mark>边界问题搞人</mark>）</h2>\n<pre><code class=\"language-java\">class Solution {\n    public int searchInsert(int[] nums, int target) {\n        int lo=0,hi=nums.length-1,mi=0;\n        if(target&lt;=nums[lo]){return 0;}  //小于最小值按0处理\n        if(target&gt;nums[hi]){return hi+1;} //大于最大值按length处理\n        while(lo&lt;=hi){ //注意必须是 &lt;= 否则会错过一次循环判定\n            mi=(lo+hi)/2;\n            if(target==nums[mi]){return mi;} //如果刚好相等，那返回该处索引\n            else if(target&lt;nums[mi]){hi=mi-1;} //二分查找模板\n            else if(target&gt;nums[mi]){lo=mi+1;}\n        }\n        //如果没有刚好相等的，要进行最后一轮判定\n        if(nums[mi]&lt;target)return mi+1; //小于target，要+1\n        else return mi;\n    }\n}\n</code></pre>\n<h1 id=\"53-Maximum-Subarray\"><a href=\"https://leetcode-cn.com/problems/maximum-subarray/\" target=\"_blank\" rel=\"noopener\">53. Maximum Subarray</a></h1>\n<p><a href=\"Array-Easy/image-20200226145315266.png\" title=\"image-20200226145315266\" class=\"gallery-item\"><img src=\"image-20200226145315266.png\" alt=\"image-20200226145315266\"></a></p>\n<h2 id=\"解法一：分治\">解法一：分治</h2>\n<ol>\n<li>最大和序列可能的情况：左边界序列，右边界序列，中间序列</li>\n<li>因此先计算左右边界序列的最大值，再递归地比较中间序列，就能找到最大的子序列和</li>\n</ol>\n<pre><code class=\"language-java\">class Solution {\n    public int maxSubArray(int[] nums) {\n        return maxSub(nums,0,nums.length-1);\n    }\n\n    public int maxSub(int[] nums,int lo,int hi){\n        if(hi&lt;lo){return Integer.MIN_VALUE;//注意越界后要返回一个最小的值，否则无法通过负数的情况\n                 }// lo必须小于等于hi\n        \n        int maxLeft=nums[lo],maxRight=nums[hi],sumLeft=0,sumRight=0;//一些待用变量\n        \n        for(int i=lo;i&lt;=hi;i++){//找到左边界的最大和序列\n            sumLeft+=nums[i];\n            maxLeft=Math.max(sumLeft,maxLeft);\n            //if(sumLeft&gt;maxLeft){\n            //    maxLeft=sumLeft;\n            //    indexLeft=i;\n            //}\n        }\n        for(int i=hi;i&gt;=lo;i--){//找到右边界的最大和序列\n            sumRight+=nums[i];\n            maxRight=Math.max(sumRight,maxRight);\n            //if(sumRight&gt;maxRight){\n            //    maxRight=sumRight;\n            //    indexRight=i;\n            //}\n        }\n        int maxSide=Math.max(maxLeft,maxRight);\n        return Math.max(maxSide,maxSub(nums,lo+1,hi-1)); //左右边界最大和序列 与 中间和序列 比较\n    }\n}\n</code></pre>\n<h2 id=\"解法二：线性扫描\">解法二：线性扫描</h2>\n<ol>\n<li>\n<p>计算当前的和</p>\n</li>\n<li>\n<p>比较最大值</p>\n</li>\n<li>\n<p>如果当前和 小于等于0，那么和直接归零，因为前面的结果不能让后面更大了，因此也没有继续加和的必要了</p>\n</li>\n<li>\n<p>时间复杂度：$O(N)$</p>\n</li>\n</ol>\n<pre><code class=\"language-java\">class Solution {\n    public int maxSubArray(int[] nums) {\n        int sum=0,max=nums[0];\n        for(int i=0;i&lt;nums.length;i++){\n            sum+=nums[i];          //计算当前和\n            max=Math.max(sum,max); //注意要先比较max，不然会导致sum=0和全负数的情况比较，结果错误\n            if(sum&lt;=0){sum=0;}     //小于0就可以滚蛋了，因为肯定没有后面的和大\n        }\n        return max;\n    }\n}\n</code></pre>\n<h1 id=\"88-Merge-Sorted-Array\"><a href=\"https://leetcode-cn.com/problems/merge-sorted-array/\" target=\"_blank\" rel=\"noopener\">88. Merge Sorted Array</a></h1>\n<p><a href=\"Array-Easy/image-20200302231613636.png\" title=\"image-20200302231613636\" class=\"gallery-item\"><img src=\"image-20200302231613636.png\" alt=\"image-20200302231613636\"></a></p>\n<h2 id=\"解法一：排序\">解法一：排序</h2>\n<p>复制数组，然后排序就行了，简单粗暴</p>\n<pre><code class=\"language-java\">class Solution {\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\n        System.arraycopy(nums2, 0, nums1, m, n);\n        Arrays.sort(nums1);\n    }\n}\n</code></pre>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) {\n        int len = m + n;\n        for(int i = m; i &lt; len; i++) \n            nums1[i] = nums2[i - m];\n        std::sort(nums1.begin(), nums1.end());\n    }\n};\n</code></pre>\n<h2 id=\"解法二：双指针\">解法二：双指针</h2>\n<p>要点是从后往前填</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) {\n        int len = m + n, p1 = m - 1, p2 = n - 1;\n        for(int i = len - 1; i &gt; -1; i--) {\n            if(p1 &lt; 0) nums1[i] = nums2[p2--];\n            else if(p2 &lt; 0) nums1[i] = nums1[p1--];\n            else if(nums1[p1] &lt; nums2[p2])\n                nums1[i] = nums2[p2--];\n            else\n                nums1[i] = nums1[p1--];\n        }\n        \n    }\n};\n</code></pre>\n<h1 id=\"169-Majority-Element\"><a href=\"https://leetcode-cn.com/problems/majority-element/\" target=\"_blank\" rel=\"noopener\">169. Majority Element</a></h1>\n<p><a href=\"Array-Easy/image-20200303001955825.png\" title=\"image-20200303001955825\" class=\"gallery-item\"><img src=\"image-20200303001955825.png\" alt=\"image-20200303001955825\"></a></p>\n<h2 id=\"解法一：排序-v2\">解法一：排序</h2>\n<p>排序之后，相同的数将会连续排列，就能方便地进行统计了</p>\n<pre><code class=\"language-java\">class Solution {\n    public int majorityElement(int[] nums) {\n        if(nums.length==1)return nums[0];\n        Arrays.sort(nums);\n        int num=1;\n        for(int i=1;i&lt;nums.length;i++){\n            if(nums[i]==nums[i-1]){\n                if(++num&gt;nums.length/2)return nums[i];\n            }\n            else num=1;\n        }\n        return -1;\n    }\n}\n</code></pre>\n<h2 id=\"解法二：投票法\">解法二：投票法</h2>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    int majorityElement(vector&lt;int&gt;&amp; nums) {\n        int curr = -1, curr_val = 0;\n        for(int i : nums){\n            if(curr_val &lt;= 0) curr = i;\n            if(i == curr) \n                curr_val++;\n            else \n                curr_val--;\n        }\n        return curr;\n    }\n};\n</code></pre>\n<h1 id=\"189-Rotate-Array\"><a href=\"https://leetcode-cn.com/problems/rotate-array/\" target=\"_blank\" rel=\"noopener\">189. Rotate Array</a></h1>\n<p><a href=\"Array-Easy/image-20200505193321501.png\" title=\"image-20200505193321501\" class=\"gallery-item\"><img src=\"image-20200505193321501.png\" alt=\"image-20200505193321501\"></a></p>\n<h2 id=\"解法一：暴力模拟\">解法一：暴力模拟</h2>\n<p>用类似冒泡法的方法每轮从末尾移动到第一个，一共n轮，由于数据规模达到20000，超时</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    void rotate(vector&lt;int&gt;&amp; nums, int k) {\n        k = k % nums.size();\n        for(int i = 0; i &lt; k; i++){\n            for(int j = nums.size() - 1; j &gt; 0; j--){\n                int tmp = nums[j];\n                nums[j] = nums[j - 1];\n                nums[j - 1] = tmp; \n            }\n        }\n    }\n};\n</code></pre>\n<h2 id=\"解法二：辅助空间\">解法二：辅助空间</h2>\n<p>后k个移到辅助数组的前k个，剩余移到后面，再把辅助数组移回原数组</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    void rotate(vector&lt;int&gt;&amp; nums, int k) {\n        k = k % nums.size();\n        vector&lt;int&gt; helper = vector&lt;int&gt;(nums.size());\n        for(int i = 0; i &lt; k; i++)\n            helper[i] = nums[nums.size() - k + i];\n        for(int i = k; i &lt; nums.size(); i++)\n            helper[i] = nums[i - k];\n        for(int i = 0; i &lt; nums.size(); i++)\n            nums[i] = helper[i];\n    }\n};\n</code></pre>\n<h1 id=\"283-Move-Zeroes\"><a href=\"https://leetcode-cn.com/problems/move-zeroes/\" target=\"_blank\" rel=\"noopener\">283. Move Zeroes</a></h1>\n<p><a href=\"Array-Easy/image-20200517204110963.png\" title=\"image-20200517204110963\" class=\"gallery-item\"><img src=\"image-20200517204110963.png\" alt=\"image-20200517204110963\"></a></p>\n<h2 id=\"解法一：冒泡\">解法一：冒泡</h2>\n<p>两两交换，一直换到末尾</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    void moveZeroes(vector&lt;int&gt;&amp; nums) {\n        int start = 0, end = nums.size() - 1;\n        while(start &lt; end) {\n            if(nums[start] == 0) {\n                for(int i = start; i &lt; nums.size() - 1; i++)\n                    ::swap(nums[i], nums[i + 1]);\n                end--;\n            }\n            else start++;\n        }\n    }\n};\n</code></pre>\n<h2 id=\"解法二：双指针-v2\">解法二：双指针</h2>\n<p>按顺序先把k个非零元素放在前k位，再把后k位置零，但还是多遍历了 len - k - 1次</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    void moveZeroes(vector&lt;int&gt;&amp; nums) {\n        int idx = -1;\n        for(int i = 0; i &lt; nums.size(); i++) {\n            if(nums[i] != 0) nums[++idx] = nums[i];\n        }\n        for(int i = idx + 1; i &lt; nums.size(); i++)\n            nums[i] = 0;\n    }\n};\n</code></pre>\n<h3 id=\"再优化\">再优化</h3>\n<p>只需要一次遍历</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    void moveZeroes(vector&lt;int&gt;&amp; nums) {\n        int idx = -1;\n        for(int i = 0; i &lt; nums.size(); i++) {\n            if(nums[i] != 0) ::swap(nums[++idx], nums[i]);\n        }\n    }\n};\n</code></pre>\n<h1 id=\"448-Find-All-Numbers-Disappeared-in-an-Array\"><a href=\"https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/\" target=\"_blank\" rel=\"noopener\">448. Find All Numbers Disappeared in an Array</a></h1>\n<p><a href=\"Array-Easy/image-20200926221245248.png\" title=\"image-20200926221245248\" class=\"gallery-item\"><img src=\"image-20200926221245248.png\" alt=\"image-20200926221245248\"></a></p>\n<h2 id=\"Solution-1\">Solution-1</h2>\n<p>Because of the val range’s specialty (<code>1 &lt;= a[i] &lt;= n</code>), the trick of it is convert positive val’s corresponding postion to negative one, marking the val which you have check</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    vector&lt;int&gt; findDisappearedNumbers(vector&lt;int&gt;&amp; nums) {\n        vector&lt;int&gt; res;\n        // convert cooresponding pos to negative form\n        for(int i = 0; i &lt; nums.size(); ++i) \n            nums[abs(nums[i]) - 1] = -abs(nums[abs(nums[i]) - 1]);\n        // remaining postive pos show the \n        for(int i = 0; i &lt; nums.size(); ++i) \n            if(nums[i] &gt; 0) res.push_back(i + 1);\n        return res;\n    }\n};\n</code></pre>\n<h1 id=\"581-Shortest-Unsorted-Continuous-Subarray\"><a href=\"https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray/\" target=\"_blank\" rel=\"noopener\">581. Shortest Unsorted Continuous Subarray</a></h1>\n<p><a href=\"Array-Easy/image-20200926222308447.png\" title=\"image-20200926222308447\" class=\"gallery-item\"><img src=\"image-20200926222308447.png\" alt=\"image-20200926222308447\"></a></p>\n<h2 id=\"Solution-1-v2\">Solution-1</h2>\n<p>Sort the array and check same postion of left side and rigth side, <code>r - l + 1</code> show the answer</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    int findUnsortedSubarray(vector&lt;int&gt;&amp; nums) {\n        vector&lt;int&gt; t = nums;\n        std::sort(nums.begin(), nums.end());\n        int l = 0, r = nums.size() - 1;\n        while(l &lt;= r &amp;&amp; nums[l] == t[l]) ++l;\n        while(l &lt;= r &amp;&amp; nums[r] == t[r]) --r;\n        return r - l + 1;\n    }\n};\n</code></pre>\n<h2 id=\"Solution-2\">Solution-2</h2>\n<ul>\n<li>find the last position which didn’t incresing</li>\n<li>find the firts position which didn’t declinling</li>\n<li><code>r - l + 1</code> show the ans of the problem, expect for case of  <code>l == r</code>  which show origin array is ascending array</li>\n</ul>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    int findUnsortedSubarray(vector&lt;int&gt;&amp; nums) {\n        int len = nums.size(), l = 0, r = 0;\n        for(int i = 1, max = nums[0]; i &lt; len; ++i) {\n            if(nums[i] &lt; max) r = i;\n            max = std::max(max, nums[i]);\n        }\n        for(int i = len - 2, min = nums[len - 1]; i &gt; -1; --i) {\n            if(nums[i] &gt; min) l = i;\n            min = std::min(min, nums[i]);\n        }\n        return r == l ? 0 : r - l + 1;\n    }\n};\n</code></pre>\n<script src=\"https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js\"></script><script>if (typeof lightGallery !== 'undefined') {\n        var options = {\n            selector: '.gallery-item'\n        };\n        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);\n        }</script>","categories":[{"name":"Algorithm","path":"api/categories/Algorithm.json"}],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"}]}