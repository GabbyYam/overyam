{"title":"Math-Medium","slug":"Math-Medium","date":"2020-04-30T07:38:42.000Z","updated":"2020-05-17T14:59:00.819Z","comments":true,"path":"api/articles/Math-Medium.json","excerpt":"Abstract：leetcode 数学tag Medium 难度题解合集","covers":["image-20200430154015296.png","image-20200506203545965.png","image-20200511152611963.png","image-20200517225343332.png"],"content":"<link rel=\"stylesheet\" type=\"text/css\" href=\"https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css\"><div class=\".article-gallery\" <p><strong>Abstract</strong>：leetcode 数学tag Medium 难度题解合集<p></p>\n<a id=\"more\"></a>\n<h1 id=\"50-Pow-x-n\"><a href=\"https://leetcode-cn.com/problems/powx-n/\" target=\"_blank\" rel=\"noopener\">50. Pow(x, n)</a></h1>\n<p><a href=\"Math-Medium/image-20200430154015296.png\" title=\"image-20200430154015296\" class=\"gallery-item\"><img src=\"image-20200430154015296.png\" alt=\"image-20200430154015296\"></a></p>\n<h2 id=\"解法一：递归快速幂\">解法一：递归快速幂</h2>\n<p>快速幂本质就是靠不重复计算平方提速的，但是这题有坑点，n必须先转成long long类型，否则会被卡</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    double myPow(double x, int n) {\n        long long l = n;\n        return l &gt; 0 ? fastPow(x, l) : fastPow(1 / x, -l);\n    }\n\n    double fastPow(double x, int n){\n        if(n == 0) return 1;\n        if(n == 1) return x;\n        double half = fastPow(x, n / 2);\n        if(n % 2 == 0)\n            return half * half;\n        else \n            return half * half * x;\n    }\n};\n</code></pre>\n<h2 id=\"解法二：迭代快速幂\">解法二：迭代快速幂</h2>\n<p>卡了半天还是看了答案</p>\n<pre><code class=\"language-cpp\">\n</code></pre>\n<h1 id=\"223-Rectangle-Area\"><a href=\"https://leetcode-cn.com/problems/rectangle-area/\" target=\"_blank\" rel=\"noopener\">223. Rectangle Area</a></h1>\n<p><a href=\"Math-Medium/image-20200506203545965.png\" title=\"image-20200506203545965\" class=\"gallery-item\"><img src=\"image-20200506203545965.png\" alt=\"image-20200506203545965\"></a></p>\n<h2 id=\"解法一\">解法一</h2>\n<p>本质就是求交面积问题，因为没有旋转问题，所以求交也很简单。。</p>\n<p>最后记得先减再加否则会溢出</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\n        int overlap = 0;\n        if(!(E &gt;= C || D &lt;= F || G &lt;= A || H &lt;= B)) {        \n            int left   = std::max(A, E);\n            int right  = std::min(C, G);\n            int top    = std::min(D, H);\n            int bottom = std::max(B, F);   \n            overlap = (right - left) * (top - bottom);\n        }\n        int area1 = (D - B) * (C - A);\n        int area2 = (G - E) * (H - F);\n        return  area1 + (area2 - overlap);\n    }\n};\n</code></pre>\n<h1 id=\"279-Perfect-Squares\"><a href=\"https://leetcode-cn.com/problems/perfect-squares/\" target=\"_blank\" rel=\"noopener\">279. Perfect Squares</a></h1>\n<p><a href=\"Math-Medium/image-20200511152611963.png\" title=\"image-20200511152611963\" class=\"gallery-item\"><img src=\"image-20200511152611963.png\" alt=\"image-20200511152611963\"></a></p>\n<h2 id=\"解法一：记忆化递归\">解法一：记忆化递归</h2>\n<p>我们显然可以递归地求解这个问题，也就是</p>\n<pre><code class=\"language-mathematica\">F(n) = 1 + min{ i * i &lt;= n | F(n - i * i) }\n</code></pre>\n<p>很快我们可以得到递归写法</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    vector&lt;int&gt; memo;\n    int numSquares(int n) {\n        if(n == 0) return 0;\n        int min = INT32_MAX;\n        for(int i = 1; i * i &lt;= n; i++) {\n            min = std::min(min, numSquares(n - i * i) + 1);\n        }\n        return min;\n    }\n};\n</code></pre>\n<p>但是直接递归就太多重复了，就像斐波那契数列的递归写法一样，所以我们记忆化递归</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    vector&lt;int&gt; memo;\n    int numSquares(int n) {\n        memo = vector&lt;int&gt;(n + 1, INT32_MAX);\n        memo[0] = 0;\n        return getMinSquare(n);\n    }\n\n    int getMinSquare(int n) {\n        if(memo[n] != INT32_MAX) return memo[n];\n        for(int i = 1; i * i &lt;= n; i++) {\n            memo[n] = std::min(memo[n], getMinSquare(n - i * i) + 1);\n        }\n        return memo[n];\n    }\n};\n</code></pre>\n<h2 id=\"解法二：DP\">解法二：DP</h2>\n<p>记忆化递归改写成DP</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    int numSquares(int n) {\n        vector&lt;int&gt; dp(n + 1, INT32_MAX);\n        dp[0] = 0;\n        for(int i = 1; i &lt;= n; i++) {\n            for(int j = 1; j * j &lt;= i; j++) {\n                dp[i] = std::min(dp[i], dp[i - j * j] + 1);\n            }\n        }\n        return dp[n];\n    }\n};\n</code></pre>\n<h2 id=\"解法三：BFS-贪心\">解法三：BFS + 贪心</h2>\n<p>如果把问题理解成最短路问题的话…下次再写</p>\n<h2 id=\"解法四：数论\">解法四：数论</h2>\n<p>这题是有数学解的，反正我是不知道这种方法，看了答案，数学，永远滴神</p>\n<ul>\n<li>\n<p>一个数最多需要4个完全平方数来表示</p>\n</li>\n<li>\n<p>对于可以表示为$4^k(8m + 7)$形式的数，需要四个平方数来表示</p>\n</li>\n<li>\n<p>对于完全平方数，当然只需要一个</p>\n</li>\n<li>\n<p>对于需要两个的完全平方数，我们枚举检查</p>\n</li>\n<li>\n<p>否则排除法需要三个</p>\n</li>\n</ul>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    bool isSquare(int n) {\n        int val = (int)std::sqrt(n);\n        return n == val * val;\n    }\n\n    int numSquares(int n) {\n        while(n % 4 == 0)\n            n /= 4;\n        if(n % 8 == 7)\n            return 4;\n        if(isSquare(n)) return 1;\n        for(int i = 1; i * i &lt;= n; i++) {\n            if(isSquare(n - i * i)) return 2;\n        }\n        return 3;\n    }\n};\n</code></pre>\n<h1 id=\"593-Valid-Square\"><a href=\"https://leetcode-cn.com/problems/valid-square/\" target=\"_blank\" rel=\"noopener\">593. Valid Square</a></h1>\n<p><a href=\"Math-Medium/image-20200517225343332.png\" title=\"image-20200517225343332\" class=\"gallery-item\"><img src=\"image-20200517225343332.png\" alt=\"image-20200517225343332\"></a></p>\n<h2 id=\"解法一：枚举\">解法一：枚举</h2>\n<ul>\n<li>考虑三种不同的相对位置</li>\n<li>当四条边相等 且 对角线也相等时说明是正方形</li>\n</ul>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    bool validSquare(vector&lt;int&gt;&amp; p1, vector&lt;int&gt;&amp; p2, vector&lt;int&gt;&amp; p3, vector&lt;int&gt;&amp; p4) {\n        return check(p1, p2, p3, p4) || check(p1, p3, p2, p4) || check(p1, p2, p4, p3);\n    }\n\n    bool check(vector&lt;int&gt;&amp; p1, vector&lt;int&gt;&amp; p2, vector&lt;int&gt;&amp; p3, vector&lt;int&gt;&amp; p4) {\n        int d1 = getDistance(p1, p2),\n            d2 = getDistance(p2, p3),\n            d3 = getDistance(p3, p4),\n            d4 = getDistance(p4, p1),\n            d5 = getDistance(p1, p3),\n            d6 = getDistance(p2, p4);\n        return d1 &gt; 0 &amp;&amp; d1 == d2 &amp;&amp; d2 == d3 &amp;&amp; d3 == d4 &amp;&amp; d5 == d6;\n    }\n\n    int getDistance(vector&lt;int&gt;&amp; p1, vector&lt;int&gt;&amp; p2) {\n        int y = p2[1] - p1[1], x = p2[0] - p1[0];\n        return y * y + x * x; \n    }\n};\n</code></pre>\n</div><script src=\"https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js\"></script><script>if (typeof lightGallery !== 'undefined') {\n        var options = {\n            selector: '.gallery-item'\n        };\n        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);\n        }</script>","more":"<h1 id=\"50-Pow-x-n\"><a href=\"https://leetcode-cn.com/problems/powx-n/\" target=\"_blank\" rel=\"noopener\">50. Pow(x, n)</a></h1>\n<p><a href=\"Math-Medium/image-20200430154015296.png\" title=\"image-20200430154015296\" class=\"gallery-item\"><img src=\"image-20200430154015296.png\" alt=\"image-20200430154015296\"></a></p>\n<h2 id=\"解法一：递归快速幂\">解法一：递归快速幂</h2>\n<p>快速幂本质就是靠不重复计算平方提速的，但是这题有坑点，n必须先转成long long类型，否则会被卡</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    double myPow(double x, int n) {\n        long long l = n;\n        return l &gt; 0 ? fastPow(x, l) : fastPow(1 / x, -l);\n    }\n\n    double fastPow(double x, int n){\n        if(n == 0) return 1;\n        if(n == 1) return x;\n        double half = fastPow(x, n / 2);\n        if(n % 2 == 0)\n            return half * half;\n        else \n            return half * half * x;\n    }\n};\n</code></pre>\n<h2 id=\"解法二：迭代快速幂\">解法二：迭代快速幂</h2>\n<p>卡了半天还是看了答案</p>\n<pre><code class=\"language-cpp\">\n</code></pre>\n<h1 id=\"223-Rectangle-Area\"><a href=\"https://leetcode-cn.com/problems/rectangle-area/\" target=\"_blank\" rel=\"noopener\">223. Rectangle Area</a></h1>\n<p><a href=\"Math-Medium/image-20200506203545965.png\" title=\"image-20200506203545965\" class=\"gallery-item\"><img src=\"image-20200506203545965.png\" alt=\"image-20200506203545965\"></a></p>\n<h2 id=\"解法一\">解法一</h2>\n<p>本质就是求交面积问题，因为没有旋转问题，所以求交也很简单。。</p>\n<p>最后记得先减再加否则会溢出</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\n        int overlap = 0;\n        if(!(E &gt;= C || D &lt;= F || G &lt;= A || H &lt;= B)) {        \n            int left   = std::max(A, E);\n            int right  = std::min(C, G);\n            int top    = std::min(D, H);\n            int bottom = std::max(B, F);   \n            overlap = (right - left) * (top - bottom);\n        }\n        int area1 = (D - B) * (C - A);\n        int area2 = (G - E) * (H - F);\n        return  area1 + (area2 - overlap);\n    }\n};\n</code></pre>\n<h1 id=\"279-Perfect-Squares\"><a href=\"https://leetcode-cn.com/problems/perfect-squares/\" target=\"_blank\" rel=\"noopener\">279. Perfect Squares</a></h1>\n<p><a href=\"Math-Medium/image-20200511152611963.png\" title=\"image-20200511152611963\" class=\"gallery-item\"><img src=\"image-20200511152611963.png\" alt=\"image-20200511152611963\"></a></p>\n<h2 id=\"解法一：记忆化递归\">解法一：记忆化递归</h2>\n<p>我们显然可以递归地求解这个问题，也就是</p>\n<pre><code class=\"language-mathematica\">F(n) = 1 + min{ i * i &lt;= n | F(n - i * i) }\n</code></pre>\n<p>很快我们可以得到递归写法</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    vector&lt;int&gt; memo;\n    int numSquares(int n) {\n        if(n == 0) return 0;\n        int min = INT32_MAX;\n        for(int i = 1; i * i &lt;= n; i++) {\n            min = std::min(min, numSquares(n - i * i) + 1);\n        }\n        return min;\n    }\n};\n</code></pre>\n<p>但是直接递归就太多重复了，就像斐波那契数列的递归写法一样，所以我们记忆化递归</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    vector&lt;int&gt; memo;\n    int numSquares(int n) {\n        memo = vector&lt;int&gt;(n + 1, INT32_MAX);\n        memo[0] = 0;\n        return getMinSquare(n);\n    }\n\n    int getMinSquare(int n) {\n        if(memo[n] != INT32_MAX) return memo[n];\n        for(int i = 1; i * i &lt;= n; i++) {\n            memo[n] = std::min(memo[n], getMinSquare(n - i * i) + 1);\n        }\n        return memo[n];\n    }\n};\n</code></pre>\n<h2 id=\"解法二：DP\">解法二：DP</h2>\n<p>记忆化递归改写成DP</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    int numSquares(int n) {\n        vector&lt;int&gt; dp(n + 1, INT32_MAX);\n        dp[0] = 0;\n        for(int i = 1; i &lt;= n; i++) {\n            for(int j = 1; j * j &lt;= i; j++) {\n                dp[i] = std::min(dp[i], dp[i - j * j] + 1);\n            }\n        }\n        return dp[n];\n    }\n};\n</code></pre>\n<h2 id=\"解法三：BFS-贪心\">解法三：BFS + 贪心</h2>\n<p>如果把问题理解成最短路问题的话…下次再写</p>\n<h2 id=\"解法四：数论\">解法四：数论</h2>\n<p>这题是有数学解的，反正我是不知道这种方法，看了答案，数学，永远滴神</p>\n<ul>\n<li>\n<p>一个数最多需要4个完全平方数来表示</p>\n</li>\n<li>\n<p>对于可以表示为$4^k(8m + 7)$形式的数，需要四个平方数来表示</p>\n</li>\n<li>\n<p>对于完全平方数，当然只需要一个</p>\n</li>\n<li>\n<p>对于需要两个的完全平方数，我们枚举检查</p>\n</li>\n<li>\n<p>否则排除法需要三个</p>\n</li>\n</ul>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    bool isSquare(int n) {\n        int val = (int)std::sqrt(n);\n        return n == val * val;\n    }\n\n    int numSquares(int n) {\n        while(n % 4 == 0)\n            n /= 4;\n        if(n % 8 == 7)\n            return 4;\n        if(isSquare(n)) return 1;\n        for(int i = 1; i * i &lt;= n; i++) {\n            if(isSquare(n - i * i)) return 2;\n        }\n        return 3;\n    }\n};\n</code></pre>\n<h1 id=\"593-Valid-Square\"><a href=\"https://leetcode-cn.com/problems/valid-square/\" target=\"_blank\" rel=\"noopener\">593. Valid Square</a></h1>\n<p><a href=\"Math-Medium/image-20200517225343332.png\" title=\"image-20200517225343332\" class=\"gallery-item\"><img src=\"image-20200517225343332.png\" alt=\"image-20200517225343332\"></a></p>\n<h2 id=\"解法一：枚举\">解法一：枚举</h2>\n<ul>\n<li>考虑三种不同的相对位置</li>\n<li>当四条边相等 且 对角线也相等时说明是正方形</li>\n</ul>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    bool validSquare(vector&lt;int&gt;&amp; p1, vector&lt;int&gt;&amp; p2, vector&lt;int&gt;&amp; p3, vector&lt;int&gt;&amp; p4) {\n        return check(p1, p2, p3, p4) || check(p1, p3, p2, p4) || check(p1, p2, p4, p3);\n    }\n\n    bool check(vector&lt;int&gt;&amp; p1, vector&lt;int&gt;&amp; p2, vector&lt;int&gt;&amp; p3, vector&lt;int&gt;&amp; p4) {\n        int d1 = getDistance(p1, p2),\n            d2 = getDistance(p2, p3),\n            d3 = getDistance(p3, p4),\n            d4 = getDistance(p4, p1),\n            d5 = getDistance(p1, p3),\n            d6 = getDistance(p2, p4);\n        return d1 &gt; 0 &amp;&amp; d1 == d2 &amp;&amp; d2 == d3 &amp;&amp; d3 == d4 &amp;&amp; d5 == d6;\n    }\n\n    int getDistance(vector&lt;int&gt;&amp; p1, vector&lt;int&gt;&amp; p2) {\n        int y = p2[1] - p1[1], x = p2[0] - p1[0];\n        return y * y + x * x; \n    }\n};\n</code></pre>\n<script src=\"https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js\"></script><script>if (typeof lightGallery !== 'undefined') {\n        var options = {\n            selector: '.gallery-item'\n        };\n        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);\n        }</script>","categories":[{"name":"Algorithm","path":"api/categories/Algorithm.json"}],"tags":[{"name":"Leetcode","path":"api/tags/Leetcode.json"}]}