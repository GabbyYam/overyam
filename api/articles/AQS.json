{"title":"AQS & ReentrantLock 原理和实现","slug":"AQS","date":"2020-02-28T03:54:49.000Z","updated":"2020-02-28T08:12:44.049Z","comments":true,"path":"api/articles/AQS.json","excerpt":"Abstruct：初步分析AQS与ReentrantLock的构成与关联","covers":null,"content":"<link rel=\"stylesheet\" type=\"text/css\" href=\"https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css\"><div class=\".article-gallery\" <p><strong>Abstruct</strong>：初步分析<code>AQS</code>与<code>ReentrantLock</code>的构成与关联<p></p>\n<a id=\"more\"></a>\n<h1 id=\"AQS核心\">AQS核心 <sup class=\"footnote-ref\"><a href=\"#fn1\" id=\"fnref1\">[1]</a></sup></h1>\n<ul>\n<li>\n<p><code>AQS</code>，全称<code>AbstractQueueSynchronizer</code>，<code>j.u.c</code>中许多类依赖于<code>AQS</code>实现，是<code>j.u.c</code>中的核心框架，主要作用是维护获取锁的队列</p>\n</li>\n<li>\n<p><code>AQS</code>中的队列是<code>FIFO</code>的<strong>双向队列</strong></p>\n</li>\n<li>\n<p><code>AQS</code>中的<strong>节点</strong>和<strong>锁状态</strong>均为<code>volatile</code>修饰，以此保证锁状态和队列的<strong>可见性</strong></p>\n<pre><code class=\"language-java\">volatile int waitStatus;\t//等待状态，包含5种枚举值，含义如下\n/**\n *\t0,初始化值\n *\t1，CANCELED，表示获取锁的请求被取消\n *\t-1，SIGNAL，表示线程就绪，等待资源释放\n *\t-2，CANCELED，表示获取锁的请求取消\n * \t-3，PROPAGATE，共享模式时使用\n */\n\nprivate transient volatile Node head; //头结点为虚节点，用于维护表头\nprivate transient volatile Node tail;\n\nvolatile Node prev;         //前驱节点\nvolatile Node next;\t\t\t//后继节点\nvolatile Thread thread;\t\t//代表的线程\n\nprivate volatile int state; //同步状态，即锁状态，大于1时表示同一线程递归上锁，等于0时锁被释放\n\n</code></pre>\n<h2 id=\"实现自定义同步器需要实现的以下方法：\">实现<mark>自定义同步器</mark>需要实现的以下方法：</h2>\n<pre><code class=\"language-java\">//判断线程是否取得锁\nprotected boolean isHeldExclusively()    \n\n//独占模式\nprotected boolean tryAcquire(int arg)\t//用于AQS中的acquire方法，CAS获取锁\nprotected boolean tryRelease(int arg)\t//用于AQS中的release方法，释放锁\n    \n//共享模式\nprotected int tryAcquireShared(int arg)\t\t\t//锁可以被多个线程获取，但是有上限\nprotected boolean tryReleaseShared(int arg)\n\n//纯独占模式的实现：`ReentrantLock`\n//双模式实现：`ReentrantWriteReadLock`\n//其中acquire和release继承于AQS，不需要重写，用于管理位于双向队列中的各节点\n</code></pre>\n<h2 id=\"加入等待队列的流程\">加入等待队列的流程</h2>\n<pre><code class=\"language-java\">//1.请求锁\npublic final void acquire(int arg) {\n    if (!tryAcquire(arg) &amp;&amp;\t\t\t\t\t\t\t\t//先尝试获取锁，如果成功，请求队列\n        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))\t//独占模式才有此操作\n        selfInterrupt();\t\t//一定情况下自行中断，下面会说\n}\n\n//2.非极端情况下加入Waiter，即添加到队列队尾\nprivate Node addWaiter(Node mode) {\n        Node node = new Node(Thread.currentThread(), mode);\n        // Try the fast path of enq; backup to full enq on failure\n        Node pred = tail;\n        if (pred != null) {\n            node.prev = pred;\n            if (compareAndSetTail(pred, node)) {\t\t//对队尾的设置也是CAS操作\n                pred.next = node;\n                return node;\n            }\n        }\n        enq(node);\n        return node;\n    }\n\n//2.1.如果入队时没有tail，那么初始化一个Node出来\nprivate Node enq(final Node node) {\n    for (;;) {\t\t\t //通过自旋来设置\n        Node t = tail;\n        if (t == null) { // Must initialize\n            if (compareAndSetHead(new Node()))\n                tail = head;\n        } else {\t\t //由于不是原子操作，如果此时头部有了，那么还是addWaiter里面的老方法\n            node.prev = t;\n            if (compareAndSetTail(t, node)) {\n                t.next = node;\n                return t;\n            }\n        }\n    }\n}\n</code></pre>\n<h2 id=\"队列处理流程\">队列处理流程</h2>\n<pre><code class=\"language-java\">//1.上面acquire中出现的acqureQueued\nfinal boolean acquireQueued(final Node node, int arg) {\n    boolean failed = true;\n    try {\n        boolean interrupted = false;\n        for (;;) {\t\t\t\t\t\t\t\t\t\t\t//通过自旋\n            final Node p = node.predecessor();\t\t\t\t//取得前驱节点\n            if (p == head &amp;&amp; tryAcquire(arg)) {\t//由于head为虚节点，如果在队首=&gt;尝试取锁\n                setHead(node); //node变为虚节点，相当于删除\n                p.next = null; // help GC\n                failed = false;\n                return interrupted;\n            }\n            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;\t//判断失败过后是否应该继续留队\n                parkAndCheckInterrupt())\t\t\t\t\t//如果是，再确认是否中断\n                interrupted = true;\n        }\n    } finally {\n        if (failed)\n            cancelAcquire(node);\t\t\t\t\t\t//如果最终失败，节点设为CANCELED\n    }\n}\n\n//2.留队判断：通过waitStatus判断后续处理，官方的注释写得已经比较清楚了\nprivate static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {\n    int ws = pred.waitStatus;\n    if (ws == Node.SIGNAL) //已就绪，继续留队\n        /*\n             * This node has already set status asking a release\n             * to signal it, so it can safely park.\n             */\n        return true;\n    if (ws &gt; 0) {\t\t  //ws=1，表示取消，向前找到下一个未取消的节点，将中间这些取消的节点出队\n        /*\n             * Predecessor was cancelled. Skip over predecessors and\n             * indicate retry.\n             */\n        do {\n            node.prev = pred = pred.prev;\n        } while (pred.waitStatus &gt; 0);\n        pred.next = node;\n    } else {\t\t\t  //此时不是0就是PROPAGATE，设为SIGNAL，等下一轮锁请求\n        /*\n             * waitStatus must be 0 or PROPAGATE.  Indicate that we\n             * need a signal, but don't park yet.  Caller will need to\n             * retry to make sure it cannot acquire before parking.\n             */\n        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);\n    }\n    return false;\n}\n\n//3.如果留队，还要判断是否中断\nprivate final boolean parkAndCheckInterrupt() {\n    LockSupport.park(this);   \t\t\t//通过UNSAFE相关操作，在后面UNSAFE中再详细解释\n    return Thread.interrupted();\n}\n\n//4.最后，如果没能上机，则waitSatus设为CANCELED\nprivate void cancelAcquire(Node node) {\n    // Ignore if node doesn't exist\n    if (node == null)\n        return;\n\n    node.thread = null;\n\n    // Skip cancelled predecessors  ： 跳过所有前面其他被取消的节点\n    Node pred = node.prev;\n    while (pred.waitStatus &gt; 0)\n        node.prev = pred = pred.prev;\n\n    // predNext is the apparent node to unsplice. CASes below will\n    // fail if not, in which case, we lost race vs another cancel\n    // or signal, so no further action is necessary.\n    Node predNext = pred.next;\n\n    // Can use unconditional write instead of CAS here.\n    // After this atomic step, other Nodes can skip past us.\n    // Before, we are free of interference from other threads.\n    node.waitStatus = Node.CANCELLED;\n\n    // If we are the tail, remove ourselves. ：如果是尾结点，直接移除就行\n    if (node == tail &amp;&amp; compareAndSetTail(node, pred)) {\n        compareAndSetNext(pred, predNext, null);\n    } else {\n        // If successor needs signal, try to set pred's next-link\n        // so it will get one. Otherwise wake it up to propagate.\n        int ws;\n        if (pred != head &amp;&amp;\n            ((ws = pred.waitStatus) == Node.SIGNAL ||\n             (ws &lt;= 0 &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp;\n            pred.thread != null) {\n            Node next = node.next;\n            if (next != null &amp;&amp; next.waitStatus &lt;= 0)\n                compareAndSetNext(pred, predNext, next);\n        } else {\n            unparkSuccessor(node);\n        }\n\n        node.next = node; // help GC\n    }\n}\n\n</code></pre>\n</li>\n</ul>\n<h1 id=\"与ReentrantLock的关联\">与ReentrantLock的关联</h1>\n<ul>\n<li>\n<p><code>ReentrantLock</code>是<code>Lock</code>的实现类而不是<code>AQS</code>的实现类</p>\n</li>\n<li>\n<p>其内部自定义同步器<code>Sync</code>是<code>AQS</code>的实现类，内部实现为<strong>独占模式</strong></p>\n<pre><code class=\"language-java\">abstract static class Sync extends AbstractQueuedSynchronizer{...}\n</code></pre>\n</li>\n<li>\n<p><code>ReentrantLock</code>中存在<strong>公平锁</strong>和<strong>非公平锁</strong>，实现分别为<code>NonfairSync</code>和<code>FairSync</code></p>\n</li>\n<li>\n<p>以非公平锁为例，<code>ReentrantLock</code>对<code>AQS</code>方法的实现如下：</p>\n<pre><code class=\"language-java\">//tryAcquire，和原方法名不同是因为tryAcquire间接调用了此方法，就不贴上来了\nfinal boolean nonfairTryAcquire(int acquires) {\n    final Thread current = Thread.currentThread();\n    int c = getState();\t\t\t\t\t\t\t//获取当前锁状态\n    if (c == 0) {\n        if (compareAndSetState(0, acquires)) {\t//如果锁空闲，CAS尝试获取锁\n            setExclusiveOwnerThread(current);\n            return true;\n        }\n    }\n    else if (current == getExclusiveOwnerThread()) { //重入该锁，可重入性\n        int nextc = c + acquires;\n        if (nextc &lt; 0) // overflow\n            throw new Error(&quot;Maximum lock count exceeded&quot;);\n        setState(nextc);\n        return true;\n    }\n    return false;\n}\n\n//tryRelease\nprotected final boolean tryRelease(int releases) {\n    int c = getState() - releases;\t\t\t\t\t\t\t //释放锁\t\t\t\t\n    if (Thread.currentThread() != getExclusiveOwnerThread()) //不是锁的持有者无法释放锁\n        throw new IllegalMonitorStateException();\n    boolean free = false;\n    if (c == 0) {\t\t\t\t\t\t\t\t\t\t\t\n        free = true;\n        setExclusiveOwnerThread(null);\t \t//如果释放后state=0，将锁设为空闲，取消线程独占\n    }\n    setState(c);\n    return free;\n}\n\n//isHeldExclusively，确认此线程是否持有锁\nprotected final boolean isHeldExclusively() {\n    // While we must in general read state before owner,\n    // we don't need to do so to check if current thread is owner\n    return getExclusiveOwnerThread() == Thread.currentThread();\n}\n</code></pre>\n</li>\n<li>\n<p><code>NonfairSync</code>和<code>FairSync</code>的区别</p>\n<pre><code class=\"language-java\">//公平锁\nint c = getState();\nif (c == 0) {\n    if (!hasQueuedPredecessors() &amp;&amp;         //此处多一个是否为sync队首的判断，该方法来自AQS\n        compareAndSetState(0, acquires)) {\n        setExclusiveOwnerThread(current);\n        return true;\n    }\n}\n</code></pre>\n</li>\n</ul>\n<hr class=\"footnotes-sep\">\n<section class=\"footnotes\">\n<ol class=\"footnotes-list\">\n<li id=\"fn1\" class=\"footnote-item\"><p>参考文章：<a href=\"https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html\" target=\"_blank\" rel=\"noopener\">从ReentrantLock的实现看AQS的原理及应用</a> <a href=\"#fnref1\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n</ol>\n</section>\n</div><script src=\"https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js\"></script><script>if (typeof lightGallery !== 'undefined') {\n        var options = {\n            selector: '.gallery-item'\n        };\n        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);\n        }</script>","more":"<h1 id=\"AQS核心\">AQS核心 <sup class=\"footnote-ref\"><a href=\"#fn1\" id=\"fnref1\">[1]</a></sup></h1>\n<ul>\n<li>\n<p><code>AQS</code>，全称<code>AbstractQueueSynchronizer</code>，<code>j.u.c</code>中许多类依赖于<code>AQS</code>实现，是<code>j.u.c</code>中的核心框架，主要作用是维护获取锁的队列</p>\n</li>\n<li>\n<p><code>AQS</code>中的队列是<code>FIFO</code>的<strong>双向队列</strong></p>\n</li>\n<li>\n<p><code>AQS</code>中的<strong>节点</strong>和<strong>锁状态</strong>均为<code>volatile</code>修饰，以此保证锁状态和队列的<strong>可见性</strong></p>\n<pre><code class=\"language-java\">volatile int waitStatus;\t//等待状态，包含5种枚举值，含义如下\n/**\n *\t0,初始化值\n *\t1，CANCELED，表示获取锁的请求被取消\n *\t-1，SIGNAL，表示线程就绪，等待资源释放\n *\t-2，CANCELED，表示获取锁的请求取消\n * \t-3，PROPAGATE，共享模式时使用\n */\n\nprivate transient volatile Node head; //头结点为虚节点，用于维护表头\nprivate transient volatile Node tail;\n\nvolatile Node prev;         //前驱节点\nvolatile Node next;\t\t\t//后继节点\nvolatile Thread thread;\t\t//代表的线程\n\nprivate volatile int state; //同步状态，即锁状态，大于1时表示同一线程递归上锁，等于0时锁被释放\n\n</code></pre>\n<h2 id=\"实现自定义同步器需要实现的以下方法：\">实现<mark>自定义同步器</mark>需要实现的以下方法：</h2>\n<pre><code class=\"language-java\">//判断线程是否取得锁\nprotected boolean isHeldExclusively()    \n\n//独占模式\nprotected boolean tryAcquire(int arg)\t//用于AQS中的acquire方法，CAS获取锁\nprotected boolean tryRelease(int arg)\t//用于AQS中的release方法，释放锁\n    \n//共享模式\nprotected int tryAcquireShared(int arg)\t\t\t//锁可以被多个线程获取，但是有上限\nprotected boolean tryReleaseShared(int arg)\n\n//纯独占模式的实现：`ReentrantLock`\n//双模式实现：`ReentrantWriteReadLock`\n//其中acquire和release继承于AQS，不需要重写，用于管理位于双向队列中的各节点\n</code></pre>\n<h2 id=\"加入等待队列的流程\">加入等待队列的流程</h2>\n<pre><code class=\"language-java\">//1.请求锁\npublic final void acquire(int arg) {\n    if (!tryAcquire(arg) &amp;&amp;\t\t\t\t\t\t\t\t//先尝试获取锁，如果成功，请求队列\n        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))\t//独占模式才有此操作\n        selfInterrupt();\t\t//一定情况下自行中断，下面会说\n}\n\n//2.非极端情况下加入Waiter，即添加到队列队尾\nprivate Node addWaiter(Node mode) {\n        Node node = new Node(Thread.currentThread(), mode);\n        // Try the fast path of enq; backup to full enq on failure\n        Node pred = tail;\n        if (pred != null) {\n            node.prev = pred;\n            if (compareAndSetTail(pred, node)) {\t\t//对队尾的设置也是CAS操作\n                pred.next = node;\n                return node;\n            }\n        }\n        enq(node);\n        return node;\n    }\n\n//2.1.如果入队时没有tail，那么初始化一个Node出来\nprivate Node enq(final Node node) {\n    for (;;) {\t\t\t //通过自旋来设置\n        Node t = tail;\n        if (t == null) { // Must initialize\n            if (compareAndSetHead(new Node()))\n                tail = head;\n        } else {\t\t //由于不是原子操作，如果此时头部有了，那么还是addWaiter里面的老方法\n            node.prev = t;\n            if (compareAndSetTail(t, node)) {\n                t.next = node;\n                return t;\n            }\n        }\n    }\n}\n</code></pre>\n<h2 id=\"队列处理流程\">队列处理流程</h2>\n<pre><code class=\"language-java\">//1.上面acquire中出现的acqureQueued\nfinal boolean acquireQueued(final Node node, int arg) {\n    boolean failed = true;\n    try {\n        boolean interrupted = false;\n        for (;;) {\t\t\t\t\t\t\t\t\t\t\t//通过自旋\n            final Node p = node.predecessor();\t\t\t\t//取得前驱节点\n            if (p == head &amp;&amp; tryAcquire(arg)) {\t//由于head为虚节点，如果在队首=&gt;尝试取锁\n                setHead(node); //node变为虚节点，相当于删除\n                p.next = null; // help GC\n                failed = false;\n                return interrupted;\n            }\n            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;\t//判断失败过后是否应该继续留队\n                parkAndCheckInterrupt())\t\t\t\t\t//如果是，再确认是否中断\n                interrupted = true;\n        }\n    } finally {\n        if (failed)\n            cancelAcquire(node);\t\t\t\t\t\t//如果最终失败，节点设为CANCELED\n    }\n}\n\n//2.留队判断：通过waitStatus判断后续处理，官方的注释写得已经比较清楚了\nprivate static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {\n    int ws = pred.waitStatus;\n    if (ws == Node.SIGNAL) //已就绪，继续留队\n        /*\n             * This node has already set status asking a release\n             * to signal it, so it can safely park.\n             */\n        return true;\n    if (ws &gt; 0) {\t\t  //ws=1，表示取消，向前找到下一个未取消的节点，将中间这些取消的节点出队\n        /*\n             * Predecessor was cancelled. Skip over predecessors and\n             * indicate retry.\n             */\n        do {\n            node.prev = pred = pred.prev;\n        } while (pred.waitStatus &gt; 0);\n        pred.next = node;\n    } else {\t\t\t  //此时不是0就是PROPAGATE，设为SIGNAL，等下一轮锁请求\n        /*\n             * waitStatus must be 0 or PROPAGATE.  Indicate that we\n             * need a signal, but don't park yet.  Caller will need to\n             * retry to make sure it cannot acquire before parking.\n             */\n        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);\n    }\n    return false;\n}\n\n//3.如果留队，还要判断是否中断\nprivate final boolean parkAndCheckInterrupt() {\n    LockSupport.park(this);   \t\t\t//通过UNSAFE相关操作，在后面UNSAFE中再详细解释\n    return Thread.interrupted();\n}\n\n//4.最后，如果没能上机，则waitSatus设为CANCELED\nprivate void cancelAcquire(Node node) {\n    // Ignore if node doesn't exist\n    if (node == null)\n        return;\n\n    node.thread = null;\n\n    // Skip cancelled predecessors  ： 跳过所有前面其他被取消的节点\n    Node pred = node.prev;\n    while (pred.waitStatus &gt; 0)\n        node.prev = pred = pred.prev;\n\n    // predNext is the apparent node to unsplice. CASes below will\n    // fail if not, in which case, we lost race vs another cancel\n    // or signal, so no further action is necessary.\n    Node predNext = pred.next;\n\n    // Can use unconditional write instead of CAS here.\n    // After this atomic step, other Nodes can skip past us.\n    // Before, we are free of interference from other threads.\n    node.waitStatus = Node.CANCELLED;\n\n    // If we are the tail, remove ourselves. ：如果是尾结点，直接移除就行\n    if (node == tail &amp;&amp; compareAndSetTail(node, pred)) {\n        compareAndSetNext(pred, predNext, null);\n    } else {\n        // If successor needs signal, try to set pred's next-link\n        // so it will get one. Otherwise wake it up to propagate.\n        int ws;\n        if (pred != head &amp;&amp;\n            ((ws = pred.waitStatus) == Node.SIGNAL ||\n             (ws &lt;= 0 &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp;\n            pred.thread != null) {\n            Node next = node.next;\n            if (next != null &amp;&amp; next.waitStatus &lt;= 0)\n                compareAndSetNext(pred, predNext, next);\n        } else {\n            unparkSuccessor(node);\n        }\n\n        node.next = node; // help GC\n    }\n}\n\n</code></pre>\n</li>\n</ul>\n<h1 id=\"与ReentrantLock的关联\">与ReentrantLock的关联</h1>\n<ul>\n<li>\n<p><code>ReentrantLock</code>是<code>Lock</code>的实现类而不是<code>AQS</code>的实现类</p>\n</li>\n<li>\n<p>其内部自定义同步器<code>Sync</code>是<code>AQS</code>的实现类，内部实现为<strong>独占模式</strong></p>\n<pre><code class=\"language-java\">abstract static class Sync extends AbstractQueuedSynchronizer{...}\n</code></pre>\n</li>\n<li>\n<p><code>ReentrantLock</code>中存在<strong>公平锁</strong>和<strong>非公平锁</strong>，实现分别为<code>NonfairSync</code>和<code>FairSync</code></p>\n</li>\n<li>\n<p>以非公平锁为例，<code>ReentrantLock</code>对<code>AQS</code>方法的实现如下：</p>\n<pre><code class=\"language-java\">//tryAcquire，和原方法名不同是因为tryAcquire间接调用了此方法，就不贴上来了\nfinal boolean nonfairTryAcquire(int acquires) {\n    final Thread current = Thread.currentThread();\n    int c = getState();\t\t\t\t\t\t\t//获取当前锁状态\n    if (c == 0) {\n        if (compareAndSetState(0, acquires)) {\t//如果锁空闲，CAS尝试获取锁\n            setExclusiveOwnerThread(current);\n            return true;\n        }\n    }\n    else if (current == getExclusiveOwnerThread()) { //重入该锁，可重入性\n        int nextc = c + acquires;\n        if (nextc &lt; 0) // overflow\n            throw new Error(&quot;Maximum lock count exceeded&quot;);\n        setState(nextc);\n        return true;\n    }\n    return false;\n}\n\n//tryRelease\nprotected final boolean tryRelease(int releases) {\n    int c = getState() - releases;\t\t\t\t\t\t\t //释放锁\t\t\t\t\n    if (Thread.currentThread() != getExclusiveOwnerThread()) //不是锁的持有者无法释放锁\n        throw new IllegalMonitorStateException();\n    boolean free = false;\n    if (c == 0) {\t\t\t\t\t\t\t\t\t\t\t\n        free = true;\n        setExclusiveOwnerThread(null);\t \t//如果释放后state=0，将锁设为空闲，取消线程独占\n    }\n    setState(c);\n    return free;\n}\n\n//isHeldExclusively，确认此线程是否持有锁\nprotected final boolean isHeldExclusively() {\n    // While we must in general read state before owner,\n    // we don't need to do so to check if current thread is owner\n    return getExclusiveOwnerThread() == Thread.currentThread();\n}\n</code></pre>\n</li>\n<li>\n<p><code>NonfairSync</code>和<code>FairSync</code>的区别</p>\n<pre><code class=\"language-java\">//公平锁\nint c = getState();\nif (c == 0) {\n    if (!hasQueuedPredecessors() &amp;&amp;         //此处多一个是否为sync队首的判断，该方法来自AQS\n        compareAndSetState(0, acquires)) {\n        setExclusiveOwnerThread(current);\n        return true;\n    }\n}\n</code></pre>\n</li>\n</ul>\n<hr class=\"footnotes-sep\">\n<section class=\"footnotes\">\n<ol class=\"footnotes-list\">\n<li id=\"fn1\" class=\"footnote-item\"><p>参考文章：<a href=\"https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html\" target=\"_blank\" rel=\"noopener\">从ReentrantLock的实现看AQS的原理及应用</a> <a href=\"#fnref1\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n</ol>\n</section>\n<script src=\"https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js\"></script><script>if (typeof lightGallery !== 'undefined') {\n        var options = {\n            selector: '.gallery-item'\n        };\n        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);\n        }</script>","categories":[{"name":"Java","path":"api/categories/Java.json"}],"tags":[{"name":"concurrency","path":"api/tags/concurrency.json"}]}