{"title":"JDK 缓存清单","slug":"缓存清单","date":"2020-03-01T06:56:02.000Z","updated":"2020-03-01T09:45:54.196Z","comments":true,"path":"api/articles/缓存清单.json","excerpt":"Abstract：简单整理Java中出现的各种缓存","covers":null,"content":"<link rel=\"stylesheet\" type=\"text/css\" href=\"https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css\"><div class=\".article-gallery\" <p><strong>Abstract</strong>：简单整理<code>Java</code>中出现的各种缓存<p></p>\n<a id=\"more\"></a>\n<h2 id=\"什么东西需要缓存？\">什么东西需要缓存？</h2>\n<p>缓存的一般都是对象，即在<strong>堆</strong>上存储的数据，它们具备以下特点：</p>\n<ul>\n<li>数据量小</li>\n<li>需要频繁访问读取</li>\n</ul>\n<h2 id=\"缓存的时机\">缓存的时机</h2>\n<p>根据不同类型的缓存分类讨论</p>\n<h1 id=\"初始化缓存：基本数据类型缓存池\">初始化缓存：基本数据类型缓存池</h1>\n<p>Java中的基本数据类型的包装类，诸如<code>Integer</code>、<code>Long</code>、<code>Short</code>，均设有对应的缓存池</p>\n<p>缓存的时机是包装类被加载进内存时，缓存代码写在对应包装类的<code>static</code>块中，以<code>Integer</code>为例</p>\n<pre><code class=\"language-java\">static final int low = -128;\nstatic final int high;\nstatic final Integer cache[];\n\n//缓存了-128 ~ 127 之间的数\nstatic {\n    // high value may be configured by property\n    int h = 127;\n    String integerCacheHighPropValue =\n        sun.misc.VM.getSavedProperty(&quot;java.lang.Integer.IntegerCache.high&quot;);\n    if (integerCacheHighPropValue != null) {\n        try {\n            int i = parseInt(integerCacheHighPropValue);\n            i = Math.max(i, 127);\n            // Maximum array size is Integer.MAX_VALUE ： 如果缓存池大小指定比127大，就会扩大缓存池\n            h = Math.min(i, Integer.MAX_VALUE - (-low) -1);\n        } catch( NumberFormatException nfe) {\n            // If the property cannot be parsed into an int, ignore it.\n        }\n    }\n    high = h;\n\n    cache = new Integer[(high - low) + 1]; //new 出缓存\n    int j = low;\n    for(int k = 0; k &lt; cache.length; k++)\n        cache[k] = new Integer(j++);\n\n    // range [-128, 127] must be interned (JLS7 5.1.7)\n    assert IntegerCache.high &gt;= 127;\n}\n\n</code></pre>\n<h2 id=\"其他包装类的默认缓存范围：\">其他包装类的默认缓存范围：</h2>\n<p>（<strong>但是注意一下：这个缓存范围并不是固定的，可以通过调整JVM参数 XX:AutoBoxCacheMax = &lt; size &gt; 来修改缓存池的大小</strong>）</p>\n<ul>\n<li>boolean values true and false</li>\n<li>all byte values</li>\n<li>short values between -128 and 127</li>\n<li>int values between -128 and 127</li>\n<li>char in the range \\u0000 to \\u007F</li>\n</ul>\n<p>​</p>\n<h1 id=\"懒缓存：String-Pool\">懒缓存：String Pool</h1>\n<p>String Pool本质上是<strong>常量池</strong>，当然也可以认为它是缓存，（<strong>另外注意一下</strong>：jdk7及以前，String Pool都是在<strong>Perm</strong>即永久代，而不是堆上，这里不作讨论）</p>\n<p><strong>String的不变性支持了String Pool的实现（final修饰符）</strong>：</p>\n<ul>\n<li>由于hash值不变，如果缓存中存在“aba”字符串，那么我们可以通过hash直接引用到该对象，而不是重新<strong>new</strong></li>\n<li>另外不变性间接使String变为<strong>线程安全</strong>的类</li>\n</ul>\n<pre><code class=\"language-java\">String s1 = new String(&quot;aaa&quot;);\nString s2 = new String(&quot;aaa&quot;);\nSystem.out.println(s1 == s2);           // false\nString s3 = s1.intern();\nString s4 = s1.intern();\nSystem.out.println(s3 == s4);           // true\n</code></pre>\n<h2 id=\"intern-是怎么回事？\">intern()是怎么回事？<sup class=\"footnote-ref\"><a href=\"#fn1\" id=\"fnref1\">[1]</a></sup></h2>\n<ul>\n<li>\n<p>如果String Pool中已经存在该字符串，那么就直接返回，否则添加进常量池后返回（<strong>缓存初始化</strong>）</p>\n</li>\n<li>\n<p>根据openjdk，本质上最后是调用了c++中的<code>StringTable::intern</code>方法</p>\n<pre><code class=\"language-c++\">oop StringTable::intern(Handle string_or_null, jchar* name,  \n                        int len, TRAPS) {  \n    unsigned int hashValue = java_lang_String::hash_string(name, len); //计算hash值 \n    int index = the_table()-&gt;hash_to_index(hashValue);                 //计算hash索引\n    oop string = the_table()-&gt;lookup(index, name, len, hashValue);     //查找常量池\n    // Found  \n    if (string != NULL) return string;  \n    // Otherwise, add to symbol to table  \n    return the_table()-&gt;basic_add(index, string_or_null, name, len,    //如果不存在，则先加入常量池\n                                  hashValue, CHECK_NULL);  \n}\n</code></pre>\n</li>\n<li>\n<p><code>intern()</code>的<mark>正确使用姿势</mark></p>\n<pre><code class=\"language-java\">for (int i = 0; i &lt; MAX; i++) {\n    //arr[i] = new String(String.valueOf(DB_DATA[i % DB_DATA.length]));\n    arr[i] = new String(String.valueOf(DB_DATA[i % DB_DATA.length])).intern();\n}\n</code></pre>\n<p><strong>当然，前提是缓存的目标大多都是不变的，如果缓存的String大量变动，就会对String Pool造成巨大的压力</strong></p>\n</li>\n</ul>\n<h1 id=\"未完待续…知道了新的再补充吧​！🕊\">未完待续…知道了新的再补充吧​！🕊</h1>\n<hr class=\"footnotes-sep\">\n<section class=\"footnotes\">\n<ol class=\"footnotes-list\">\n<li id=\"fn1\" class=\"footnote-item\"><p><a href=\"https://tech.meituan.com/2014/03/06/in-depth-understanding-string-intern.html\" target=\"_blank\" rel=\"noopener\">深入解析String#intern</a> <a href=\"#fnref1\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n</ol>\n</section>\n</div><script src=\"https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js\"></script><script>if (typeof lightGallery !== 'undefined') {\n        var options = {\n            selector: '.gallery-item'\n        };\n        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);\n        }</script>","more":"<h2 id=\"什么东西需要缓存？\">什么东西需要缓存？</h2>\n<p>缓存的一般都是对象，即在<strong>堆</strong>上存储的数据，它们具备以下特点：</p>\n<ul>\n<li>数据量小</li>\n<li>需要频繁访问读取</li>\n</ul>\n<h2 id=\"缓存的时机\">缓存的时机</h2>\n<p>根据不同类型的缓存分类讨论</p>\n<h1 id=\"初始化缓存：基本数据类型缓存池\">初始化缓存：基本数据类型缓存池</h1>\n<p>Java中的基本数据类型的包装类，诸如<code>Integer</code>、<code>Long</code>、<code>Short</code>，均设有对应的缓存池</p>\n<p>缓存的时机是包装类被加载进内存时，缓存代码写在对应包装类的<code>static</code>块中，以<code>Integer</code>为例</p>\n<pre><code class=\"language-java\">static final int low = -128;\nstatic final int high;\nstatic final Integer cache[];\n\n//缓存了-128 ~ 127 之间的数\nstatic {\n    // high value may be configured by property\n    int h = 127;\n    String integerCacheHighPropValue =\n        sun.misc.VM.getSavedProperty(&quot;java.lang.Integer.IntegerCache.high&quot;);\n    if (integerCacheHighPropValue != null) {\n        try {\n            int i = parseInt(integerCacheHighPropValue);\n            i = Math.max(i, 127);\n            // Maximum array size is Integer.MAX_VALUE ： 如果缓存池大小指定比127大，就会扩大缓存池\n            h = Math.min(i, Integer.MAX_VALUE - (-low) -1);\n        } catch( NumberFormatException nfe) {\n            // If the property cannot be parsed into an int, ignore it.\n        }\n    }\n    high = h;\n\n    cache = new Integer[(high - low) + 1]; //new 出缓存\n    int j = low;\n    for(int k = 0; k &lt; cache.length; k++)\n        cache[k] = new Integer(j++);\n\n    // range [-128, 127] must be interned (JLS7 5.1.7)\n    assert IntegerCache.high &gt;= 127;\n}\n\n</code></pre>\n<h2 id=\"其他包装类的默认缓存范围：\">其他包装类的默认缓存范围：</h2>\n<p>（<strong>但是注意一下：这个缓存范围并不是固定的，可以通过调整JVM参数 XX:AutoBoxCacheMax = &lt; size &gt; 来修改缓存池的大小</strong>）</p>\n<ul>\n<li>boolean values true and false</li>\n<li>all byte values</li>\n<li>short values between -128 and 127</li>\n<li>int values between -128 and 127</li>\n<li>char in the range \\u0000 to \\u007F</li>\n</ul>\n<p>​</p>\n<h1 id=\"懒缓存：String-Pool\">懒缓存：String Pool</h1>\n<p>String Pool本质上是<strong>常量池</strong>，当然也可以认为它是缓存，（<strong>另外注意一下</strong>：jdk7及以前，String Pool都是在<strong>Perm</strong>即永久代，而不是堆上，这里不作讨论）</p>\n<p><strong>String的不变性支持了String Pool的实现（final修饰符）</strong>：</p>\n<ul>\n<li>由于hash值不变，如果缓存中存在“aba”字符串，那么我们可以通过hash直接引用到该对象，而不是重新<strong>new</strong></li>\n<li>另外不变性间接使String变为<strong>线程安全</strong>的类</li>\n</ul>\n<pre><code class=\"language-java\">String s1 = new String(&quot;aaa&quot;);\nString s2 = new String(&quot;aaa&quot;);\nSystem.out.println(s1 == s2);           // false\nString s3 = s1.intern();\nString s4 = s1.intern();\nSystem.out.println(s3 == s4);           // true\n</code></pre>\n<h2 id=\"intern-是怎么回事？\">intern()是怎么回事？<sup class=\"footnote-ref\"><a href=\"#fn1\" id=\"fnref1\">[1]</a></sup></h2>\n<ul>\n<li>\n<p>如果String Pool中已经存在该字符串，那么就直接返回，否则添加进常量池后返回（<strong>缓存初始化</strong>）</p>\n</li>\n<li>\n<p>根据openjdk，本质上最后是调用了c++中的<code>StringTable::intern</code>方法</p>\n<pre><code class=\"language-c++\">oop StringTable::intern(Handle string_or_null, jchar* name,  \n                        int len, TRAPS) {  \n    unsigned int hashValue = java_lang_String::hash_string(name, len); //计算hash值 \n    int index = the_table()-&gt;hash_to_index(hashValue);                 //计算hash索引\n    oop string = the_table()-&gt;lookup(index, name, len, hashValue);     //查找常量池\n    // Found  \n    if (string != NULL) return string;  \n    // Otherwise, add to symbol to table  \n    return the_table()-&gt;basic_add(index, string_or_null, name, len,    //如果不存在，则先加入常量池\n                                  hashValue, CHECK_NULL);  \n}\n</code></pre>\n</li>\n<li>\n<p><code>intern()</code>的<mark>正确使用姿势</mark></p>\n<pre><code class=\"language-java\">for (int i = 0; i &lt; MAX; i++) {\n    //arr[i] = new String(String.valueOf(DB_DATA[i % DB_DATA.length]));\n    arr[i] = new String(String.valueOf(DB_DATA[i % DB_DATA.length])).intern();\n}\n</code></pre>\n<p><strong>当然，前提是缓存的目标大多都是不变的，如果缓存的String大量变动，就会对String Pool造成巨大的压力</strong></p>\n</li>\n</ul>\n<h1 id=\"未完待续…知道了新的再补充吧​！🕊\">未完待续…知道了新的再补充吧​！🕊</h1>\n<hr class=\"footnotes-sep\">\n<section class=\"footnotes\">\n<ol class=\"footnotes-list\">\n<li id=\"fn1\" class=\"footnote-item\"><p><a href=\"https://tech.meituan.com/2014/03/06/in-depth-understanding-string-intern.html\" target=\"_blank\" rel=\"noopener\">深入解析String#intern</a> <a href=\"#fnref1\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n</ol>\n</section>\n<script src=\"https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js\"></script><script>if (typeof lightGallery !== 'undefined') {\n        var options = {\n            selector: '.gallery-item'\n        };\n        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);\n        }</script>","categories":[{"name":"Java","path":"api/categories/Java.json"}],"tags":[{"name":"cache","path":"api/tags/cache.json"}]}