{"title":"Design","slug":"Design","date":"2020-03-07T14:01:23.000Z","updated":"2020-03-07T14:17:00.978Z","comments":true,"path":"api/articles/Design.json","excerpt":"Abstract：leetcode Design专题题解","covers":["image-20200307220507721.png"],"content":"<link rel=\"stylesheet\" type=\"text/css\" href=\"https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css\"><div class=\".article-gallery\" <p><strong>Abstract</strong>：leetcode Design专题题解<p></p>\n<a id=\"more\"></a>\n<h1 id=\"面试题59-II-队列的最大值\"><a href=\"https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/\" target=\"_blank\" rel=\"noopener\">面试题59 - II. 队列的最大值</a></h1>\n<p><a href=\"Design/image-20200307220507721.png\" title=\"image-20200307220507721\" class=\"gallery-item\"><img src=\"image-20200307220507721.png\" alt=\"image-20200307220507721\"></a></p>\n<h2 id=\"解法一：辅助队列\">解法一：辅助队列</h2>\n<p>和minStack有点像，当然minStack可以不需要不需要辅助栈，是因为先进后出的特性</p>\n<ul>\n<li><strong>辅助队列如何记录最大值？</strong>\n<ul>\n<li>队首维护最大值</li>\n<li>对于新加入的value，从队尾找起，如果队列中存在比value小的，统统删掉，因为它们不会影响最大值的结果</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"完整实现\">完整实现</h3>\n<pre><code class=\"language-java\">class MaxQueue {\n\n    private LinkedList&lt;Integer&gt; q;\n    private LinkedList&lt;Integer&gt; helper;\n\n    public MaxQueue() {\n        q=new LinkedList&lt;&gt;();\n        helper=new LinkedList&lt;&gt;();\n    }\n    \n    public int max_value() {\n        if(helper.size()!=0)return helper.getFirst();\n        return -1;\n    }\n    \n    public void push_back(int value) {\n        while(helper.size()!=0 &amp;&amp; value&gt;helper.getLast())\n            helper.removeLast();                     //从队尾找起，小于value的统统删掉\n        q.add(value);\n        helper.add(value);\n    }\n    \n    public int pop_front() {\n        if(q.size()!=0){\n            int e=q.removeFirst();\n            if(e==helper.getFirst())               //如果pop的是最大值，则同步一下helper\n                helper.removeFirst();\n            return e;\n        }\n        return -1;\n    }\n}\n\n/**\n * Your MaxQueue object will be instantiated and called as such:\n * MaxQueue obj = new MaxQueue();\n * int param_1 = obj.max_value();\n * obj.push_back(value);\n * int param_3 = obj.pop_front();\n */\n</code></pre>\n</div><script src=\"https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js\"></script><script>if (typeof lightGallery !== 'undefined') {\n        var options = {\n            selector: '.gallery-item'\n        };\n        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);\n        }</script>","more":"<h1 id=\"面试题59-II-队列的最大值\"><a href=\"https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/\" target=\"_blank\" rel=\"noopener\">面试题59 - II. 队列的最大值</a></h1>\n<p><a href=\"Design/image-20200307220507721.png\" title=\"image-20200307220507721\" class=\"gallery-item\"><img src=\"image-20200307220507721.png\" alt=\"image-20200307220507721\"></a></p>\n<h2 id=\"解法一：辅助队列\">解法一：辅助队列</h2>\n<p>和minStack有点像，当然minStack可以不需要不需要辅助栈，是因为先进后出的特性</p>\n<ul>\n<li><strong>辅助队列如何记录最大值？</strong>\n<ul>\n<li>队首维护最大值</li>\n<li>对于新加入的value，从队尾找起，如果队列中存在比value小的，统统删掉，因为它们不会影响最大值的结果</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"完整实现\">完整实现</h3>\n<pre><code class=\"language-java\">class MaxQueue {\n\n    private LinkedList&lt;Integer&gt; q;\n    private LinkedList&lt;Integer&gt; helper;\n\n    public MaxQueue() {\n        q=new LinkedList&lt;&gt;();\n        helper=new LinkedList&lt;&gt;();\n    }\n    \n    public int max_value() {\n        if(helper.size()!=0)return helper.getFirst();\n        return -1;\n    }\n    \n    public void push_back(int value) {\n        while(helper.size()!=0 &amp;&amp; value&gt;helper.getLast())\n            helper.removeLast();                     //从队尾找起，小于value的统统删掉\n        q.add(value);\n        helper.add(value);\n    }\n    \n    public int pop_front() {\n        if(q.size()!=0){\n            int e=q.removeFirst();\n            if(e==helper.getFirst())               //如果pop的是最大值，则同步一下helper\n                helper.removeFirst();\n            return e;\n        }\n        return -1;\n    }\n}\n\n/**\n * Your MaxQueue object will be instantiated and called as such:\n * MaxQueue obj = new MaxQueue();\n * int param_1 = obj.max_value();\n * obj.push_back(value);\n * int param_3 = obj.pop_front();\n */\n</code></pre>\n<script src=\"https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js\"></script><script>if (typeof lightGallery !== 'undefined') {\n        var options = {\n            selector: '.gallery-item'\n        };\n        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);\n        }</script>","categories":[{"name":"Algorithm","path":"api/categories/Algorithm.json"}],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"}]}