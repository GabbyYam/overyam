{"title":"LinkedList-Hard","slug":"LinkedList-Hard","date":"2020-05-15T17:41:58.000Z","updated":"2020-05-23T07:29:47.955Z","comments":true,"path":"api/articles/LinkedList-Hard.json","excerpt":"Abstract：leetcode 链表相关 困难难度 合集","covers":["image-20200516014318736.png"],"content":"<link rel=\"stylesheet\" type=\"text/css\" href=\"https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css\"><div class=\".article-gallery\" <p><strong>Abstract</strong>：leetcode 链表相关 困难难度 合集<p></p>\n<a id=\"more\"></a>\n<h1 id=\"25-Reverse-Nodes-in-k-Group\"><a href=\"https://leetcode-cn.com/problems/reverse-nodes-in-k-group/\" target=\"_blank\" rel=\"noopener\">25. Reverse Nodes in k-Group</a></h1>\n<p><a href=\"LinkedList-Hard/image-20200516014318736.png\" title=\"image-20200516014318736\" class=\"gallery-item\"><img src=\"image-20200516014318736.png\" alt=\"image-20200516014318736\"></a></p>\n<h2 id=\"解法一\">解法一</h2>\n<p>反转链表，k个一组反转，按题意模拟就行，改造原来的reverse函数，增加添加头尾的功能，会让这题简单很多</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    int getLength(ListNode* head) {\n        int len = 0;\n        while(head) {\n            head = head-&gt;next;\n            len++;\n        }\n        return len;\n    }\n\n    ListNode* reverseKGroup(ListNode* head, int k) {\n        int len = getLength(head);\n        if(k &gt; len) return head;\n        ListNode* dummy = new ListNode(-1), * curr = dummy, * prev = curr;\n        dummy-&gt;next = head;\n        while(curr) {\n            prev = curr;\n            for(int i = 0; i &lt; k; i++) {\n                curr = curr-&gt;next;\n                if(curr == NULL) return dummy-&gt;next;\n            }\n            ListNode* next = curr-&gt;next;\n            curr-&gt;next = NULL;\n            curr = reverse(prev-&gt;next, next, prev);\n             \n        }\n        return dummy-&gt;next;\n    }\n\n    ListNode* reverse(ListNode* head, ListNode* tail, ListNode* front) {\n        ListNode* prev = tail, *curr = head;\n        while(curr) {\n            ListNode* next = curr-&gt;next;\n            curr-&gt;next = prev;\n            prev = curr;\n            curr = next;\n        }\n        if(front) front-&gt;next = prev;\n        return head;\n    }\n};\n</code></pre>\n</div><script src=\"https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js\"></script><script>if (typeof lightGallery !== 'undefined') {\n        var options = {\n            selector: '.gallery-item'\n        };\n        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);\n        }</script>","more":"<h1 id=\"25-Reverse-Nodes-in-k-Group\"><a href=\"https://leetcode-cn.com/problems/reverse-nodes-in-k-group/\" target=\"_blank\" rel=\"noopener\">25. Reverse Nodes in k-Group</a></h1>\n<p><a href=\"LinkedList-Hard/image-20200516014318736.png\" title=\"image-20200516014318736\" class=\"gallery-item\"><img src=\"image-20200516014318736.png\" alt=\"image-20200516014318736\"></a></p>\n<h2 id=\"解法一\">解法一</h2>\n<p>反转链表，k个一组反转，按题意模拟就行，改造原来的reverse函数，增加添加头尾的功能，会让这题简单很多</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    int getLength(ListNode* head) {\n        int len = 0;\n        while(head) {\n            head = head-&gt;next;\n            len++;\n        }\n        return len;\n    }\n\n    ListNode* reverseKGroup(ListNode* head, int k) {\n        int len = getLength(head);\n        if(k &gt; len) return head;\n        ListNode* dummy = new ListNode(-1), * curr = dummy, * prev = curr;\n        dummy-&gt;next = head;\n        while(curr) {\n            prev = curr;\n            for(int i = 0; i &lt; k; i++) {\n                curr = curr-&gt;next;\n                if(curr == NULL) return dummy-&gt;next;\n            }\n            ListNode* next = curr-&gt;next;\n            curr-&gt;next = NULL;\n            curr = reverse(prev-&gt;next, next, prev);\n             \n        }\n        return dummy-&gt;next;\n    }\n\n    ListNode* reverse(ListNode* head, ListNode* tail, ListNode* front) {\n        ListNode* prev = tail, *curr = head;\n        while(curr) {\n            ListNode* next = curr-&gt;next;\n            curr-&gt;next = prev;\n            prev = curr;\n            curr = next;\n        }\n        if(front) front-&gt;next = prev;\n        return head;\n    }\n};\n</code></pre>\n<script src=\"https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js\"></script><script>if (typeof lightGallery !== 'undefined') {\n        var options = {\n            selector: '.gallery-item'\n        };\n        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);\n        }</script>","categories":[{"name":"Algorithm","path":"api/categories/Algorithm.json"}],"tags":[{"name":"Leetcode","path":"api/tags/Leetcode.json"}]}