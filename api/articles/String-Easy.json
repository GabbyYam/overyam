{"title":"String-Easy","slug":"String-Easy","date":"2020-02-26T15:17:22.000Z","updated":"2020-02-27T13:59:01.900Z","comments":true,"path":"api/articles/String-Easy.json","excerpt":"Abstract： 更新部分Easy难度 string相关题解","covers":["image-20200226235254934.png","image-20200226235312264.png","image-20200226235335075.png","image-20200226235401209.png","image-20200226235519434.png"],"content":"<link rel=\"stylesheet\" type=\"text/css\" href=\"https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css\"><div class=\".article-gallery\" <p><strong>Abstract：</strong> 更新部分<code>Easy</code>难度 <code>string</code>相关题解<p></p>\n<a id=\"more\"></a>\n<h1 id=\"13-Roman-to-Integer\"><a href=\"https://leetcode-cn.com/problems/roman-to-integer/\" target=\"_blank\" rel=\"noopener\">13. Roman to Integer</a></h1>\n<p><a href=\"String-Easy/image-20200226235254934.png\" title=\"image-20200226235254934\" class=\"gallery-item\"><img src=\"image-20200226235254934.png\" alt=\"image-20200226235254934\"></a></p>\n<h2 id=\"解法一：Hash表\">解法一：Hash表</h2>\n<p>优先判定两个字符的值，其他没什么可说的</p>\n<pre><code class=\"language-java\">class Solution {\n    public int romanToInt(String s) {\n        Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;();\n        map.put(&quot;I&quot;, 1);\n        map.put(&quot;IV&quot;, 4);\n        map.put(&quot;V&quot;, 5);\n        map.put(&quot;IX&quot;, 9);\n        map.put(&quot;X&quot;, 10);\n        map.put(&quot;XL&quot;, 40);\n        map.put(&quot;L&quot;, 50);\n        map.put(&quot;XC&quot;, 90);\n        map.put(&quot;C&quot;, 100);\n        map.put(&quot;CD&quot;, 400);\n        map.put(&quot;D&quot;, 500);\n        map.put(&quot;CM&quot;, 900);\n        map.put(&quot;M&quot;, 1000);\n        \n        int ans=0;\n        for(int i=0;i&lt;s.length();i++){\n            if(i+1&lt;s.length() &amp;&amp; map.containsKey(s.substring(i,i+2))){\n                ans+=map.get(s.substring(i,i+2));\n                i++;\n            }\n            else ans+=map.get(s.substring(i,i+1));\n        }\n        return ans;\n    }\n}\n</code></pre>\n<h1 id=\"14-Longest-Common-Prefix\"><a href=\"https://leetcode-cn.com/problems/longest-common-prefix/\" target=\"_blank\" rel=\"noopener\">14. Longest Common Prefix</a></h1>\n<p><a href=\"String-Easy/image-20200226235312264.png\" title=\"image-20200226235312264\" class=\"gallery-item\"><img src=\"image-20200226235312264.png\" alt=\"image-20200226235312264\"></a></p>\n<h2 id=\"解法一：线性扫描（从前往后）\">解法一：线性扫描（从前往后）</h2>\n<pre><code class=\"language-java\">class Solution {\n    public String longestCommonPrefix(String[] strs) {\n        if(strs.length==0 || strs==null){return &quot;&quot;;}\n        String common=&quot;&quot;;\n        int min_len=Integer.MAX_VALUE;\n        for(String s:strs){min_len=Math.min(min_len,s.length());} //先找最小长度min_len\n        for(int curr=0;curr&lt;min_len;curr++){\n            char c=strs[0].charAt(curr); //以第一个为准\n            for(String s:strs){if(s.charAt(curr)!=c)return common;}\n            common+=c;\n        }\n        return common;\n    }\n}\n</code></pre>\n<p><mark><strong>[改进版]</strong></mark></p>\n<ul>\n<li><strong>String</strong> ：改进了String的操作相关，String重载的 <mark>+操作</mark> 相当耗时，因此不使用<strong>字符串拼接</strong>，而是<strong>substring</strong> 的方法</li>\n<li><strong>遍历：</strong> 根本不需要找到最短的字符串，只要遍历时多判断一次是否超出就行了</li>\n<li><strong>效果：</strong> 12ms -&gt;2ms</li>\n</ul>\n<pre><code class=\"language-java\">class Solution {\n    public String longestCommonPrefix(String[] strs) {\n        if(strs.length==0 || strs==null){return &quot;&quot;;}\n        for(int curr=0;curr&lt;strs[0].length();curr++){\n            char c=strs[0].charAt(curr);\n            for(String s:strs){\n                if(s.length()==curr || s.charAt(curr)!=c) //新增s.length()==curr判断一下就行\n                    return strs[0].substring(0,curr); //改为substring,String+操作是相当费时的\n            }\n        }\n        return strs[0];\n    }\n}\n</code></pre>\n<h2 id=\"解法二：线性扫描（从后往前）\">解法二：线性扫描（从后往前）</h2>\n<pre><code class=\"language-java\">public String longestCommonPrefix(String[] strs) {\n   if (strs.length == 0) return &quot;&quot;;\n   String prefix = strs[0];\n   for (int i = 1; i &lt; strs.length; i++)\n       while (strs[i].indexOf(prefix) != 0) { //以第一个为准\n           prefix = prefix.substring(0, prefix.length() - 1); //如果不满足，每次缩小一个字符\n           if (prefix.isEmpty()) return &quot;&quot;; //直到为空\n       }        \n   return prefix;\n}\n</code></pre>\n<h1 id=\"20-Valid-Parentheses\"><a href=\"https://leetcode-cn.com/problems/valid-parentheses/\" target=\"_blank\" rel=\"noopener\">20. Valid Parentheses</a></h1>\n<p><a href=\"String-Easy/image-20200226235335075.png\" title=\"image-20200226235335075\" class=\"gallery-item\"><img src=\"image-20200226235335075.png\" alt=\"image-20200226235335075\"></a></p>\n<h2 id=\"解法一：栈（标准解法）\">解法一：栈（标准解法）</h2>\n<pre><code class=\"language-java\">class Solution {\n    public boolean isValid(String s) {\n        Stack&lt;Character&gt; stack = new Stack&lt;Character&gt;();\n        for(int curr=0;curr&lt;s.length();curr++){\n            char c=s.charAt(curr);\n            if(c=='(' || c=='[' || c=='{') //如果是左括号，压入栈中\n                stack.push(c);\n            else if(c==')'){               //如果是右括号，检查栈是否为空，不为空的话检查是否匹配\n                if(stack.isEmpty() || stack.pop()!='(')return false; //注意isEmpty在前\n            }\n            else if(c==']'){\n                if(stack.isEmpty() || stack.pop()!='[')return false;\n            }\n            else if(c=='}'){\n                if(stack.isEmpty() || stack.pop()!='{')return false;\n            }\n        }\n        return stack.isEmpty();//最后如果栈空则为ture,否则为false\n    }\n}\n</code></pre>\n<h1 id=\"28-Implement-strStr\"><a href=\"https://leetcode-cn.com/problems/implement-strstr/\" target=\"_blank\" rel=\"noopener\">28. Implement strStr()</a></h1>\n<p><a href=\"String-Easy/image-20200226235401209.png\" title=\"image-20200226235401209\" class=\"gallery-item\"><img src=\"image-20200226235401209.png\" alt=\"image-20200226235401209\"></a></p>\n<h2 id=\"解法一：猥琐API法（太脏了，自裁）\">解法一：猥琐API法（<mark>太脏了，自裁</mark>）</h2>\n<pre><code class=\"language-java\">class Solution {\n    public int strStr(String haystack, String needle) {\n        return haystack.indexOf(needle); //这题要实现的就是indexOf的功能\n    }\n}\n</code></pre>\n<h2 id=\"解法二：暴力匹配\">解法二：暴力匹配</h2>\n<pre><code class=\"language-java\">class Solution {\n    public int strStr(String haystack, String needle) {\n        //以下三者均会卡掉for循环，需要特别处理，且equals要第一个判定，否则第二条需要进一步限定\n        if(haystack.equals(needle))return 0;                     //字典等于词\n        if(haystack.length()==0)return -1;                       //字典为空\n        if(needle.length()==0) return 0;                         //词为空\n        \n        //注意curr_hay&lt;haystack.length()-needle.length()+1，必须+1，否则匹配不到最后一位\n        for(int curr_hay=0;curr_hay&lt;haystack.length()-needle.length()+1;curr_hay++){\n            for(int curr_nee=0;curr_nee&lt;needle.length();curr_nee++){\n                if(haystack.charAt(curr_hay+curr_nee)!=needle.charAt(curr_nee))\n                    break;\n                if(curr_nee==needle.length()-1)//匹配到最后一个依然正确，返回此时的curr_hay\n                    return curr_hay;\n            }\n        }\n        return -1; //没找到则返回-1\n    }\n}\n</code></pre>\n<h2 id=\"解法三：KMP（以后再说吧）\">解法三：KMP（<mark>以后再说吧</mark>）</h2>\n<pre><code class=\"language-java\">//问就是不会\n</code></pre>\n<h1 id=\"58-Length-of-Last-Word\"><a href=\"https://leetcode-cn.com/problems/length-of-last-word/\" target=\"_blank\" rel=\"noopener\">58. Length of Last Word</a></h1>\n<p><a href=\"String-Easy/image-20200226235519434.png\" title=\"image-20200226235519434\" class=\"gallery-item\"><img src=\"image-20200226235519434.png\" alt=\"image-20200226235519434\"></a></p>\n<h2 id=\"要点分析\">要点分析</h2>\n<ul>\n<li><strong>特殊情况</strong>：末尾有空格</li>\n<li>如何找到最后一个空格？</li>\n<li>连续空格怎么处理？</li>\n</ul>\n<h2 id=\"解法一：分段切割\">解法一：分段切割</h2>\n<ul>\n<li><strong>缺点</strong>：substring耗时，trim耗时</li>\n</ul>\n<pre><code class=\"language-java\">class Solution {\n    public int lengthOfLastWord(String s) {\n       s=s.trim(); //开局剪切，保证末尾没有空格\n       String res=s;\n       for(int i=0;i&lt;s.length();i++){\n           if(s.charAt(i)==' ')res=s.substring(i+1,s.length()); //每遇到一个空格，把前面的砍掉\n       }\n       return res.length(); //最后的长度即为所求\n    }\n}\n</code></pre>\n<ul>\n<li>改进版，从后往前切割，大大节省时间</li>\n</ul>\n<pre><code class=\"language-java\">class Solution {\n    public int lengthOfLastWord(String s) {\n       s=s.trim(); //开局剪切，保证末尾没有空格\n       String res=s;\n       for(int i=s.length()-1;i&gt;-1;i--){ //从后往前砍\n           if(s.charAt(i)==' '){return s.substring(i+1,s.length());}\n       }\n       return res.length(); //最后的长度即为所求\n    }\n}\n</code></pre>\n</div><script src=\"https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js\"></script><script>if (typeof lightGallery !== 'undefined') {\n        var options = {\n            selector: '.gallery-item'\n        };\n        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);\n        }</script>","more":"<h1 id=\"13-Roman-to-Integer\"><a href=\"https://leetcode-cn.com/problems/roman-to-integer/\" target=\"_blank\" rel=\"noopener\">13. Roman to Integer</a></h1>\n<p><a href=\"String-Easy/image-20200226235254934.png\" title=\"image-20200226235254934\" class=\"gallery-item\"><img src=\"image-20200226235254934.png\" alt=\"image-20200226235254934\"></a></p>\n<h2 id=\"解法一：Hash表\">解法一：Hash表</h2>\n<p>优先判定两个字符的值，其他没什么可说的</p>\n<pre><code class=\"language-java\">class Solution {\n    public int romanToInt(String s) {\n        Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;();\n        map.put(&quot;I&quot;, 1);\n        map.put(&quot;IV&quot;, 4);\n        map.put(&quot;V&quot;, 5);\n        map.put(&quot;IX&quot;, 9);\n        map.put(&quot;X&quot;, 10);\n        map.put(&quot;XL&quot;, 40);\n        map.put(&quot;L&quot;, 50);\n        map.put(&quot;XC&quot;, 90);\n        map.put(&quot;C&quot;, 100);\n        map.put(&quot;CD&quot;, 400);\n        map.put(&quot;D&quot;, 500);\n        map.put(&quot;CM&quot;, 900);\n        map.put(&quot;M&quot;, 1000);\n        \n        int ans=0;\n        for(int i=0;i&lt;s.length();i++){\n            if(i+1&lt;s.length() &amp;&amp; map.containsKey(s.substring(i,i+2))){\n                ans+=map.get(s.substring(i,i+2));\n                i++;\n            }\n            else ans+=map.get(s.substring(i,i+1));\n        }\n        return ans;\n    }\n}\n</code></pre>\n<h1 id=\"14-Longest-Common-Prefix\"><a href=\"https://leetcode-cn.com/problems/longest-common-prefix/\" target=\"_blank\" rel=\"noopener\">14. Longest Common Prefix</a></h1>\n<p><a href=\"String-Easy/image-20200226235312264.png\" title=\"image-20200226235312264\" class=\"gallery-item\"><img src=\"image-20200226235312264.png\" alt=\"image-20200226235312264\"></a></p>\n<h2 id=\"解法一：线性扫描（从前往后）\">解法一：线性扫描（从前往后）</h2>\n<pre><code class=\"language-java\">class Solution {\n    public String longestCommonPrefix(String[] strs) {\n        if(strs.length==0 || strs==null){return &quot;&quot;;}\n        String common=&quot;&quot;;\n        int min_len=Integer.MAX_VALUE;\n        for(String s:strs){min_len=Math.min(min_len,s.length());} //先找最小长度min_len\n        for(int curr=0;curr&lt;min_len;curr++){\n            char c=strs[0].charAt(curr); //以第一个为准\n            for(String s:strs){if(s.charAt(curr)!=c)return common;}\n            common+=c;\n        }\n        return common;\n    }\n}\n</code></pre>\n<p><mark><strong>[改进版]</strong></mark></p>\n<ul>\n<li><strong>String</strong> ：改进了String的操作相关，String重载的 <mark>+操作</mark> 相当耗时，因此不使用<strong>字符串拼接</strong>，而是<strong>substring</strong> 的方法</li>\n<li><strong>遍历：</strong> 根本不需要找到最短的字符串，只要遍历时多判断一次是否超出就行了</li>\n<li><strong>效果：</strong> 12ms -&gt;2ms</li>\n</ul>\n<pre><code class=\"language-java\">class Solution {\n    public String longestCommonPrefix(String[] strs) {\n        if(strs.length==0 || strs==null){return &quot;&quot;;}\n        for(int curr=0;curr&lt;strs[0].length();curr++){\n            char c=strs[0].charAt(curr);\n            for(String s:strs){\n                if(s.length()==curr || s.charAt(curr)!=c) //新增s.length()==curr判断一下就行\n                    return strs[0].substring(0,curr); //改为substring,String+操作是相当费时的\n            }\n        }\n        return strs[0];\n    }\n}\n</code></pre>\n<h2 id=\"解法二：线性扫描（从后往前）\">解法二：线性扫描（从后往前）</h2>\n<pre><code class=\"language-java\">public String longestCommonPrefix(String[] strs) {\n   if (strs.length == 0) return &quot;&quot;;\n   String prefix = strs[0];\n   for (int i = 1; i &lt; strs.length; i++)\n       while (strs[i].indexOf(prefix) != 0) { //以第一个为准\n           prefix = prefix.substring(0, prefix.length() - 1); //如果不满足，每次缩小一个字符\n           if (prefix.isEmpty()) return &quot;&quot;; //直到为空\n       }        \n   return prefix;\n}\n</code></pre>\n<h1 id=\"20-Valid-Parentheses\"><a href=\"https://leetcode-cn.com/problems/valid-parentheses/\" target=\"_blank\" rel=\"noopener\">20. Valid Parentheses</a></h1>\n<p><a href=\"String-Easy/image-20200226235335075.png\" title=\"image-20200226235335075\" class=\"gallery-item\"><img src=\"image-20200226235335075.png\" alt=\"image-20200226235335075\"></a></p>\n<h2 id=\"解法一：栈（标准解法）\">解法一：栈（标准解法）</h2>\n<pre><code class=\"language-java\">class Solution {\n    public boolean isValid(String s) {\n        Stack&lt;Character&gt; stack = new Stack&lt;Character&gt;();\n        for(int curr=0;curr&lt;s.length();curr++){\n            char c=s.charAt(curr);\n            if(c=='(' || c=='[' || c=='{') //如果是左括号，压入栈中\n                stack.push(c);\n            else if(c==')'){               //如果是右括号，检查栈是否为空，不为空的话检查是否匹配\n                if(stack.isEmpty() || stack.pop()!='(')return false; //注意isEmpty在前\n            }\n            else if(c==']'){\n                if(stack.isEmpty() || stack.pop()!='[')return false;\n            }\n            else if(c=='}'){\n                if(stack.isEmpty() || stack.pop()!='{')return false;\n            }\n        }\n        return stack.isEmpty();//最后如果栈空则为ture,否则为false\n    }\n}\n</code></pre>\n<h1 id=\"28-Implement-strStr\"><a href=\"https://leetcode-cn.com/problems/implement-strstr/\" target=\"_blank\" rel=\"noopener\">28. Implement strStr()</a></h1>\n<p><a href=\"String-Easy/image-20200226235401209.png\" title=\"image-20200226235401209\" class=\"gallery-item\"><img src=\"image-20200226235401209.png\" alt=\"image-20200226235401209\"></a></p>\n<h2 id=\"解法一：猥琐API法（太脏了，自裁）\">解法一：猥琐API法（<mark>太脏了，自裁</mark>）</h2>\n<pre><code class=\"language-java\">class Solution {\n    public int strStr(String haystack, String needle) {\n        return haystack.indexOf(needle); //这题要实现的就是indexOf的功能\n    }\n}\n</code></pre>\n<h2 id=\"解法二：暴力匹配\">解法二：暴力匹配</h2>\n<pre><code class=\"language-java\">class Solution {\n    public int strStr(String haystack, String needle) {\n        //以下三者均会卡掉for循环，需要特别处理，且equals要第一个判定，否则第二条需要进一步限定\n        if(haystack.equals(needle))return 0;                     //字典等于词\n        if(haystack.length()==0)return -1;                       //字典为空\n        if(needle.length()==0) return 0;                         //词为空\n        \n        //注意curr_hay&lt;haystack.length()-needle.length()+1，必须+1，否则匹配不到最后一位\n        for(int curr_hay=0;curr_hay&lt;haystack.length()-needle.length()+1;curr_hay++){\n            for(int curr_nee=0;curr_nee&lt;needle.length();curr_nee++){\n                if(haystack.charAt(curr_hay+curr_nee)!=needle.charAt(curr_nee))\n                    break;\n                if(curr_nee==needle.length()-1)//匹配到最后一个依然正确，返回此时的curr_hay\n                    return curr_hay;\n            }\n        }\n        return -1; //没找到则返回-1\n    }\n}\n</code></pre>\n<h2 id=\"解法三：KMP（以后再说吧）\">解法三：KMP（<mark>以后再说吧</mark>）</h2>\n<pre><code class=\"language-java\">//问就是不会\n</code></pre>\n<h1 id=\"58-Length-of-Last-Word\"><a href=\"https://leetcode-cn.com/problems/length-of-last-word/\" target=\"_blank\" rel=\"noopener\">58. Length of Last Word</a></h1>\n<p><a href=\"String-Easy/image-20200226235519434.png\" title=\"image-20200226235519434\" class=\"gallery-item\"><img src=\"image-20200226235519434.png\" alt=\"image-20200226235519434\"></a></p>\n<h2 id=\"要点分析\">要点分析</h2>\n<ul>\n<li><strong>特殊情况</strong>：末尾有空格</li>\n<li>如何找到最后一个空格？</li>\n<li>连续空格怎么处理？</li>\n</ul>\n<h2 id=\"解法一：分段切割\">解法一：分段切割</h2>\n<ul>\n<li><strong>缺点</strong>：substring耗时，trim耗时</li>\n</ul>\n<pre><code class=\"language-java\">class Solution {\n    public int lengthOfLastWord(String s) {\n       s=s.trim(); //开局剪切，保证末尾没有空格\n       String res=s;\n       for(int i=0;i&lt;s.length();i++){\n           if(s.charAt(i)==' ')res=s.substring(i+1,s.length()); //每遇到一个空格，把前面的砍掉\n       }\n       return res.length(); //最后的长度即为所求\n    }\n}\n</code></pre>\n<ul>\n<li>改进版，从后往前切割，大大节省时间</li>\n</ul>\n<pre><code class=\"language-java\">class Solution {\n    public int lengthOfLastWord(String s) {\n       s=s.trim(); //开局剪切，保证末尾没有空格\n       String res=s;\n       for(int i=s.length()-1;i&gt;-1;i--){ //从后往前砍\n           if(s.charAt(i)==' '){return s.substring(i+1,s.length());}\n       }\n       return res.length(); //最后的长度即为所求\n    }\n}\n</code></pre>\n<script src=\"https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js\"></script><script>if (typeof lightGallery !== 'undefined') {\n        var options = {\n            selector: '.gallery-item'\n        };\n        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);\n        }</script>","categories":[{"name":"Algorithm","path":"api/categories/Algorithm.json"}],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"}]}