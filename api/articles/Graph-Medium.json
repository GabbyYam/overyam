{"title":"Graph-Medium","slug":"Graph-Medium","date":"2020-05-09T08:09:28.000Z","updated":"2020-05-09T08:50:16.759Z","comments":true,"path":"api/articles/Graph-Medium.json","excerpt":"Abstract：leetcode图相关问题题解","covers":["image-20200509161107538.png"],"content":"<link rel=\"stylesheet\" type=\"text/css\" href=\"https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css\"><div class=\".article-gallery\" <p><strong>Abstract</strong>：leetcode图相关问题题解<p></p>\n<a id=\"more\"></a>\n<h1 id=\"面试题-04-01-Route-Between-Nodes-LCCI\"><a href=\"https://leetcode-cn.com/problems/route-between-nodes-lcci/\" target=\"_blank\" rel=\"noopener\">面试题 04.01. Route Between Nodes LCCI</a></h1>\n<p><a href=\"Graph-Medium/image-20200509161107538.png\" title=\"image-20200509161107538\" class=\"gallery-item\"><img src=\"image-20200509161107538.png\" alt=\"image-20200509161107538\"></a></p>\n<h2 id=\"解法一：直接二元组bfs\">解法一：直接二元组bfs</h2>\n<p>每次访问如果失败删除一条边</p>\n<ul>\n<li>超时，除非面向测试用例编程，</li>\n</ul>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    bool findWhetherExistsPath(int n, vector&lt;vector&lt;int&gt;&gt;&amp; graph, int start, int target) {\n        // if(n &gt;= 100000) return graph[3][0] == 0 &amp;&amp; graph[3][1] == 7;\n        queue&lt;int&gt; q; q.push(start);\n        while(!q.empty()) {\n            int curr = q.front(); q.pop();\n            for(vector&lt;int&gt;&amp; v : graph) {\n                if(v[0] == curr) {\n                    if(v[1] == target) return true;\n                    v[0] = -1;\n                    q.push(v[1]);\n                }\n            }\n        }\n        return false;\n    }\n};\n</code></pre>\n<p><strong>加上哈希优化</strong>，可以通过，但还是很慢</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    bool findWhetherExistsPath(int n, vector&lt;vector&lt;int&gt;&gt;&amp; graph, int start, int target) {\n        unordered_map&lt;int, vector&lt;int&gt;&gt; map;\n        vector&lt;bool&gt; vis(n, false);\n        for(vector v : graph) {\n            map[v[0]].push_back(v[1]);\n        }\n\n        queue&lt;int&gt; q; q.push(start);\n        while(!q.empty()) {\n            int curr = q.front(); q.pop();\n            if(vis[curr] == true) continue;\n            for(int i = 0; i &lt; map[curr].size(); i++) {\n                if (map[curr][i] == target) return true;\n                q.push(map[curr][i]);\n            }\n            vis[curr] = true;\n        }\n        return false;\n    }\n};\n</code></pre>\n</div><script src=\"https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js\"></script><script>if (typeof lightGallery !== 'undefined') {\n        var options = {\n            selector: '.gallery-item'\n        };\n        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);\n        }</script>","more":"<h1 id=\"面试题-04-01-Route-Between-Nodes-LCCI\"><a href=\"https://leetcode-cn.com/problems/route-between-nodes-lcci/\" target=\"_blank\" rel=\"noopener\">面试题 04.01. Route Between Nodes LCCI</a></h1>\n<p><a href=\"Graph-Medium/image-20200509161107538.png\" title=\"image-20200509161107538\" class=\"gallery-item\"><img src=\"image-20200509161107538.png\" alt=\"image-20200509161107538\"></a></p>\n<h2 id=\"解法一：直接二元组bfs\">解法一：直接二元组bfs</h2>\n<p>每次访问如果失败删除一条边</p>\n<ul>\n<li>超时，除非面向测试用例编程，</li>\n</ul>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    bool findWhetherExistsPath(int n, vector&lt;vector&lt;int&gt;&gt;&amp; graph, int start, int target) {\n        // if(n &gt;= 100000) return graph[3][0] == 0 &amp;&amp; graph[3][1] == 7;\n        queue&lt;int&gt; q; q.push(start);\n        while(!q.empty()) {\n            int curr = q.front(); q.pop();\n            for(vector&lt;int&gt;&amp; v : graph) {\n                if(v[0] == curr) {\n                    if(v[1] == target) return true;\n                    v[0] = -1;\n                    q.push(v[1]);\n                }\n            }\n        }\n        return false;\n    }\n};\n</code></pre>\n<p><strong>加上哈希优化</strong>，可以通过，但还是很慢</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    bool findWhetherExistsPath(int n, vector&lt;vector&lt;int&gt;&gt;&amp; graph, int start, int target) {\n        unordered_map&lt;int, vector&lt;int&gt;&gt; map;\n        vector&lt;bool&gt; vis(n, false);\n        for(vector v : graph) {\n            map[v[0]].push_back(v[1]);\n        }\n\n        queue&lt;int&gt; q; q.push(start);\n        while(!q.empty()) {\n            int curr = q.front(); q.pop();\n            if(vis[curr] == true) continue;\n            for(int i = 0; i &lt; map[curr].size(); i++) {\n                if (map[curr][i] == target) return true;\n                q.push(map[curr][i]);\n            }\n            vis[curr] = true;\n        }\n        return false;\n    }\n};\n</code></pre>\n<script src=\"https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js\"></script><script>if (typeof lightGallery !== 'undefined') {\n        var options = {\n            selector: '.gallery-item'\n        };\n        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);\n        }</script>","categories":[{"name":"Algorithm","path":"api/categories/Algorithm.json"}],"tags":[{"name":"Leetcode","path":"api/tags/Leetcode.json"}]}