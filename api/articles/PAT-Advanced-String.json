{"title":"PAT-Advanced String","slug":"PAT-Advanced-String","date":"2020-04-08T10:16:26.000Z","updated":"2020-04-22T12:15:37.556Z","comments":true,"path":"api/articles/PAT-Advanced-String.json","excerpt":"Abstract：PAT 字符串相关","covers":["image-20200408181841355.png","image-20200412173628280.png","image-20200421152758509.png","image-20200422164012910.png"],"content":"<link rel=\"stylesheet\" type=\"text/css\" href=\"https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css\"><div class=\".article-gallery\" <p><strong>Abstract</strong>：PAT 字符串相关<p></p>\n<a id=\"more\"></a>\n<h1 id=\"1061-Dating-20分\"><a href=\"https://pintia.cn/problem-sets/994805342720868352/problems/994805411985604608\" target=\"_blank\" rel=\"noopener\">1061 Dating (20分)</a></h1>\n<p><a href=\"PAT-Advanced-String/image-20200408181841355.png\" title=\"image-20200408181841355\" class=\"gallery-item\"><img src=\"image-20200408181841355.png\" alt=\"image-20200408181841355\"></a></p>\n<h1 id=\"解法一\">解法一</h1>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\n\nint d, h, m;\nstd::string s1, s2, s3, s4;\n\nvoid parse_input() { // 自己写的时候也很蛋疼，如果你觉得有点乱就看看别人的题解吧\n\tstd::cin &gt;&gt; s1 &gt;&gt; s2 &gt;&gt; s3 &gt;&gt; s4;\n\tfor (unsigned int i = 0, idx = 0; i &lt; s1.length() &amp;&amp; i &lt; s2.length(); i++) {\n\t\tif (s1[i] == s2[i]) { // 前提是两者相同       \n\t\t\t// 先找day\n\t\t\tif (idx == 0 &amp;&amp; s1[i] &gt;= 'A' &amp;&amp; s1[i] &lt;= 'G')                        \n\t\t\t\t{ d = s1[i] - 'A' + 1; idx++; continue; }\n\t\t\t// 再找hour, isdigit可以简化判断, 以0-9和A-N计算结果\n\t\t\tif (idx == 1 &amp;&amp; ((s1[i] &gt;= 'A' &amp;&amp; s1[i] &lt;= 'N') || isdigit(s1[i])))\n\t\t\t\t{ h = isdigit(s1[i]) ? s1[i] - '0' : s1[i] - 'A' + 10; break; }           \t\t\n\t\t}\n\t}\n\tfor (unsigned int i = 0; i &lt; s3.length() &amp;&amp; i &lt; s4.length();i++) {\n\t\tif (s3[i] == s4[i] &amp;&amp; isalpha(s3[i])) { m = i; break; }   // 直接取得索引就行\n\t}\n}\n\nstd::string get_day(int day) {\n\tswitch (day) {\n\t\tcase 1: return &quot;MON&quot;;\n\t\tcase 2: return &quot;TUE&quot;;\n\t\tcase 3: return &quot;WED&quot;;\n\t\tcase 4: return &quot;THU&quot;;\n\t\tcase 5: return &quot;FRI&quot;;\n\t\tcase 6: return &quot;SAT&quot;;\n\t\tcase 7: return &quot;SUN&quot;;\n\t}\n}\n\nint main(){\n\tparse_input();\n\tstd::string day = get_day(d);\n\tstd::cout &lt;&lt; day &lt;&lt; &quot; &quot;;\n\tprintf(&quot;%02d:%02d&quot;, h, m); // 我也想用 pure C++，奈何麻烦 \t\n}\n</code></pre>\n<h1 id=\"1024-Palindromic-Number-25分\"><a href=\"https://pintia.cn/problem-sets/994805342720868352/problems/994805476473028608\" target=\"_blank\" rel=\"noopener\">1024 Palindromic Number (25分)</a></h1>\n<p><a href=\"PAT-Advanced-String/image-20200412173628280.png\" title=\"image-20200412173628280\" class=\"gallery-item\"><img src=\"image-20200412173628280.png\" alt=\"image-20200412173628280\"></a></p>\n<h2 id=\"解法一-v2\">解法一</h2>\n<p>10的10次方，显然是要用字符串来模拟大数加减法的</p>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\n#include&lt;string&gt;\n\nint k;\nstd::string num;\n\nbool isPalindromic(std::string&amp; s) {\n\tint i = 0, j = s.size() - 1;\n\twhile (i &lt;= j) {\n\t\tif (s[i] != s[j])return false;\n\t\ti++; j--;\n\t}\n\treturn true;\n}\n\nstd::string getReverseSum(std::string a) {\n\tint carry = 0;\n\tstd::string b = a; std::reverse(b.begin(), b.end());\n\tfor (int i = 0; i &lt; a.size(); i++) {\n\t\ta[i] = a[i]+ b[i] - '0' + carry;\n\t\tif (a[i] &gt; '9') { a[i] -= 10; carry = 1; }\n\t\telse carry = 0;\n\t}\n\tif (carry) a += '1';             // 进位加在末尾再reverse就行了\n\tstd::reverse(a.begin(), a.end());\n\treturn a;\n}\n\nint main() {\n\tstd::cin &gt;&gt; num &gt;&gt; k;\n\tfor (int i = 0; i &lt; k; i++) {\n\t\tif (isPalindromic(num)) {\n\t\t\tstd::cout &lt;&lt; num &lt;&lt; std::endl &lt;&lt; i;\n\t\t\treturn 0;\n\t\t}\n\t\telse num = getReverseSum(num);\n\t}\n\tstd::cout &lt;&lt; num &lt;&lt; std::endl &lt;&lt; k;\n}\n</code></pre>\n<h1 id=\"1031-Hello-World-for-U-20分\"><a href=\"https://pintia.cn/problem-sets/994805342720868352/problems/994805462535356416\" target=\"_blank\" rel=\"noopener\">1031 Hello World for U (20分)</a></h1>\n<p><a href=\"PAT-Advanced-String/image-20200421152758509.png\" title=\"image-20200421152758509\" class=\"gallery-item\"><img src=\"image-20200421152758509.png\" alt=\"image-20200421152758509\"></a></p>\n<h2 id=\"解法一-v3\">解法一</h2>\n<p>关键在于知道怎么分割，题目要求U字要尽可能地“方”，而且给出了明确的表达式：</p>\n<p><code>n1 = n3 = max{ n2 | n1 + n2 + n3 + 2 = N }</code></p>\n<p>显然在最后一行之前应该有 <code>N / 3</code>行，也就是 <code>n1 = n3 = 1+(N/3)</code>，因为<code>len / 3 = (len + 2) / 3</code></p>\n<p>最后一行的长度为</p>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\n\nint main() {\n\tstd::string s;\n\tstd::cin &gt;&gt; s;\n\tint len = s.length() - 1, i = 0, num = len / 3 + len % 3;\n\tfor (i = 0; i &lt; len / 3; i++) {\n\t\tstd::cout &lt;&lt; s[i];\n\t\tfor (int k = 0; k &lt; num - 1; k++) std::cout &lt;&lt; &quot; &quot;;\n\t\tstd::cout&lt;&lt; s[len - i] &lt;&lt; std::endl;\n\t}\n\tstd::cout &lt;&lt; s.substr(i, num + 1);\n}\n</code></pre>\n<h1 id=\"1038-Recover-the-Smallest-Number-30分\"><a href=\"https://pintia.cn/problem-sets/994805342720868352/problems/994805449625288704\" target=\"_blank\" rel=\"noopener\">1038 Recover the Smallest Number (30分)</a></h1>\n<p><a href=\"PAT-Advanced-String/image-20200422164012910.png\" title=\"image-20200422164012910\" class=\"gallery-item\"><img src=\"image-20200422164012910.png\" alt=\"image-20200422164012910\"></a></p>\n<h2 id=\"解法一-v4\">解法一</h2>\n<p>字符串排序，逐一对比，如果长度不同，长的那个截断前半部分，递归比较</p>\n<p>记得处理前导零，还要注意一种特殊情况，全是0时，此时需要输出0，也即全程前导零</p>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\n#include&lt;vector&gt;\n#include&lt;algorithm&gt;\n\nint compare(const std::string s1, const std::string s2) {\n\tint len1 = s1.length(), len2 = s2.length(), len = std::min(len1, len2);\n\tfor (int i = 0; i &lt; len; i++)\n\t\tif (s1[i] != s2[i]) return s1[i] &lt; s2[i];\n\t\n\tif (len1 &gt; len2)\n\t\treturn compare(s1.substr(len, len1 - len), s2);\n\telse if (len1 &lt; len2)\n\t\treturn compare(s1, s2.substr(len, len2 - len));\n\telse return 0;\n}\n\nint main() {\n\tint num;\n\tstd::cin &gt;&gt; num;\n\tstd::vector&lt;std::string&gt; list = std::vector&lt;std::string&gt;(num);\n\tfor (int i = 0; i &lt; num; i++) std::cin &gt;&gt; list[i];\n\n\tstd::sort(list.begin(), list.end(), compare);\n\n\tbool leadingZero = true;\n\tfor (const std::string&amp; s : list) {\n\t\tfor (char c : s) {\n\t\t\tif (leadingZero &amp;&amp; c == '0') continue;\n\t\t\tif (leadingZero &amp;&amp; c != '0') leadingZero = false;\n\t\t\tstd::cout &lt;&lt; c;\n\t\t}\n\t}\n\tif (leadingZero) std::cout &lt;&lt; 0; // 特殊处理全0\n}\n</code></pre>\n<h2 id=\"解法二\">解法二</h2>\n<p>另一种方法是直接用string自带的比较去做，直接比较 s1+s2 和 s2+s1 可以直接得出结果，但是速度略慢一些，因为字符串拼接需要复制整串到一个新的char数组里，反复拼接的消耗还是比较大的</p>\n<pre><code class=\"language-cpp\">int compare(const std::string&amp; s1, const std::string&amp; s2){\n    return s1 + s2 &lt; s2 + s1;\n}\n</code></pre>\n</div><script src=\"https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js\"></script><script>if (typeof lightGallery !== 'undefined') {\n        var options = {\n            selector: '.gallery-item'\n        };\n        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);\n        }</script>","more":"<h1 id=\"1061-Dating-20分\"><a href=\"https://pintia.cn/problem-sets/994805342720868352/problems/994805411985604608\" target=\"_blank\" rel=\"noopener\">1061 Dating (20分)</a></h1>\n<p><a href=\"PAT-Advanced-String/image-20200408181841355.png\" title=\"image-20200408181841355\" class=\"gallery-item\"><img src=\"image-20200408181841355.png\" alt=\"image-20200408181841355\"></a></p>\n<h1 id=\"解法一\">解法一</h1>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\n\nint d, h, m;\nstd::string s1, s2, s3, s4;\n\nvoid parse_input() { // 自己写的时候也很蛋疼，如果你觉得有点乱就看看别人的题解吧\n\tstd::cin &gt;&gt; s1 &gt;&gt; s2 &gt;&gt; s3 &gt;&gt; s4;\n\tfor (unsigned int i = 0, idx = 0; i &lt; s1.length() &amp;&amp; i &lt; s2.length(); i++) {\n\t\tif (s1[i] == s2[i]) { // 前提是两者相同       \n\t\t\t// 先找day\n\t\t\tif (idx == 0 &amp;&amp; s1[i] &gt;= 'A' &amp;&amp; s1[i] &lt;= 'G')                        \n\t\t\t\t{ d = s1[i] - 'A' + 1; idx++; continue; }\n\t\t\t// 再找hour, isdigit可以简化判断, 以0-9和A-N计算结果\n\t\t\tif (idx == 1 &amp;&amp; ((s1[i] &gt;= 'A' &amp;&amp; s1[i] &lt;= 'N') || isdigit(s1[i])))\n\t\t\t\t{ h = isdigit(s1[i]) ? s1[i] - '0' : s1[i] - 'A' + 10; break; }           \t\t\n\t\t}\n\t}\n\tfor (unsigned int i = 0; i &lt; s3.length() &amp;&amp; i &lt; s4.length();i++) {\n\t\tif (s3[i] == s4[i] &amp;&amp; isalpha(s3[i])) { m = i; break; }   // 直接取得索引就行\n\t}\n}\n\nstd::string get_day(int day) {\n\tswitch (day) {\n\t\tcase 1: return &quot;MON&quot;;\n\t\tcase 2: return &quot;TUE&quot;;\n\t\tcase 3: return &quot;WED&quot;;\n\t\tcase 4: return &quot;THU&quot;;\n\t\tcase 5: return &quot;FRI&quot;;\n\t\tcase 6: return &quot;SAT&quot;;\n\t\tcase 7: return &quot;SUN&quot;;\n\t}\n}\n\nint main(){\n\tparse_input();\n\tstd::string day = get_day(d);\n\tstd::cout &lt;&lt; day &lt;&lt; &quot; &quot;;\n\tprintf(&quot;%02d:%02d&quot;, h, m); // 我也想用 pure C++，奈何麻烦 \t\n}\n</code></pre>\n<h1 id=\"1024-Palindromic-Number-25分\"><a href=\"https://pintia.cn/problem-sets/994805342720868352/problems/994805476473028608\" target=\"_blank\" rel=\"noopener\">1024 Palindromic Number (25分)</a></h1>\n<p><a href=\"PAT-Advanced-String/image-20200412173628280.png\" title=\"image-20200412173628280\" class=\"gallery-item\"><img src=\"image-20200412173628280.png\" alt=\"image-20200412173628280\"></a></p>\n<h2 id=\"解法一-v2\">解法一</h2>\n<p>10的10次方，显然是要用字符串来模拟大数加减法的</p>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\n#include&lt;string&gt;\n\nint k;\nstd::string num;\n\nbool isPalindromic(std::string&amp; s) {\n\tint i = 0, j = s.size() - 1;\n\twhile (i &lt;= j) {\n\t\tif (s[i] != s[j])return false;\n\t\ti++; j--;\n\t}\n\treturn true;\n}\n\nstd::string getReverseSum(std::string a) {\n\tint carry = 0;\n\tstd::string b = a; std::reverse(b.begin(), b.end());\n\tfor (int i = 0; i &lt; a.size(); i++) {\n\t\ta[i] = a[i]+ b[i] - '0' + carry;\n\t\tif (a[i] &gt; '9') { a[i] -= 10; carry = 1; }\n\t\telse carry = 0;\n\t}\n\tif (carry) a += '1';             // 进位加在末尾再reverse就行了\n\tstd::reverse(a.begin(), a.end());\n\treturn a;\n}\n\nint main() {\n\tstd::cin &gt;&gt; num &gt;&gt; k;\n\tfor (int i = 0; i &lt; k; i++) {\n\t\tif (isPalindromic(num)) {\n\t\t\tstd::cout &lt;&lt; num &lt;&lt; std::endl &lt;&lt; i;\n\t\t\treturn 0;\n\t\t}\n\t\telse num = getReverseSum(num);\n\t}\n\tstd::cout &lt;&lt; num &lt;&lt; std::endl &lt;&lt; k;\n}\n</code></pre>\n<h1 id=\"1031-Hello-World-for-U-20分\"><a href=\"https://pintia.cn/problem-sets/994805342720868352/problems/994805462535356416\" target=\"_blank\" rel=\"noopener\">1031 Hello World for U (20分)</a></h1>\n<p><a href=\"PAT-Advanced-String/image-20200421152758509.png\" title=\"image-20200421152758509\" class=\"gallery-item\"><img src=\"image-20200421152758509.png\" alt=\"image-20200421152758509\"></a></p>\n<h2 id=\"解法一-v3\">解法一</h2>\n<p>关键在于知道怎么分割，题目要求U字要尽可能地“方”，而且给出了明确的表达式：</p>\n<p><code>n1 = n3 = max{ n2 | n1 + n2 + n3 + 2 = N }</code></p>\n<p>显然在最后一行之前应该有 <code>N / 3</code>行，也就是 <code>n1 = n3 = 1+(N/3)</code>，因为<code>len / 3 = (len + 2) / 3</code></p>\n<p>最后一行的长度为</p>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\n\nint main() {\n\tstd::string s;\n\tstd::cin &gt;&gt; s;\n\tint len = s.length() - 1, i = 0, num = len / 3 + len % 3;\n\tfor (i = 0; i &lt; len / 3; i++) {\n\t\tstd::cout &lt;&lt; s[i];\n\t\tfor (int k = 0; k &lt; num - 1; k++) std::cout &lt;&lt; &quot; &quot;;\n\t\tstd::cout&lt;&lt; s[len - i] &lt;&lt; std::endl;\n\t}\n\tstd::cout &lt;&lt; s.substr(i, num + 1);\n}\n</code></pre>\n<h1 id=\"1038-Recover-the-Smallest-Number-30分\"><a href=\"https://pintia.cn/problem-sets/994805342720868352/problems/994805449625288704\" target=\"_blank\" rel=\"noopener\">1038 Recover the Smallest Number (30分)</a></h1>\n<p><a href=\"PAT-Advanced-String/image-20200422164012910.png\" title=\"image-20200422164012910\" class=\"gallery-item\"><img src=\"image-20200422164012910.png\" alt=\"image-20200422164012910\"></a></p>\n<h2 id=\"解法一-v4\">解法一</h2>\n<p>字符串排序，逐一对比，如果长度不同，长的那个截断前半部分，递归比较</p>\n<p>记得处理前导零，还要注意一种特殊情况，全是0时，此时需要输出0，也即全程前导零</p>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\n#include&lt;vector&gt;\n#include&lt;algorithm&gt;\n\nint compare(const std::string s1, const std::string s2) {\n\tint len1 = s1.length(), len2 = s2.length(), len = std::min(len1, len2);\n\tfor (int i = 0; i &lt; len; i++)\n\t\tif (s1[i] != s2[i]) return s1[i] &lt; s2[i];\n\t\n\tif (len1 &gt; len2)\n\t\treturn compare(s1.substr(len, len1 - len), s2);\n\telse if (len1 &lt; len2)\n\t\treturn compare(s1, s2.substr(len, len2 - len));\n\telse return 0;\n}\n\nint main() {\n\tint num;\n\tstd::cin &gt;&gt; num;\n\tstd::vector&lt;std::string&gt; list = std::vector&lt;std::string&gt;(num);\n\tfor (int i = 0; i &lt; num; i++) std::cin &gt;&gt; list[i];\n\n\tstd::sort(list.begin(), list.end(), compare);\n\n\tbool leadingZero = true;\n\tfor (const std::string&amp; s : list) {\n\t\tfor (char c : s) {\n\t\t\tif (leadingZero &amp;&amp; c == '0') continue;\n\t\t\tif (leadingZero &amp;&amp; c != '0') leadingZero = false;\n\t\t\tstd::cout &lt;&lt; c;\n\t\t}\n\t}\n\tif (leadingZero) std::cout &lt;&lt; 0; // 特殊处理全0\n}\n</code></pre>\n<h2 id=\"解法二\">解法二</h2>\n<p>另一种方法是直接用string自带的比较去做，直接比较 s1+s2 和 s2+s1 可以直接得出结果，但是速度略慢一些，因为字符串拼接需要复制整串到一个新的char数组里，反复拼接的消耗还是比较大的</p>\n<pre><code class=\"language-cpp\">int compare(const std::string&amp; s1, const std::string&amp; s2){\n    return s1 + s2 &lt; s2 + s1;\n}\n</code></pre>\n<script src=\"https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js\"></script><script>if (typeof lightGallery !== 'undefined') {\n        var options = {\n            selector: '.gallery-item'\n        };\n        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);\n        }</script>","categories":[{"name":"Algorithm","path":"api/categories/Algorithm.json"}],"tags":[{"name":"PAT-A","path":"api/tags/PAT-A.json"}]}